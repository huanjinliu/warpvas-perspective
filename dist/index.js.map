{"version":3,"file":"index.js","sources":["../node_modules/.pnpm/warpvas@1.0.0/node_modules/warpvas/dist/index.esm.js","../node_modules/.pnpm/bezier-js@6.1.4/node_modules/bezier-js/src/utils.js","../node_modules/.pnpm/bezier-js@6.1.4/node_modules/bezier-js/src/poly-bezier.js","../node_modules/.pnpm/bezier-js@6.1.4/node_modules/bezier-js/src/bezier.js","../src/index.ts"],"sourcesContent":["function e(t,e,i,n){return new(i||(i=Promise))((function(r,o){function s(t){try{h(n.next(t))}catch(t){o(t)}}function a(t){try{h(n.throw(t))}catch(t){o(t)}}function h(t){var e;t.done?r(t.value):(e=t.value,e instanceof i?e:new i((function(t){t(e)}))).then(s,a)}h((n=n.apply(t,e||[])).next())}))}\"function\"==typeof SuppressedError&&SuppressedError;const{abs:i,cos:n,sin:r,acos:o,atan2:s,sqrt:a,pow:h}=Math;function c(t){return t<0?-h(-t,1/3):h(t,1/3)}const l=Math.PI,u=2*l,p=l/2,g=Number.MAX_SAFE_INTEGER||9007199254740991,x=Number.MIN_SAFE_INTEGER||-9007199254740991,f={x:0,y:0,z:0},y={Tvalues:[-.06405689286260563,.06405689286260563,-.1911188674736163,.1911188674736163,-.3150426796961634,.3150426796961634,-.4337935076260451,.4337935076260451,-.5454214713888396,.5454214713888396,-.6480936519369755,.6480936519369755,-.7401241915785544,.7401241915785544,-.820001985973903,.820001985973903,-.8864155270044011,.8864155270044011,-.9382745520027328,.9382745520027328,-.9747285559713095,.9747285559713095,-.9951872199970213,.9951872199970213],Cvalues:[.12793819534675216,.12793819534675216,.1258374563468283,.1258374563468283,.12167047292780339,.12167047292780339,.1155056680537256,.1155056680537256,.10744427011596563,.10744427011596563,.09761865210411388,.09761865210411388,.08619016153195327,.08619016153195327,.0733464814110803,.0733464814110803,.05929858491543678,.05929858491543678,.04427743881741981,.04427743881741981,.028531388628933663,.028531388628933663,.0123412297999872,.0123412297999872],arcfn:function(t,e){const i=e(t);let n=i.x*i.x+i.y*i.y;return void 0!==i.z&&(n+=i.z*i.z),a(n)},compute:function(t,e,i){if(0===t)return e[0].t=0,e[0];const n=e.length-1;if(1===t)return e[n].t=1,e[n];const r=1-t;let o=e;if(0===n)return e[0].t=t,e[0];if(1===n){const e={x:r*o[0].x+t*o[1].x,y:r*o[0].y+t*o[1].y,t:t};return i&&(e.z=r*o[0].z+t*o[1].z),e}if(n<4){let e,s,a,h=r*r,c=t*t,l=0;2===n?(o=[o[0],o[1],o[2],f],e=h,s=r*t*2,a=c):3===n&&(e=h*r,s=h*t*3,a=r*c*3,l=t*c);const u={x:e*o[0].x+s*o[1].x+a*o[2].x+l*o[3].x,y:e*o[0].y+s*o[1].y+a*o[2].y+l*o[3].y,t:t};return i&&(u.z=e*o[0].z+s*o[1].z+a*o[2].z+l*o[3].z),u}const s=JSON.parse(JSON.stringify(e));for(;s.length>1;){for(let e=0;e<s.length-1;e++)s[e]={x:s[e].x+(s[e+1].x-s[e].x)*t,y:s[e].y+(s[e+1].y-s[e].y)*t},void 0!==s[e].z&&(s[e].z=s[e].z+(s[e+1].z-s[e].z)*t);s.splice(s.length-1,1)}return s[0].t=t,s[0]},computeWithRatios:function(t,e,i,n){const r=1-t,o=i,s=e;let a,h=o[0],c=o[1],l=o[2],u=o[3];return h*=r,c*=t,2===s.length?(a=h+c,{x:(h*s[0].x+c*s[1].x)/a,y:(h*s[0].y+c*s[1].y)/a,z:!!n&&(h*s[0].z+c*s[1].z)/a,t:t}):(h*=r,c*=2*r,l*=t*t,3===s.length?(a=h+c+l,{x:(h*s[0].x+c*s[1].x+l*s[2].x)/a,y:(h*s[0].y+c*s[1].y+l*s[2].y)/a,z:!!n&&(h*s[0].z+c*s[1].z+l*s[2].z)/a,t:t}):(h*=r,c*=1.5*r,l*=3*r,u*=t*t*t,4===s.length?(a=h+c+l+u,{x:(h*s[0].x+c*s[1].x+l*s[2].x+u*s[3].x)/a,y:(h*s[0].y+c*s[1].y+l*s[2].y+u*s[3].y)/a,z:!!n&&(h*s[0].z+c*s[1].z+l*s[2].z+u*s[3].z)/a,t:t}):void 0))},derive:function(t,e){const i=[];for(let n=t,r=n.length,o=r-1;r>1;r--,o--){const t=[];for(let i,r=0;r<o;r++)i={x:o*(n[r+1].x-n[r].x),y:o*(n[r+1].y-n[r].y)},e&&(i.z=o*(n[r+1].z-n[r].z)),t.push(i);i.push(t),n=t}return i},between:function(t,e,i){return e<=t&&t<=i||y.approximately(t,e)||y.approximately(t,i)},approximately:function(t,e,n){return i(t-e)<=(n||1e-6)},length:function(t){const e=y.Tvalues.length;let i=0;for(let n,r=0;r<e;r++)n=.5*y.Tvalues[r]+.5,i+=y.Cvalues[r]*y.arcfn(n,t);return.5*i},map:function(t,e,i,n,r){return n+(r-n)*((t-e)/(i-e))},lerp:function(t,e,i){const n={x:e.x+t*(i.x-e.x),y:e.y+t*(i.y-e.y)};return void 0!==e.z&&void 0!==i.z&&(n.z=e.z+t*(i.z-e.z)),n},pointToString:function(t){let e=t.x+\"/\"+t.y;return void 0!==t.z&&(e+=\"/\"+t.z),e},pointsToString:function(t){return\"[\"+t.map(y.pointToString).join(\", \")+\"]\"},copy:function(t){return JSON.parse(JSON.stringify(t))},angle:function(t,e,i){const n=e.x-t.x,r=e.y-t.y,o=i.x-t.x,a=i.y-t.y;return s(n*a-r*o,n*o+r*a)},round:function(t,e){const i=\"\"+t,n=i.indexOf(\".\");return parseFloat(i.substring(0,n+1+e))},dist:function(t,e){const i=t.x-e.x,n=t.y-e.y;return a(i*i+n*n)},closest:function(t,e){let i,n,r=h(2,63);return t.forEach((function(t,o){n=y.dist(e,t),n<r&&(r=n,i=o)})),{mdist:r,mpos:i}},abcratio:function(t,e){if(2!==e&&3!==e)return!1;if(void 0===t)t=.5;else if(0===t||1===t)return t;const n=h(t,e)+h(1-t,e);return i((n-1)/n)},projectionratio:function(t,e){if(2!==e&&3!==e)return!1;if(void 0===t)t=.5;else if(0===t||1===t)return t;const i=h(1-t,e);return i/(h(t,e)+i)},lli8:function(t,e,i,n,r,o,s,a){const h=(t-i)*(o-a)-(e-n)*(r-s);return 0!=h&&{x:((t*n-e*i)*(r-s)-(t-i)*(r*a-o*s))/h,y:((t*n-e*i)*(o-a)-(e-n)*(r*a-o*s))/h}},lli4:function(t,e,i,n){const r=t.x,o=t.y,s=e.x,a=e.y,h=i.x,c=i.y,l=n.x,u=n.y;return y.lli8(r,o,s,a,h,c,l,u)},lli:function(t,e){return y.lli4(t,t.c,e,e.c)},makeline:function(t,e){return new T(t.x,t.y,(t.x+e.x)/2,(t.y+e.y)/2,e.x,e.y)},findbbox:function(t){let e=g,i=g,n=x,r=x;return t.forEach((function(t){const o=t.bbox();e>o.x.min&&(e=o.x.min),i>o.y.min&&(i=o.y.min),n<o.x.max&&(n=o.x.max),r<o.y.max&&(r=o.y.max)})),{x:{min:e,mid:(e+n)/2,max:n,size:n-e},y:{min:i,mid:(i+r)/2,max:r,size:r-i}}},shapeintersections:function(t,e,i,n,r){if(!y.bboxoverlap(e,n))return[];const o=[],s=[t.startcap,t.forward,t.back,t.endcap],a=[i.startcap,i.forward,i.back,i.endcap];return s.forEach((function(e){e.virtual||a.forEach((function(n){if(n.virtual)return;const s=e.intersects(n,r);s.length>0&&(s.c1=e,s.c2=n,s.s1=t,s.s2=i,o.push(s))}))})),o},makeshape:function(t,e,i){const n=e.points.length,r=t.points.length,o=y.makeline(e.points[n-1],t.points[0]),s=y.makeline(t.points[r-1],e.points[0]),a={startcap:o,forward:t,back:e,endcap:s,bbox:y.findbbox([o,t,e,s]),intersections:function(t){return y.shapeintersections(a,a.bbox,t,t.bbox,i)}};return a},getminmax:function(t,e,i){if(!i)return{min:0,max:0};let n,r,o=g,s=x;-1===i.indexOf(0)&&(i=[0].concat(i)),-1===i.indexOf(1)&&i.push(1);for(let a=0,h=i.length;a<h;a++)n=i[a],r=t.get(n),r[e]<o&&(o=r[e]),r[e]>s&&(s=r[e]);return{min:o,mid:(o+s)/2,max:s,size:s-o}},align:function(t,e){const i=e.p1.x,o=e.p1.y,a=-s(e.p2.y-o,e.p2.x-i);return t.map((function(t){return{x:(t.x-i)*n(a)-(t.y-o)*r(a),y:(t.x-i)*r(a)+(t.y-o)*n(a)}}))},roots:function(t,e){e=e||{p1:{x:0,y:0},p2:{x:1,y:0}};const i=t.length-1,r=y.align(t,e),s=function(t){return 0<=t&&t<=1};if(2===i){const t=r[0].y,e=r[1].y,i=r[2].y,n=t-2*e+i;if(0!==n){const r=-a(e*e-t*i),o=-t+e;return[-(r+o)/n,-(-r+o)/n].filter(s)}return e!==i&&0===n?[(2*e-i)/(2*e-2*i)].filter(s):[]}const h=r[0].y,l=r[1].y,p=r[2].y;let g=3*l-h-3*p+r[3].y,x=3*h-6*l+3*p,f=-3*h+3*l,d=h;if(y.approximately(g,0)){if(y.approximately(x,0))return y.approximately(f,0)?[]:[-d/f].filter(s);const t=a(f*f-4*x*d),e=2*x;return[(t-f)/e,(-f-t)/e].filter(s)}x/=g,f/=g,d/=g;const m=(3*f-x*x)/3,v=m/3,_=(2*x*x*x-9*x*f+27*d)/27,b=_/2,E=b*b+v*v*v;let w,C,z,T,R;if(E<0){const t=-m/3,e=a(t*t*t),i=-_/(2*e),r=o(i<-1?-1:i>1?1:i),h=2*c(e);return z=h*n(r/3)-x/3,T=h*n((r+u)/3)-x/3,R=h*n((r+2*u)/3)-x/3,[z,T,R].filter(s)}if(0===E)return w=b<0?c(-b):-c(b),z=2*w-x/3,T=-w-x/3,[z,T].filter(s);{const t=a(E);return w=c(-b+t),C=c(b+t),[w-C-x/3].filter(s)}},droots:function(t){if(3===t.length){const e=t[0],i=t[1],n=t[2],r=e-2*i+n;if(0!==r){const t=-a(i*i-e*n),o=-e+i;return[-(t+o)/r,-(-t+o)/r]}return i!==n&&0===r?[(2*i-n)/(2*(i-n))]:[]}if(2===t.length){const e=t[0],i=t[1];return e!==i?[e/(e-i)]:[]}return[]},curvature:function(t,e,n,r,o){let s,c,l,u,p=0,g=0;const x=y.compute(t,e),f=y.compute(t,n),d=x.x*x.x+x.y*x.y;if(r?(s=a(h(x.y*f.z-f.y*x.z,2)+h(x.z*f.x-f.z*x.x,2)+h(x.x*f.y-f.x*x.y,2)),c=h(d+x.z*x.z,1.5)):(s=x.x*f.y-x.y*f.x,c=h(d,1.5)),0===s||0===c)return{k:0,r:0};if(p=s/c,g=c/s,!o){const o=y.curvature(t-.001,e,n,r,!0).k,s=y.curvature(t+.001,e,n,r,!0).k;u=(s-p+(p-o))/2,l=(i(s-p)+i(p-o))/2}return{k:p,r:g,dk:u,adk:l}},inflections:function(t){if(t.length<4)return[];const e=y.align(t,{p1:t[0],p2:t.slice(-1)[0]}),i=e[2].x*e[1].y,n=e[3].x*e[1].y,r=e[1].x*e[2].y,o=18*(-3*i+2*n+3*r-e[3].x*e[2].y),s=18*(3*i-n-3*r),a=18*(r-i);if(y.approximately(o,0)){if(!y.approximately(s,0)){let t=-a/s;if(0<=t&&t<=1)return[t]}return[]}const h=2*o;if(y.approximately(h,0))return[];const c=s*s-4*o*a;if(c<0)return[];const l=Math.sqrt(c);return[(l-s)/h,-(s+l)/h].filter((function(t){return 0<=t&&t<=1}))},bboxoverlap:function(t,e){const n=[\"x\",\"y\"],r=n.length;for(let o,s,a,h,c=0;c<r;c++)if(o=n[c],s=t[o].mid,a=e[o].mid,h=(t[o].size+e[o].size)/2,i(s-a)>=h)return!1;return!0},expandbox:function(t,e){e.x.min<t.x.min&&(t.x.min=e.x.min),e.y.min<t.y.min&&(t.y.min=e.y.min),e.z&&e.z.min<t.z.min&&(t.z.min=e.z.min),e.x.max>t.x.max&&(t.x.max=e.x.max),e.y.max>t.y.max&&(t.y.max=e.y.max),e.z&&e.z.max>t.z.max&&(t.z.max=e.z.max),t.x.mid=(t.x.min+t.x.max)/2,t.y.mid=(t.y.min+t.y.max)/2,t.z&&(t.z.mid=(t.z.min+t.z.max)/2),t.x.size=t.x.max-t.x.min,t.y.size=t.y.max-t.y.min,t.z&&(t.z.size=t.z.max-t.z.min)},pairiteration:function(t,e,i){const n=t.bbox(),r=e.bbox(),o=1e5,s=i||.5;if(n.x.size+n.y.size<s&&r.x.size+r.y.size<s)return[(o*(t._t1+t._t2)/2|0)/o+\"/\"+(o*(e._t1+e._t2)/2|0)/o];let a=t.split(.5),h=e.split(.5),c=[{left:a.left,right:h.left},{left:a.left,right:h.right},{left:a.right,right:h.right},{left:a.right,right:h.left}];c=c.filter((function(t){return y.bboxoverlap(t.left.bbox(),t.right.bbox())}));let l=[];return 0===c.length||(c.forEach((function(t){l=l.concat(y.pairiteration(t.left,t.right,s))})),l=l.filter((function(t,e){return l.indexOf(t)===e}))),l},getccenter:function(t,e,i){const o=e.x-t.x,a=e.y-t.y,h=i.x-e.x,c=i.y-e.y,l=o*n(p)-a*r(p),g=o*r(p)+a*n(p),x=h*n(p)-c*r(p),f=h*r(p)+c*n(p),d=(t.x+e.x)/2,m=(t.y+e.y)/2,v=(e.x+i.x)/2,_=(e.y+i.y)/2,b=d+l,E=m+g,w=v+x,C=_+f,z=y.lli8(d,m,b,E,v,_,w,C),T=y.dist(z,t);let R,S=s(t.y-z.y,t.x-z.x),P=s(e.y-z.y,e.x-z.x),M=s(i.y-z.y,i.x-z.x);return S<M?((S>P||P>M)&&(S+=u),S>M&&(R=M,M=S,S=R)):M<P&&P<S?(R=M,M=S,S=R):M+=u,z.s=S,z.e=M,z.r=T,z},numberSort:function(t,e){return t-e}};class d{constructor(t){this.curves=[],this._3d=!1,t&&(this.curves=t,this._3d=this.curves[0]._3d)}valueOf(){return this.toString()}toString(){return\"[\"+this.curves.map((function(t){return y.pointsToString(t.points)})).join(\", \")+\"]\"}addCurve(t){this.curves.push(t),this._3d=this._3d||t._3d}length(){return this.curves.map((function(t){return t.length()})).reduce((function(t,e){return t+e}))}curve(t){return this.curves[t]}bbox(){const t=this.curves;for(var e=t[0].bbox(),i=1;i<t.length;i++)y.expandbox(e,t[i].bbox());return e}offset(t){const e=[];return this.curves.forEach((function(i){e.push(...i.offset(t))})),new d(e)}}const{abs:m,min:v,max:_,cos:b,sin:E,acos:w,sqrt:C}=Math,z=Math.PI;class T{constructor(t){let e=t&&t.forEach?t:Array.from(arguments).slice(),i=!1;if(\"object\"==typeof e[0]){i=e.length;const t=[];e.forEach((function(e){[\"x\",\"y\",\"z\"].forEach((function(i){void 0!==e[i]&&t.push(e[i])}))})),e=t}let n=!1;const r=e.length;if(i){if(i>4){if(1!==arguments.length)throw new Error(\"Only new Bezier(point[]) is accepted for 4th and higher order curves\");n=!0}}else if(6!==r&&8!==r&&9!==r&&12!==r&&1!==arguments.length)throw new Error(\"Only new Bezier(point[]) is accepted for 4th and higher order curves\");const o=this._3d=!n&&(9===r||12===r)||t&&t[0]&&void 0!==t[0].z,s=this.points=[];for(let t=0,i=o?3:2;t<r;t+=i){var a={x:e[t],y:e[t+1]};o&&(a.z=e[t+2]),s.push(a)}const h=this.order=s.length-1,c=this.dims=[\"x\",\"y\"];o&&c.push(\"z\"),this.dimlen=c.length;const l=y.align(s,{p1:s[0],p2:s[h]}),u=y.dist(s[0],s[h]);this._linear=l.reduce(((t,e)=>t+m(e.y)),0)<u/50,this._lut=[],this._t1=0,this._t2=1,this.update()}static quadraticFromPoints(t,e,i,n){if(void 0===n&&(n=.5),0===n)return new T(e,e,i);if(1===n)return new T(t,e,e);const r=T.getABC(2,t,e,i,n);return new T(t,r.A,i)}static cubicFromPoints(t,e,i,n,r){void 0===n&&(n=.5);const o=T.getABC(3,t,e,i,n);void 0===r&&(r=y.dist(e,o.C));const s=r*(1-n)/n,a=y.dist(t,i),h=(i.x-t.x)/a,c=(i.y-t.y)/a,l=r*h,u=r*c,p=s*h,g=s*c,x=e.x-l,f=e.y-u,d=e.x+p,m=e.y+g,v=o.A,_=v.x+(x-v.x)/(1-n),b=v.y+(f-v.y)/(1-n),E=v.x+(d-v.x)/n,w=v.y+(m-v.y)/n,C={x:t.x+(_-t.x)/n,y:t.y+(b-t.y)/n},z={x:i.x+(E-i.x)/(1-n),y:i.y+(w-i.y)/(1-n)};return new T(t,C,z,i)}static getUtils(){return y}getUtils(){return T.getUtils()}static get PolyBezier(){return d}valueOf(){return this.toString()}toString(){return y.pointsToString(this.points)}toSVG(){if(this._3d)return!1;const t=this.points,e=[\"M\",t[0].x,t[0].y,2===this.order?\"Q\":\"C\"];for(let i=1,n=t.length;i<n;i++)e.push(t[i].x),e.push(t[i].y);return e.join(\" \")}setRatios(t){if(t.length!==this.points.length)throw new Error(\"incorrect number of ratio values\");this.ratios=t,this._lut=[]}verify(){const t=this.coordDigest();t!==this._print&&(this._print=t,this.update())}coordDigest(){return this.points.map((function(t,e){return\"\"+e+t.x+t.y+(t.z?t.z:0)})).join(\"\")}update(){this._lut=[],this.dpoints=y.derive(this.points,this._3d),this.computedirection()}computedirection(){const t=this.points,e=y.angle(t[0],t[this.order],t[1]);this.clockwise=e>0}length(){return y.length(this.derivative.bind(this))}static getABC(t=2,e,i,n,r=.5){const o=y.projectionratio(r,t),s=1-o,a={x:o*e.x+s*n.x,y:o*e.y+s*n.y},h=y.abcratio(r,t);return{A:{x:i.x+(i.x-a.x)/h,y:i.y+(i.y-a.y)/h},B:i,C:a,S:e,E:n}}getABC(t,e){e=e||this.get(t);let i=this.points[0],n=this.points[this.order];return T.getABC(this.order,i,e,n,t)}getLUT(t){if(this.verify(),t=t||100,this._lut.length===t+1)return this._lut;this._lut=[],t++,this._lut=[];for(let e,i,n=0;n<t;n++)i=n/(t-1),e=this.compute(i),e.t=i,this._lut.push(e);return this._lut}on(e,i){i=i||5;const n=this.getLUT(),r=[];for(let t,o=0,s=0;o<n.length;o++)t=n[o],y.dist(t,e)<i&&(r.push(t),s+=o/n.length);return!!r.length&&(t/=r.length)}project(t){const e=this.getLUT(),i=e.length-1,n=y.closest(e,t),r=n.mpos,o=(r-1)/i,s=(r+1)/i,a=.1/i;let h,c=n.mdist,l=o,u=l;c+=1;for(let e;l<s+a;l+=a)h=this.compute(l),e=y.dist(t,h),e<c&&(c=e,u=l);return u=u<0?0:u>1?1:u,h=this.compute(u),h.t=u,h.d=c,h}get(t){return this.compute(t)}point(t){return this.points[t]}compute(t){return this.ratios?y.computeWithRatios(t,this.points,this.ratios,this._3d):y.compute(t,this.points,this._3d,this.ratios)}raise(){const t=this.points,e=[t[0]],i=t.length;for(let n,r,o=1;o<i;o++)n=t[o],r=t[o-1],e[o]={x:(i-o)/i*n.x+o/i*r.x,y:(i-o)/i*n.y+o/i*r.y};return e[i]=t[i-1],new T(e)}derivative(t){return y.compute(t,this.dpoints[0],this._3d)}dderivative(t){return y.compute(t,this.dpoints[1],this._3d)}align(){let t=this.points;return new T(y.align(t,{p1:t[0],p2:t[t.length-1]}))}curvature(t){return y.curvature(t,this.dpoints[0],this.dpoints[1],this._3d)}inflections(){return y.inflections(this.points)}normal(t){return this._3d?this.__normal3(t):this.__normal2(t)}__normal2(t){const e=this.derivative(t),i=C(e.x*e.x+e.y*e.y);return{t:t,x:-e.y/i,y:e.x/i}}__normal3(t){const e=this.derivative(t),i=this.derivative(t+.01),n=C(e.x*e.x+e.y*e.y+e.z*e.z),r=C(i.x*i.x+i.y*i.y+i.z*i.z);e.x/=n,e.y/=n,e.z/=n,i.x/=r,i.y/=r,i.z/=r;const o={x:i.y*e.z-i.z*e.y,y:i.z*e.x-i.x*e.z,z:i.x*e.y-i.y*e.x},s=C(o.x*o.x+o.y*o.y+o.z*o.z);o.x/=s,o.y/=s,o.z/=s;const a=[o.x*o.x,o.x*o.y-o.z,o.x*o.z+o.y,o.x*o.y+o.z,o.y*o.y,o.y*o.z-o.x,o.x*o.z-o.y,o.y*o.z+o.x,o.z*o.z];return{t:t,x:a[0]*e.x+a[1]*e.y+a[2]*e.z,y:a[3]*e.x+a[4]*e.y+a[5]*e.z,z:a[6]*e.x+a[7]*e.y+a[8]*e.z}}hull(t){let e=this.points,i=[],n=[],r=0;for(n[r++]=e[0],n[r++]=e[1],n[r++]=e[2],3===this.order&&(n[r++]=e[3]);e.length>1;){i=[];for(let o,s=0,a=e.length-1;s<a;s++)o=y.lerp(t,e[s],e[s+1]),n[r++]=o,i.push(o);e=i}return n}split(t,e){if(0===t&&e)return this.split(e).left;if(1===e)return this.split(t).right;const i=this.hull(t),n={left:2===this.order?new T([i[0],i[3],i[5]]):new T([i[0],i[4],i[7],i[9]]),right:2===this.order?new T([i[5],i[4],i[2]]):new T([i[9],i[8],i[6],i[3]]),span:i};return n.left._t1=y.map(0,0,1,this._t1,this._t2),n.left._t2=y.map(t,0,1,this._t1,this._t2),n.right._t1=y.map(t,0,1,this._t1,this._t2),n.right._t2=y.map(1,0,1,this._t1,this._t2),e?(e=y.map(e,t,1,0,1),n.right.split(e).left):n}extrema(){const t={};let e=[];return this.dims.forEach(function(i){let n=function(t){return t[i]},r=this.dpoints[0].map(n);t[i]=y.droots(r),3===this.order&&(r=this.dpoints[1].map(n),t[i]=t[i].concat(y.droots(r))),t[i]=t[i].filter((function(t){return t>=0&&t<=1})),e=e.concat(t[i].sort(y.numberSort))}.bind(this)),t.values=e.sort(y.numberSort).filter((function(t,i){return e.indexOf(t)===i})),t}bbox(){const t=this.extrema(),e={};return this.dims.forEach(function(i){e[i]=y.getminmax(this,i,t[i])}.bind(this)),e}overlaps(t){const e=this.bbox(),i=t.bbox();return y.bboxoverlap(e,i)}offset(t,e){if(void 0!==e){const i=this.get(t),n=this.normal(t),r={c:i,n:n,x:i.x+n.x*e,y:i.y+n.y*e};return this._3d&&(r.z=i.z+n.z*e),r}if(this._linear){const e=this.normal(0),i=this.points.map((function(i){const n={x:i.x+t*e.x,y:i.y+t*e.y};return i.z&&e.z&&(n.z=i.z+t*e.z),n}));return[new T(i)]}return this.reduce().map((function(e){return e._linear?e.offset(t)[0]:e.scale(t)}))}simple(){if(3===this.order){const t=y.angle(this.points[0],this.points[3],this.points[1]),e=y.angle(this.points[0],this.points[3],this.points[2]);if(t>0&&e<0||t<0&&e>0)return!1}const t=this.normal(0),e=this.normal(1);let i=t.x*e.x+t.y*e.y;return this._3d&&(i+=t.z*e.z),m(w(i))<z/3}reduce(){let t,e,i=0,n=0,r=.01,o=[],s=[],a=this.extrema().values;for(-1===a.indexOf(0)&&(a=[0].concat(a)),-1===a.indexOf(1)&&a.push(1),i=a[0],t=1;t<a.length;t++)n=a[t],e=this.split(i,n),e._t1=i,e._t2=n,o.push(e),i=n;return o.forEach((function(t){for(i=0,n=0;n<=1;)for(n=i+r;n<=1.01;n+=r)if(e=t.split(i,n),!e.simple()){if(n-=r,m(i-n)<r)return[];e=t.split(i,n),e._t1=y.map(i,0,1,t._t1,t._t2),e._t2=y.map(n,0,1,t._t1,t._t2),s.push(e),i=n;break}i<1&&(e=t.split(i,1),e._t1=y.map(i,0,1,t._t1,t._t2),e._t2=t._t2,s.push(e))})),s}translate(t,e,i){i=\"number\"==typeof i?i:e;const n=this.order;let r=this.points.map(((t,r)=>(1-r/n)*e+r/n*i));return new T(this.points.map(((e,i)=>({x:e.x+t.x*r[i],y:e.y+t.y*r[i]}))))}scale(t){const e=this.order;let i=!1;if(\"function\"==typeof t&&(i=t),i&&2===e)return this.raise().scale(i);const n=this.clockwise,r=this.points;if(this._linear)return this.translate(this.normal(0),i?i(0):t,i?i(1):t);const o=i?i(0):t,s=i?i(1):t,a=[this.offset(0,10),this.offset(1,10)],h=[],c=y.lli4(a[0],a[0].c,a[1],a[1].c);if(!c)throw new Error(\"cannot scale this curve. Try reducing it first.\");return[0,1].forEach((function(t){const i=h[t*e]=y.copy(r[t*e]);i.x+=(t?s:o)*a[t].n.x,i.y+=(t?s:o)*a[t].n.y})),i?([0,1].forEach((function(o){if(2!==e||!o){var s=r[o+1],a={x:s.x-c.x,y:s.y-c.y},l=i?i((o+1)/e):t;i&&!n&&(l=-l);var u=C(a.x*a.x+a.y*a.y);a.x/=u,a.y/=u,h[o+1]={x:s.x+l*a.x,y:s.y+l*a.y}}})),new T(h)):([0,1].forEach((t=>{if(2===e&&t)return;const i=h[t*e],n=this.derivative(t),o={x:i.x+n.x,y:i.y+n.y};h[t+1]=y.lli4(i,o,c,r[t+1])})),new T(h))}outline(t,e,i,n){if(e=void 0===e?t:e,this._linear){const r=this.normal(0),o=this.points[0],s=this.points[this.points.length-1];let a,h,c;void 0===i&&(i=t,n=e),a={x:o.x+r.x*t,y:o.y+r.y*t},c={x:s.x+r.x*i,y:s.y+r.y*i},h={x:(a.x+c.x)/2,y:(a.y+c.y)/2};const l=[a,h,c];a={x:o.x-r.x*e,y:o.y-r.y*e},c={x:s.x-r.x*n,y:s.y-r.y*n},h={x:(a.x+c.x)/2,y:(a.y+c.y)/2};const u=[c,h,a],p=y.makeline(u[2],l[0]),g=y.makeline(l[2],u[0]),x=[p,new T(l),g,new T(u)];return new d(x)}const r=this.reduce(),o=r.length,s=[];let a,h=[],c=0,l=this.length();const u=void 0!==i&&void 0!==n;function p(t,e,i,n,r){return function(o){const s=n/i,a=(n+r)/i,h=e-t;return y.map(o,0,1,t+s*h,t+a*h)}}r.forEach((function(r){const o=r.length();u?(s.push(r.scale(p(t,i,l,c,o))),h.push(r.scale(p(-e,-n,l,c,o)))):(s.push(r.scale(t)),h.push(r.scale(-e))),c+=o})),h=h.map((function(t){return a=t.points,a[3]?t.points=[a[3],a[2],a[1],a[0]]:t.points=[a[2],a[1],a[0]],t})).reverse();const g=s[0].points[0],x=s[o-1].points[s[o-1].points.length-1],f=h[o-1].points[h[o-1].points.length-1],m=h[0].points[0],v=y.makeline(f,g),_=y.makeline(x,m),b=[v].concat(s).concat([_]).concat(h);return new d(b)}outlineshapes(t,e,i){e=e||t;const n=this.outline(t,e).curves,r=[];for(let t=1,e=n.length;t<e/2;t++){const o=y.makeshape(n[t],n[e-t],i);o.startcap.virtual=t>1,o.endcap.virtual=t<e/2-1,r.push(o)}return r}intersects(t,e){return t?t.p1&&t.p2?this.lineIntersects(t):(t instanceof T&&(t=t.reduce()),this.curveintersects(this.reduce(),t,e)):this.selfintersects(e)}lineIntersects(t){const e=v(t.p1.x,t.p2.x),i=v(t.p1.y,t.p2.y),n=_(t.p1.x,t.p2.x),r=_(t.p1.y,t.p2.y);return y.roots(this.points,t).filter((t=>{var o=this.get(t);return y.between(o.x,e,n)&&y.between(o.y,i,r)}))}selfintersects(t){const e=this.reduce(),i=e.length-2,n=[];for(let r,o,s,a=0;a<i;a++)o=e.slice(a,a+1),s=e.slice(a+2),r=this.curveintersects(o,s,t),n.push(...r);return n}curveintersects(t,e,i){const n=[];t.forEach((function(t){e.forEach((function(e){t.overlaps(e)&&n.push({left:t,right:e})}))}));let r=[];return n.forEach((function(t){const e=y.pairiteration(t.left,t.right,i);e.length>0&&(r=r.concat(e))})),r}arcs(t){return t=t||.5,this._iterate(t,[])}_error(t,e,i,n){const r=(n-i)/4,o=this.get(i+r),s=this.get(n-r),a=y.dist(t,e),h=y.dist(t,o),c=y.dist(t,s);return m(h-a)+m(c-a)}_iterate(t,e){let i,n=0,r=1;do{i=0,r=1;let o,s,a,h,c,l=this.get(n),u=!1,p=!1,g=r,x=1;do{if(p=u,h=a,g=(n+r)/2,o=this.get(g),s=this.get(r),a=y.getccenter(l,o,s),a.interval={start:n,end:r},u=this._error(a,l,n,r)<=t,c=p&&!u,c||(x=r),u){if(r>=1){if(a.interval.end=x=1,h=a,r>1){let t={x:a.x+a.r*b(a.e),y:a.y+a.r*E(a.e)};a.e+=y.angle({x:a.x,y:a.y},t,this.get(1))}break}r+=(r-n)/2}else r=g}while(!c&&i++<100);if(i>=100)break;h=h||a,e.push(h),n=x}while(r<1);return e}}const R=(t,e,i)=>{if(t.x===e.x)return{x:t.x,y:i.y};if(t.y===e.y)return{x:i.x,y:t.y};const n=(e.y-t.y)/(e.x-t.x),r=-1/n,o=(-n*t.x+t.y+r*i.x-i.y)/(r-n);return{x:o,y:n*(o-t.x)+t.y}},S=(t,e)=>Math.sqrt(Math.pow(e.x-t.x,2)+Math.pow(e.y-t.y,2)),P=(t,e,i)=>{const n=Math.min(t.x,e.x,i.x),r=Math.max(t.x,e.x,i.x),o=Math.min(t.y,e.y,i.y);return{width:r-n,height:Math.max(t.y,e.y,i.y)-o}},M=(t,e,i)=>{const n=Object.assign({},t),r={x:e.x-t.x,y:e.y-t.y};if(0===r.x&&0===r.y)return n;if(0===r.x)n.y+=i*Math.sign(r.y);else if(0===r.y)n.x+=i*Math.sign(r.x);else{const t=Math.sqrt(Math.pow(r.x,2)+Math.pow(r.y,2));n.x+=r.x*(i/t),n.y+=r.y*(i/t)}return n},O=(t,e)=>{const[i,n,r]=t,[o,s,a]=e,h=.1/Math.abs([...t,...e].reduce(((t,e)=>Math.min(t,e.x,e.y)),-1)),c=(t,e,i)=>{const[n,r,o,s]=t.map(Number),[a,h,c,l]=e.map(Number),[u,p,g,x]=i.map(Number),f=o-r*c/h,y=c-h*g/p,d=l-h*x/p,m=a-h*u/p,v=(f/y*d-(s-r*l/h))/(f/y*m-(n-r*a/h)),_=(d-m*v)/y;return{x:v,y:(s-n*v-o*_)/r,z:_}},l=[o.x+h,o.y+h,1,i.x+h],u=[s.x+h,s.y+h,1,n.x+h],p=[a.x+h,a.y+h,1,r.x+h],g=c(l,u,p);l[3]=i.y+h,u[3]=n.y+h,p[3]=r.y+h;const x=c(l,u,p),f=g.x,y=g.y,d=g.z;return[f,x.x,y,x.y,d,x.z]},B=(t,e,i,n,r=.1)=>{const o=(t,e,i)=>Math.abs(t.x*(e.y-i.y)+e.x*(i.y-t.y)+i.x*(t.y-e.y))/2,s=o(e,i,n);return o(e,i,t)+o(i,n,t)+o(n,e,t)<=s+r};var I=Object.freeze({__proto__:null,calcBoundingBox:P,calcCoordDistance:S,calcExpandCoord:(t,e,i,n=1)=>{const r=R(e,i,t),o=S(t,r),s=M(t,r,o+n);return{x:s.x-r.x+e.x,y:s.y-r.y+e.y}},calcIntersection:(t,e,i,n)=>{const r=(t,e)=>Math.abs(t-e)<Math.pow(.1,12);if(r(t.x,e.x)&&r(i.x,n.x))return null;if(r(t.y,e.y)&&r(i.y,n.y))return null;const o=1e4*(e.y-t.y)/Math.round(1e4*(e.x-t.x)),s=1e4*(n.y-i.y)/Math.round(1e4*(n.x-i.x)),a=t.y-o*t.x,h=i.y-s*i.x;if(Math.abs(o)===1/0)return{x:t.x,y:s*t.x+h};if(Math.abs(s)===1/0)return{x:i.x,y:o*i.x+a};const c=(h-a)/(o-s);return{x:c,y:o*c+a}},calcMatrix:O,calcPerpendicularIntersection:R,calcRelativeCoord:M,isTriangleContainsPoint:B});const A=(t,e,i,n,r)=>{var o;const{x:s,y:a,sourceScale:h=1,destinationScale:c=1}=n,{gridColor:l={r:255,g:0,b:0,a:1},enableContentDisplay:u=!0,enableGridDisplay:p=!1,enableGridVertexDisplay:g=!1}=null!==(o=t.renderingConfig)&&void 0!==o?o:{},{calcBoundingBox:x,calcPerpendicularIntersection:f,calcCoordDistance:y,calcRelativeCoord:d,calcMatrix:m}=r,v=(t,e,i,n=1)=>{const r=f(e,i,t),o=y(t,r),s=d(t,r,o+n);return{x:s.x-r.x+e.x,y:s.y-r.y+e.y}},_=i.getContext(\"2d\");_.clearRect(0,0,i.width,i.height);const b=Math.ceil(1/(h*c));_.save(),_.transform(h*c,0,0,h*c,s*h*c,a*h*c);const E=(t,i,n,r,o,s,a)=>{const c=[t,n,o],f=new Path2D;for(let t=0;t<3;t++){const e=c[t],i=c[(t+1)%3],n=c[(t+2)%3],r=v(e,i,n,b),o=v(e,n,i,b);f.lineTo(r.x,r.y),f.lineTo(o.x,o.y)}if(u){_.save(),_.clip(f);const c=m([t,n,o],[i,r,s]);_.transform(...c);const l=x(i,r,s),u=(a.x-1)*h,p=(a.y-1)*h,g=(l.width+2)*h,y=(l.height+2)*h,d=a.x-1/h,v=a.y-1/h,b=l.width+2/h,E=l.height+2/h;_.drawImage(e,u,p,g,y,d,v,b,E),_.restore()}if(g){const e=Math.floor(2/h);_.fillStyle=`rgba(${l.r}, ${l.g}, ${l.b}, ${l.a})`,_.fillRect(t.x-e/2,t.y-e/2,e,e)}if(p){const t=Math.floor(1/h);_.lineWidth=t,_.strokeStyle=\"rgba(255, 0, 0, 0.5)\",_.stroke(f)}};return t.regionPoints.forEach(((e,i)=>{e.forEach(((e,n)=>{const r=e,o=t.regionCurves[i][n].vertical.length-1;r.forEach(((e,s)=>{const a=r[s],h=r[s+1],c=r[s+o+2],l=r[s+o+1],u=t.originalRegionPoints[i][n][s],p=t.originalRegionPoints[i][n][s+1],g=t.originalRegionPoints[i][n][s+o+2],x=t.originalRegionPoints[i][n][s+o+1];h&&c&&s%(o+1)<o&&(E(a,u,h,p,l,x,u),E(c,g,h,p,l,x,u))}))}))})),_.restore(),i},L=(t,e,i,n)=>{const{width:r,height:o,sourceScale:s=1,destinationScale:a=1}=n;(i=null!=i?i:document.createElement(\"canvas\")).width=r*a*s,i.height=o*a*s;return A(t,e,i,n,{calcBoundingBox:P,calcPerpendicularIntersection:R,calcCoordDistance:S,calcRelativeCoord:M,calcMatrix:O})},F=(t,e,i,n)=>{var r;const{x:o,y:s,width:a,height:h,sourceScale:c=1}=n,{enableAntialias:l=!0,gridColor:u={r:255,g:0,b:0,a:1},enableContentDisplay:p=!0,enableGridDisplay:g=!1,enableGridVertexDisplay:x=!1}=null!==(r=t.renderingConfig)&&void 0!==r?r:{},{width:f,height:y}=e,d=i.getContext(\"webgl\",{antialias:l});if(!d)throw Error(\"[Warpvas] Failed to initialize WebGL. Your browser or device may not support it.\");const m={before:[],after:[]};t.regionPoints.forEach(((e,i)=>{e.forEach(((e,n)=>{const r=e,o=t.regionCurves[i][n].vertical.length-1;r.forEach(((e,s)=>{const a=r[s],h=r[s+1],c=r[s+o+2],l=r[s+o+1],u=t.originalRegionPoints[i][n][s],p=t.originalRegionPoints[i][n][s+1],g=t.originalRegionPoints[i][n][s+o+2],x=t.originalRegionPoints[i][n][s+o+1];h&&c&&s%(o+1)<o&&(m.before.push(u,p,x,g,p,x),m.after.push(a,h,l,c,h,l))}))}))}));const v=\"\\n      attribute vec4 aVertexPosition;\\n      attribute vec2 aTextureCoord;\\n      varying highp vec2 vTextureCoord;\\n      void main(void) {\\n          gl_Position = aVertexPosition;\\n          gl_PointSize = 2.0;\\n          vTextureCoord = aTextureCoord;\\n      }\\n  \",_=(t,e)=>{const i=d.createShader(t);return i?(d.shaderSource(i,e),d.compileShader(i),d.getShaderParameter(i,d.COMPILE_STATUS)?i:(console.error(\"[Warpvas] Shader compilation error:\",d.getShaderInfoLog(i)),d.deleteShader(i),null)):(console.error(\"[Warpvas] Failed to create shader.\"),null)},b=(t,e)=>{const i=_(d.VERTEX_SHADER,t);if(!i)return console.error(\"[Warpvas] Failed to initialize vertex shader.\"),null;const n=_(d.FRAGMENT_SHADER,e);if(!n)return console.error(\"[Warpvas] Failed to initialize fragment shader.\"),null;const r=d.createProgram();return r?(d.attachShader(r,i),d.attachShader(r,n),d.linkProgram(r),d.getProgramParameter(r,d.LINK_STATUS)?r:(console.error(\"[Warpvas] Shader program linking error:\",d.getProgramInfoLog(r)),null)):(console.error(\"[Warpvas] Failed to create shader program.\"),null)},E=t=>!(t&t-1),w=b(v,\"\\n      varying highp vec2 vTextureCoord;\\n      uniform sampler2D uSampler;\\n      void main(void) {\\n          gl_FragColor = texture2D(uSampler, vTextureCoord);\\n      }\\n  \");if(!w)throw Error(\"[Warpvas] Failed to initialize shader program.\");const C={program:w,attribLocations:{vertexPosition:d.getAttribLocation(w,\"aVertexPosition\"),textureCoord:d.getAttribLocation(w,\"aTextureCoord\")},uniformLocations:{uSampler:d.getUniformLocation(w,\"uSampler\")}},z=d.createTexture();if(!z)throw Error(\"[Warpvas] Failed to create WebGL texture object.\");d.bindTexture(d.TEXTURE_2D,z),d.texImage2D(d.TEXTURE_2D,0,d.RGBA,d.RGBA,d.UNSIGNED_BYTE,e),E(e.width)&&E(e.height)&&d.generateMipmap(d.TEXTURE_2D),d.enable(d.BLEND),d.blendFunc(d.SRC_ALPHA,d.ONE_MINUS_SRC_ALPHA),d.texParameteri(d.TEXTURE_2D,d.TEXTURE_WRAP_S,d.CLAMP_TO_EDGE),d.texParameteri(d.TEXTURE_2D,d.TEXTURE_WRAP_T,d.CLAMP_TO_EDGE),d.texParameteri(d.TEXTURE_2D,d.TEXTURE_MIN_FILTER,d.LINEAR),d.viewport(0,0,i.width,i.height);return((t,e,i)=>{d.clearColor(0,0,0,0),d.clear(d.COLOR_BUFFER_BIT);const n=d.FLOAT,r=!1,o=4*Float32Array.BYTES_PER_ELEMENT;d.bindBuffer(d.ARRAY_BUFFER,e.position),d.vertexAttribPointer(t.attribLocations.vertexPosition,2,n,r,o,0),d.enableVertexAttribArray(t.attribLocations.vertexPosition),d.bindBuffer(d.ARRAY_BUFFER,e.textureCoord),d.vertexAttribPointer(t.attribLocations.textureCoord,2,n,r,o,0),d.enableVertexAttribArray(t.attribLocations.textureCoord),d.useProgram(t.program),d.activeTexture(d.TEXTURE0),d.bindTexture(d.TEXTURE_2D,i),d.uniform1i(t.uniformLocations.uSampler,0),p&&d.drawArrays(d.TRIANGLES,0,m.before.length);const{r:s,g:a,b:h,a:c}=u,l=`${(s/255).toFixed(1)}, ${(a/255).toFixed(1)}, ${(h/255).toFixed(1)}, ${c.toFixed(1)}`,f=b(v,`\\n      void main(void) {\\n        gl_FragColor = vec4(${l});\\n      }\\n    `);if(!f)throw Error(\"[Warpvas] Failed to initialize outline shader program.\");d.bindBuffer(d.ARRAY_BUFFER,e.position),d.vertexAttribPointer(d.getAttribLocation(f,\"aVertexPosition\"),2,n,r,0,0),d.enableVertexAttribArray(d.getAttribLocation(f,\"aVertexPosition\")),d.bindBuffer(d.ARRAY_BUFFER,e.textureCoord),d.vertexAttribPointer(d.getAttribLocation(f,\"aTextureCoord\"),2,n,r,0,0),d.enableVertexAttribArray(d.getAttribLocation(f,\"aTextureCoord\")),d.useProgram(f),g&&d.drawArrays(d.LINES,0,2*m.before.length),x&&d.drawArrays(d.POINTS,0,2*m.before.length)})(C,(()=>{const t=d.createBuffer();d.bindBuffer(d.ARRAY_BUFFER,t);const e=m.before.map(((t,e)=>{const i=[t.x/(f/c),t.y/(y/c)];return(e+1)%3==0?i.push(m.before[e-2].x/(f/c),m.before[e-2].y/(y/c)):i.push(m.before[e+1].x/(f/c),m.before[e+1].y/(y/c)),i})).flat(1);d.bufferData(d.ARRAY_BUFFER,new Float32Array(e),d.STATIC_DRAW);const i=d.createBuffer();d.bindBuffer(d.ARRAY_BUFFER,i);const n=m.after.map(((t,e)=>{const i=[(t.x+o)/(a/2)-1,-((t.y+s)/(h/2)-1)];return(e+1)%3==0?i.push((m.after[e-2].x+o)/(a/2)-1,-((m.after[e-2].y+s)/(h/2)-1)):i.push((m.after[e+1].x+o)/(a/2)-1,-((m.after[e+1].y+s)/(h/2)-1)),i})).flat(1);return d.bufferData(d.ARRAY_BUFFER,new Float32Array(n),d.STATIC_DRAW),{position:i,textureCoord:t}})(),z),i},D=(t,e,i,n)=>{const{width:r,height:o,sourceScale:s=1,destinationScale:a=1}=n;(i=null!=i?i:document.createElement(\"canvas\")).width=r*a*s,i.height=o*a*s;return F(t,e,i,n)},U=\"WORKER_MESSAGE\",W=\"JOB_RESULT\",G=t=>t instanceof ArrayBuffer||t instanceof MessagePort||self.ImageBitmap&&t instanceof ImageBitmap,k=()=>{const t=[];let e,i=new Map;const n={collect:t=>{for(let e in t)i.set(e,t[e]);return n},onMessage:t=>(e=t,n),create:n=>{const r=n.toString(),o=`\\n        // 将收集到的变量声明和定义加入脚本字符串，后面函数执行的时候便不会出现not defined的错误了\\n        $collections = {};\\n        ${Object.entries(Object.fromEntries(i)).reduce(((t,[e,i])=>t+`$collections['${e}']=`+(\"function\"==typeof i?`${i};`:`JSON.parse(\\`${JSON.stringify(i)}\\`);`)),\"\")}\\n  \\n        // 声明定义用于判断是否是可转移对象的函数\\n        $isTransferables = ${G}\\n  \\n        // 在脚本中声明并定义一个包含工作流程的函数体\\n        $job=${r};\\n  \\n        // 给worker线程添加消息监听，等待主线程的发号施令\\n        onmessage=e=>{\\n          const { index, args } = e.data;\\n  \\n          Promise.resolve(\\n            $job.apply($job, args.concat([{\\n              collections: $collections,\\n              postMessage: (message) => postMessage({ type: '${U}', message }),\\n              close: self.close,\\n            }]))\\n          ).then(result => {\\n            postMessage({ type: '${W}', message: { index, result } }, [result].filter($isTransferables))\\n          }).catch(error => {\\n            postMessage({ type: '${W}', message: { index, error } })\\n          })\\n        }\\n      `,s=URL.createObjectURL(new Blob([o],{type:\"text/javascript\"})),a=new Worker(s);return a.onmessage=function(i){const n=i.data;if(n.type===U&&e&&e.call(e,n.message),n.type===W){const{index:e,result:i,error:r}=n.message,{done:o}=t[e];o(r,i)}},{run:(...e)=>new Promise(((i,n)=>{const r=t.length;t.push({done:(t,e)=>{t?n(t):i(e)}}),a.postMessage({index:r,args:e},e.filter(G))})),terminate:()=>{a.terminate(),URL.revokeObjectURL(s),t.length=0,i.clear(),e=void 0}}}};return n},N=(t,i,n,r)=>e(void 0,void 0,void 0,(function*(){const{regionPoints:e,renderingConfig:o,regionCurves:s,originalRegionPoints:a}=t,h={renderingConfig:o,regionCurves:s.map((t=>t.map((t=>({horizontal:{length:t.horizontal.length},vertical:{length:t.vertical.length}}))))),regionPoints:e,originalRegionPoints:a},c=k().collect({warpvas:h,options:r,createWarpedCanvas:A,calcBoundingBox:P,calcPerpendicularIntersection:R,calcCoordDistance:S,calcRelativeCoord:M,calcMatrix:O}).create(((t,{collections:e})=>{const{options:i,warpvas:n,createWarpedCanvas:r,calcBoundingBox:o,calcPerpendicularIntersection:s,calcCoordDistance:a,calcRelativeCoord:h,calcMatrix:c}=e,{width:l,height:u,sourceScale:p=1,destinationScale:g=1}=i,x=new OffscreenCanvas(l*g*p,u*g*p),f=new OffscreenCanvas(t.width,t.height),y=f.getContext(\"2d\");null==y||y.putImageData(t,0,0);return r(n,f,x,i,{calcBoundingBox:o,calcPerpendicularIntersection:s,calcCoordDistance:a,calcRelativeCoord:h,calcMatrix:c}).transferToImageBitmap()})),l=yield c.run(i);return c.terminate(),(n=null!=n?n:document.createElement(\"canvas\")).width=l.width,n.height=l.height,n.getContext(\"2d\").drawImage(l,0,0),n})),H=(t,i,n,r)=>e(void 0,void 0,void 0,(function*(){const{regionPoints:e,renderingConfig:o,regionCurves:s,originalRegionPoints:a}=t,h={renderingConfig:o,regionCurves:s.map((t=>t.map((t=>({horizontal:{length:t.horizontal.length},vertical:{length:t.vertical.length}}))))),regionPoints:e,originalRegionPoints:a},c=k().collect({warpvas:h,options:r,createWarpedCanvas:F}).create(((t,{collections:e})=>{const{options:i,warpvas:n,createWarpedCanvas:r}=e,{width:o,height:s,sourceScale:a=1,destinationScale:h=1}=i;return r(n,t,new OffscreenCanvas(o*h*a,s*h*a),i).transferToImageBitmap()})),l=yield c.run(i);return c.terminate(),(n=null!=n?n:document.createElement(\"canvas\")).width=l.width,n.height=l.height,n.getContext(\"2d\").drawImage(l,0,0),n}));var $,j;!function(t){t.TOP_LEFT=\"tl\",t.TOP_RIGHT=\"tr\",t.BOTTOM_LEFT=\"bl\",t.BOTTOM_RIGHT=\"br\"}($||($={})),function(t){t.TOP=\"top\",t.BOTTOM=\"bottom\",t.LEFT=\"left\",t.RIGHT=\"right\"}(j||(j={}));class V{constructor(t,e=1,i=1){if(this.splitPoints=[],this.originalRegions=[],this.originalRegionPoints=[],this.regionBoundaryCurves=[],this.regionCurves=[],this.regionPoints=[],this.splitUnit=.05,this.splitStrategy={name:\"default\",execute:V.strategy},this.renderingContext=\"webgl\",this.renderingConfig={padding:0,enableAntialias:!0,enableSafeRendering:!0,enableContentDisplay:!0,enableGridDisplay:!1,enableGridVertexDisplay:!1,gridColor:{r:255,g:0,b:0,a:1}},this._safeModeEnabled=!1,this._cacheSourceSize=null,this._cacheSourceImageData=null,this._cacheInputCanvas=null,this._cacheOutputCanvas=null,this._inputLimitScale=1,this._outputLimitScale=1,!(t instanceof HTMLCanvasElement||t instanceof HTMLImageElement))throw new TypeError(\"[Warpvas] source must be either HTMLCanvasElement or HTMLImageElement!\");if(t instanceof HTMLImageElement){const e=document.createElement(\"canvas\"),i=e.getContext(\"2d\");if(!i)throw new Error(\"Failed to get 2D rendering context for canvas\");e.width=t.naturalWidth,e.height=t.naturalHeight,i.drawImage(t,0,0),this.source=e}else this.source=t;this.splitPoints=this._initializeSplitPoints(e,i),this.setWarpState(this.splitPoints)}get maxSplitUnitPixel(){return this.splitUnit*this.source.width}get scale(){return{x:this._inputLimitScale*this._outputLimitScale,y:this._inputLimitScale*this._outputLimitScale}}static strategy(t){if(!t.regionCurves)return[];const e=[];return t.regionBoundaryCurves.forEach(((i,n)=>{const r=[];i.forEach(((e,i)=>{const o=[],{vertical:s,horizontal:a}=t.regionCurves[n][i];for(let t=0;t<a.length;t++)for(let e=0;e<s.length;e++){const i=s[e].get(t/(a.length-1)),n=a[t].get(e/(s.length-1));o.push({x:(i.x+n.x)/2,y:(i.y+n.y)/2})}r.push(o)})),e.push(r)})),e}static serializeWarpState(t){const{splitPoints:e,regionBounds:i}=t,n=[e.length,i.length,i[0].length];e.forEach((t=>{n.push(t.x,t.y)}));const r=[\"top\",\"right\",\"bottom\",\"left\"];i.forEach((t=>t.forEach((t=>[r.forEach((e=>t[e].forEach((t=>{n.push(t.x,t.y)}))))]))));const o=new Float32Array(n),s=new Uint8Array(o.buffer);return btoa(String.fromCharCode.apply(null,s))}static deserializeWarpState(t){const e=atob(t),i=new Uint8Array(e.length);for(let t=0;t<e.length;t++)i[t]=e.charCodeAt(t);const n=new Float32Array(i.buffer),r=Array.from(n),o=[\"top\",\"right\",\"bottom\",\"left\"],s=r[0],a=r[1],h=r[2];let c=3;const l=[];for(let t=0;t<s;t++)l.push({x:r[c],y:r[c+1]}),c+=2;const u=[];for(let t=0;t<a;t++){const t=[];for(let e=0;e<h;e++){const e={};for(const t of o){e[t]=[];for(let i=0;i<4;i++)e[t].push({x:r[c],y:r[c+1]}),c+=2}t.push(e)}u.push(t)}return{splitPoints:l,regionBounds:u}}_initializeSplitPoints(t=1,e=1){const i=Math.max(Math.floor(t),1),n=Math.max(Math.floor(e),1),r=[];for(let o=1;o<i;o++)for(let i=1;i<n;i++)o===i&&r.push({x:i/e,y:o/t});return r}_initializeOriginalRegions(){const{width:t,height:e}=this.source;let i=[],n=[];this.splitPoints.forEach((t=>{t.x<0||t.x>1||t.y<0||t.y>1||(i.push(t.x),n.push(t.y))})),i=[...new Set([0,...i,1])],n=[...new Set([0,...n,1])],i.sort(((t,e)=>t-e)),n.sort(((t,e)=>t-e));const r=[];for(let o=0;o<n.length-1;o++){r.push([]);for(let s=0;s<i.length-1;s++)r[r.length-1].push({tl:{x:i[s]*t,y:n[o]*e},tr:{x:i[s+1]*t,y:n[o]*e},bl:{x:i[s]*t,y:n[o+1]*e},br:{x:i[s+1]*t,y:n[o+1]*e}})}return r}_calculateSamplingPoints(t){const e=t.tr.x-t.tl.x,i=t.bl.y-t.tl.y,n=Math.max(Math.ceil(e/this.maxSplitUnitPixel),1)+1,r=Math.max(Math.ceil(i/this.maxSplitUnitPixel),1)+1;return{hts:Array.from({length:n}).map(((t,e)=>e/(n-1))),vts:Array.from({length:r}).map(((t,e)=>e/(r-1)))}}_initializeOriginalRegionPoints(){return this.originalRegions.map((t=>t.map((t=>{const{hts:e,vts:i}=this._calculateSamplingPoints(t),n=[],{tl:r,tr:o,bl:s}=t,a=o.x-r.x,h=s.y-r.y;for(let t=0;t<i.length;t++)for(let o=0;o<e.length;o++)n.push({x:r.x+a*e[o],y:r.y+h*i[t]});return n}))))}_initializeBoundaryControlPoints(t){const e=[];return t.forEach((t=>{e.push([]),t.forEach((t=>{const{tl:i,tr:n,br:r,bl:o}=t,s={top:[i,n],bottom:[o,r],left:[i,o],right:[n,r]},a={};for(const t in s){const[e,i]=s[t];a[t]=[e,{x:e.x+1*(i.x-e.x)/3,y:e.y+1*(i.y-e.y)/3},{x:i.x-1*(i.x-e.x)/3,y:i.y-1*(i.y-e.y)/3},i]}e[e.length-1].push(a)}))})),e}_generateRegionCurves(t,e,i){const n={horizontal:[],vertical:[]};return e.forEach((e=>{if(0===e)return void n.vertical.push(t.left);if(1===e)return void n.vertical.push(t.right);const i=t.top.get(e),r=t.bottom.get(e),o=new T([i,{x:i.x+((t.left.points[1].x-t.left.points[0].x)*(1-e)+(t.right.points[1].x-t.right.points[0].x)*e),y:i.y+((t.left.points[1].y-t.left.points[0].y)*(1-e)+(t.right.points[1].y-t.right.points[0].y)*e)},{x:r.x+((t.left.points[2].x-t.left.points[3].x)*(1-e)+(t.right.points[2].x-t.right.points[3].x)*e),y:r.y+((t.left.points[2].y-t.left.points[3].y)*(1-e)+(t.right.points[2].y-t.right.points[3].y)*e)},r]);n.vertical.push(o)})),i.forEach((e=>{if(0===e)return void n.horizontal.push(t.top);if(1===e)return void n.horizontal.push(t.bottom);const i=t.left.get(e),r=t.right.get(e),o=new T([i,{x:i.x+((t.top.points[1].x-t.top.points[0].x)*(1-e)+(t.bottom.points[1].x-t.bottom.points[0].x)*e),y:i.y+((t.top.points[1].y-t.top.points[0].y)*(1-e)+(t.bottom.points[1].y-t.bottom.points[0].y)*e)},{x:r.x+((t.top.points[2].x-t.top.points[3].x)*(1-e)+(t.bottom.points[2].x-t.bottom.points[3].x)*e),y:r.y+((t.top.points[2].y-t.top.points[3].y)*(1-e)+(t.bottom.points[2].y-t.bottom.points[3].y)*e)},r]);n.horizontal.push(o)})),n}_generateAllRegionCurves(t){const e=[];return t.forEach(((t,i)=>{const n=[];e.push(n),t.forEach(((t,e)=>{const r=t,o=this.originalRegions[i][e],{hts:s,vts:a}=this._calculateSamplingPoints(o);n.push(this._generateRegionCurves(r,s,a))}))})),e}setSplitUnit(t){return this.splitUnit=t<=0?1:Math.min(1,t),this.originalRegionPoints=this._initializeOriginalRegionPoints(),this}setSplitStrategy(t){return this.splitStrategy=t,this}setInputLimitSize(t){return this._inputLimitSize=t,t||(this._inputLimitScale=1,this._cacheInputCanvas=null),this._cacheSourceImageData=null,this}setOutputLimitSize(t){return this._outputLimitSize=t,t||(this._outputLimitScale=1),this}setRenderingContext(t){return this.renderingContext=t,this}setRenderingCanvas(t){return this._cacheOutputCanvas=t,this}setRenderingConfig(t){return this.renderingConfig=Object.assign(Object.assign({},this.renderingConfig),t),this}getBoundingBoxInfo(){const{padding:t}=this.renderingConfig,e=this.regionCurves.length,i=this.regionCurves[0].length,n={left:1/0,right:-1/0,top:1/0,bottom:-1/0};for(let t=0;t<e;t++)for(let e=0;e<i;e++){const i=this.regionCurves[t][e];Object.values(i).forEach((t=>{const e=t.length;for(let i=0;i<e;i++){const e=t[i].bbox();n.left=Math.min(n.left,e.x.min),n.right=Math.max(n.right,e.x.max),n.top=Math.min(n.top,e.y.min),n.bottom=Math.max(n.bottom,e.y.max)}}))}return{offsetX:-n.left+t,offsetY:-n.top+t,width:n.right-n.left+2*t,height:n.bottom-n.top+2*t}}_cloneCanvas(t,e=t.width,i=t.height){const n=document.createElement(\"canvas\");n.width=e,n.height=i;const r=n.getContext(\"2d\");return null==r||r.drawImage(t,0,0,e,i),n}_createLinearBezier(t,e){return[t,{x:t.x+1*(e.x-t.x)/3,y:t.y+1*(e.y-t.y)/3},{x:e.x-1*(e.x-t.x)/3,y:e.y-1*(e.y-t.y)/3},e]}_mergeBezierCurves(t,e){const i=(t,e,i)=>{const{x:n,y:r}=e,{x:o,y:s}=i,a=Math.atan2(r,n),h=Math.atan2(s,o)-a,c=Math.sqrt(Math.pow(o,2)+Math.pow(s,2))*Math.cos(h),l=c*Math.cos(a),u=c*Math.sin(a);return{x:t.x+l,y:t.y+u}},n=i(t[1],{x:t[1].x-t[0].x,y:t[1].y-t[0].y},{x:e[1].x-e[0].x,y:e[1].y-e[0].y}),r=i(e[2],{x:e[2].x-e[3].x,y:e[2].y-e[3].y},{x:t[2].x-t[3].x,y:t[2].y-t[3].y});return[t[0],n,r,e[3]]}_findConnectedVertex(t,e){const i={top:[[\"left\",0],[\"right\",0]],bottom:[[\"left\",3],[\"right\",3]],left:[[\"top\",0],[\"bottom\",0]],right:[[\"top\",3],[\"bottom\",3]]}[t];if(!i||![\"first\",\"last\"].includes(e))throw TypeError(`[Warpvas] Invalid vertex connection parameters: direction=\"${t}\", position=\"${e}\"\\nExpected values:\\n- direction: \"top\" | \"bottom\" | \"left\" | \"right\"\\n- position: \"first\" | \"last\"`);const n=i[{first:0,last:1}[e]];return{direction:n[0],position:{0:\"first\",3:\"last\"}[n[1]]}}_setSingleRegionVertexCoord(t,e,i,n,r=!0){const o=(i,n,o)=>{var s,a;const h=null===(a=null===(s=this.regionBoundaryCurves[t])||void 0===s?void 0:s[e])||void 0===a?void 0:a[i];if(!h)return;const c=\"first\"===n?o:h.points[0],l=\"last\"===n?o:h.points[3];h.points.forEach(((t,e)=>{if(!r&&[1,2].includes(e))return;const i=this._createLinearBezier(c,l)[e];t.x=i.x,t.y=i.y}))},[s,a]={[$.TOP_LEFT]:[\"top\",\"first\"],[$.TOP_RIGHT]:[\"top\",\"last\"],[$.BOTTOM_LEFT]:[\"bottom\",\"first\"],[$.BOTTOM_RIGHT]:[\"bottom\",\"last\"]}[i];o(s,a,n);const h=this._findConnectedVertex(s,a);o(h.direction,h.position,n)}updateVertexCoord(t,e,i,n,r=!0){this._setSingleRegionVertexCoord(t,e,i,n,r);return{[$.TOP_LEFT]:[{row:t-1,col:e-1,type:$.BOTTOM_RIGHT},{row:t-1,col:e,type:$.BOTTOM_LEFT},{row:t,col:e-1,type:$.TOP_RIGHT}],[$.TOP_RIGHT]:[{row:t-1,col:e+1,type:$.BOTTOM_LEFT},{row:t,col:e+1,type:$.TOP_LEFT},{row:t-1,col:e,type:$.BOTTOM_RIGHT}],[$.BOTTOM_LEFT]:[{row:t,col:e-1,type:$.BOTTOM_RIGHT},{row:t+1,col:e,type:$.TOP_LEFT},{row:t+1,col:e-1,type:$.TOP_RIGHT}],[$.BOTTOM_RIGHT]:[{row:t,col:e+1,type:$.BOTTOM_LEFT},{row:t+1,col:e,type:$.TOP_RIGHT},{row:t+1,col:e+1,type:$.TOP_LEFT}]}[i].forEach((({row:t,col:e,type:i})=>{this._setSingleRegionVertexCoord(t,e,i,n,r)})),this}updateRegionBoundCoords(t,e,i,n){return this.regionBoundaryCurves=this._initializeRegionBoundaryCurves(this.forEachRegionBoundCoords(((r,o,s,a)=>r===t&&o===e&&i===s?n:a.points.map((t=>({x:t.x,y:t.y})))))),this.updateVertexCoord(t,e,{top:$.TOP_LEFT,right:$.TOP_RIGHT,bottom:$.BOTTOM_LEFT,left:$.TOP_LEFT}[i],n[0],!1),this.updateVertexCoord(t,e,{top:$.TOP_RIGHT,right:$.BOTTOM_RIGHT,bottom:$.BOTTOM_RIGHT,left:$.BOTTOM_LEFT}[i],n[3],!1),this}forEachRegionBoundCoords(t=((t,e,i,n)=>n.points)){const e=[];return this.regionBoundaryCurves.forEach(((i,n)=>{e.push([]),i.forEach(((i,r)=>{e[e.length-1].push([\"top\",\"right\",\"left\",\"bottom\"].reduce(((e,o)=>(e[o]=t(n,r,o,i[o]),e)),{}))}))})),e}_initializeRegionBoundaryCurves(t){const e=[];return t.forEach(((t,i)=>{e.push([]),t.forEach(((t,n)=>{var r,o,s,a;const h={};for(const c in t){switch(c){case\"top\":{const t=null===(o=null===(r=e[i-1])||void 0===r?void 0:r[n])||void 0===o?void 0:o.bottom;t&&(h[c]=t);break}case\"left\":{const t=null===(a=null===(s=e[i])||void 0===s?void 0:s[n-1])||void 0===a?void 0:a.right;t&&(h[c]=t);break}}if(!h[c]){const e=t[c];h[c]=new T(e[0].x,e[0].y,e[1].x,e[1].y,e[2].x,e[2].y,e[3].x,e[3].y)}}e[e.length-1].push(h)}))})),e}getWarpState(){const t=this.forEachRegionBoundCoords();return{splitPoints:this.splitPoints,regionBounds:t}}setWarpState(t,e=null){this.splitPoints=t;const{width:i,height:n}=this.source;if(this._cacheSourceSize={width:i,height:n},this.originalRegions=this._initializeOriginalRegions(),this.originalRegionPoints=this._initializeOriginalRegionPoints(),e)this.regionBoundaryCurves=this._initializeRegionBoundaryCurves(e);else{const t=this._initializeBoundaryControlPoints(this.originalRegions);this.regionBoundaryCurves=this._initializeRegionBoundaryCurves(t)}return this}resetWarpState(t=1,e=1){return this.splitPoints=this._initializeSplitPoints(t,e),this.setWarpState(this.splitPoints)}isUnwarped(){const t=this.forEachRegionBoundCoords(((t,e,i,n)=>n.points.map((t=>({x:t.x/this.source.width,y:t.y/this.source.height})))));return 0===this.splitPoints.length&&Object.entries(t[0][0]).every((([t,e])=>{const i=[\"right\",\"bottom\"].includes(t)?1:0,n={top:\"y\",bottom:\"y\",left:\"x\",right:\"x\"}[t],r={top:\"x\",bottom:\"x\",left:\"y\",right:\"y\"}[t];return e.every((t=>t[n]===i))&&0===e[0][r]&&Math.abs(e[1][r]-1/3)<Number.EPSILON&&Math.abs(e[2][r]-2/3)<Number.EPSILON&&1===e[3][r]}))}getHitInfo(t){let e=null;try{this.forEachSplitRegion((([i,n,r,o],s,a,h,c,l)=>{const u=B(t,i,n,o),p=B(t,r,n,o);if(u||p)throw e={rowIndex:c,colIndex:l,row:a,col:h,after:[i,n,r,o],before:s,clickPart:u?0:1},Error()}))}catch(t){}return e}splitRegionByPoint(t,e,i,n=.05){const{tl:r,tr:o,bl:s}=this.originalRegions[t][e];let a=(i.x-r.x)/(o.x-r.x),h=(i.y-r.y)/(s.y-r.y);a<n&&(a=0),a>1-n&&(a=1),h<n&&(h=0),h>1-n&&(h=1);const c=[];this.regionBoundaryCurves.forEach(((e,i)=>{if(i!==t||0===h||1===h)return void c.push(e.map((t=>{const e={};for(const i in t)e[i]=t[i].points;return e})));const n=[],r=[];e.forEach((t=>{const{horizontal:e,vertical:i}=this._generateRegionCurves(t,[0,1],[0,h,1]),{left:o,right:s}=i[0].split(h),{left:a,right:c}=i[1].split(h);n.push({left:o.points,right:a.points,top:e[0].points,bottom:e[1].points}),r.push({left:s.points,right:c.points,top:e[1].points,bottom:e[2].points})})),c.push(n,r)})),0!==a&&1!==a&&c.forEach(((t,i)=>{const{horizontal:n,vertical:r}=this._generateRegionCurves({left:new T(t[e].left),right:new T(t[e].right),top:new T(t[e].top),bottom:new T(t[e].bottom)},[0,a,1],[0,1]),{left:o,right:s}=n[0].split(a),{left:h,right:l}=n[1].split(a);c[i].splice(e,1,{left:r[0].points,right:r[1].points,top:o.points,bottom:h.points},{left:r[1].points,right:r[2].points,top:s.points,bottom:l.points})})),this.setWarpState([...this.splitPoints,{x:(0===a?r.x:1===a?o.x:i.x)/this.source.width,y:(0===h?r.y:1===h?s.y:i.y)/this.source.height}],c)}removeRegion(...t){const e=[],{width:i,height:n}=this.source,r=(r,o,s)=>{t.some((t=>t.row===o||t.column===s))||0===o&&0===s||o===this.originalRegions.length&&0===s||0===o&&s===this.originalRegions[0].length||o===this.originalRegions.length&&s===this.originalRegions[0].length||e.some((t=>t.x===r.x||0===s||s===this.originalRegions[0].length))&&e.some((t=>t.y===r.y||0===o||o===this.originalRegions.length))||e.push({x:r.x/i,y:r.y/n})};this.originalRegions.forEach(((t,e)=>{t.forEach(((i,n)=>{const{tl:o,tr:s,bl:a,br:h}=i;r(o,e,n),n===t.length-1&&r(s,e,n+1),e===this.originalRegions.length-1&&(r(a,e+1,n),n===t.length-1&&r(h,e+1,n+1))}))}));const o=this.forEachRegionBoundCoords(),s=[...new Set(t.map((t=>t.row)))];s.sort(((t,e)=>e-t)),s.forEach((t=>{const e=o[t],i=o[t-1];e&&i&&o.splice(t-1,2,i.map(((t,i)=>({top:t.top,left:this._mergeBezierCurves(t.left,e[i].left),right:this._mergeBezierCurves(t.right,e[i].right),bottom:e[i].bottom}))))}));const a=[...new Set(t.map((t=>t.column)))];a.sort(((t,e)=>e-t)),a.forEach((t=>{o.forEach((e=>{const i=e[t],n=e[t-1];i&&n&&e.splice(t-1,2,{top:this._mergeBezierCurves(n.top,i.top),left:n.left,right:i.right,bottom:this._mergeBezierCurves(n.bottom,i.bottom)})}))})),this.setWarpState(e,o)}forEachSplitRegion(t){this.regionPoints.forEach(((e,i)=>{e.forEach(((e,n)=>{const r=e,o=this.regionCurves[i][n].vertical.length-1;r.forEach(((e,s)=>{const a=Math.floor(s/(o+1)),h=s%(o+1),c=r[s],l=r[s+1],u=r[s+o+2],p=r[s+o+1],g=this.originalRegionPoints[i][n][s],x=this.originalRegionPoints[i][n][s+1],f=this.originalRegionPoints[i][n][s+o+2],y=this.originalRegionPoints[i][n][s+o+1];l&&u&&s%(o+1)<o&&t([c,l,u,p],[g,x,f,y],a,h,i,n)}))}))}))}_generateRenderOptions(){var t,e;!this._cacheSourceSize||this._cacheSourceSize.width===this.source.width&&this._cacheSourceSize.height===this.source.height||this.setWarpState(this.splitPoints),this.regionCurves=this._generateAllRegionCurves(this.regionBoundaryCurves),this.regionPoints=this.splitStrategy.execute(this);const{offsetX:i,offsetY:n,width:r,height:o}=this.getBoundingBoxInfo();if(this._inputLimitSize&&!this._cacheInputCanvas){const t=this._inputLimitSize,{width:e,height:i}=this.source,n={width:t.width?Math.min(1,t.width/e):0,height:t.height?Math.min(1,t.height/i):0};n.width=n.width||n.height,n.height=n.height||n.width;const r=Math.min(n.width,n.height),o=document.createElement(\"canvas\");o.width=Math.ceil(e*r),o.height=Math.ceil(i*r);const s=o.getContext(\"2d\");null==s||s.drawImage(this.source,0,0,o.width,o.height),this._inputLimitScale=r,this._cacheInputCanvas=o}if(this._outputLimitSize){let t=1;this._outputLimitSize.width&&(t=Math.min(t,this._outputLimitSize.width/r)),this._outputLimitSize.height&&(t=Math.min(t,this._outputLimitSize.height/o)),this._outputLimitScale=t}let s=null!==(t=this._cacheInputCanvas)&&void 0!==t?t:this.source;const a=null!==(e=this._cacheOutputCanvas)&&void 0!==e?e:null;s===a&&(console.warn(\"[Warpvas] Do not use the same canvas as both input and output. This will require creating a copy of the input canvas before each render operation.\"),s=this._cloneCanvas(s));return{inputCanvas:s,outputCanvas:a,options:{x:i,y:n,width:r,height:o,sourceScale:this._inputLimitScale,destinationScale:this._outputLimitScale}}}_getInputCanvasImageData(t=!0){var e;if(t&&this._cacheSourceImageData)return this._cacheSourceImageData;const i=null!==(e=this._cacheInputCanvas)&&void 0!==e?e:this.source,n=i.getContext(\"2d\");if(!n)throw new Error(\"[Warpvas] Failed to get 2D rendering context. Please ensure that:\\n1. The inputCanvas is a valid <canvas> element\\n2. The browser supports Canvas API\\n3. The canvas has not been tainted by cross-origin content\");const r=n.getImageData(0,0,i.width,i.height);return this._cacheSourceImageData=r,r}render(){const{inputCanvas:t,outputCanvas:e,options:i}=this._generateRenderOptions();if(this._safeModeEnabled)return L(this,t,e,i);const n={\"2d\":L,webgl:D}[this.renderingContext];try{return n(this,t,e,i)}catch(n){if(this.renderingConfig.enableSafeRendering&&\"webgl\"===this.renderingContext)return this._safeModeEnabled=!0,L(this,t,e,i);throw n}}renderWithWorker(t=!0){return e(this,void 0,void 0,(function*(){const{outputCanvas:e,options:i}=this._generateRenderOptions(),n=this._getInputCanvasImageData(t);if(this._safeModeEnabled)return H(this,n,e,i);const r={\"2d\":N,webgl:H}[this.renderingContext];try{return r(this,n,e,i)}catch(t){if(this.renderingConfig.enableSafeRendering&&\"webgl\"===this.renderingContext)return this._safeModeEnabled=!0,H(this,n,e,i);throw t}}))}dispose(){this._safeModeEnabled=!1,this._cacheInputCanvas&&(this._cacheInputCanvas.width=0,this._cacheInputCanvas.height=0,this._cacheInputCanvas=null),this._cacheOutputCanvas&&(this._cacheOutputCanvas.width=0,this._cacheOutputCanvas.height=0,this._cacheOutputCanvas=null),this._cacheSourceImageData=null,this._cacheSourceSize=null,this.splitPoints=[],this.originalRegions=[],this.originalRegionPoints=[],this.regionBoundaryCurves=[],this.regionCurves=[],this.regionPoints=[]}}export{V as Warpvas,I as utils};\n//# sourceMappingURL=index.esm.js.map\n","import { Bezier } from \"./bezier.js\";\n\n// math-inlining.\nconst { abs, cos, sin, acos, atan2, sqrt, pow } = Math;\n\n// cube root function yielding real roots\nfunction crt(v) {\n  return v < 0 ? -pow(-v, 1 / 3) : pow(v, 1 / 3);\n}\n\n// trig constants\nconst pi = Math.PI,\n  tau = 2 * pi,\n  quart = pi / 2,\n  // float precision significant decimal\n  epsilon = 0.000001,\n  // extremas used in bbox calculation and similar algorithms\n  nMax = Number.MAX_SAFE_INTEGER || 9007199254740991,\n  nMin = Number.MIN_SAFE_INTEGER || -9007199254740991,\n  // a zero coordinate, which is surprisingly useful\n  ZERO = { x: 0, y: 0, z: 0 };\n\n// Bezier utility functions\nconst utils = {\n  // Legendre-Gauss abscissae with n=24 (x_i values, defined at i=n as the roots of the nth order Legendre polynomial Pn(x))\n  Tvalues: [\n    -0.0640568928626056260850430826247450385909,\n    0.0640568928626056260850430826247450385909,\n    -0.1911188674736163091586398207570696318404,\n    0.1911188674736163091586398207570696318404,\n    -0.3150426796961633743867932913198102407864,\n    0.3150426796961633743867932913198102407864,\n    -0.4337935076260451384870842319133497124524,\n    0.4337935076260451384870842319133497124524,\n    -0.5454214713888395356583756172183723700107,\n    0.5454214713888395356583756172183723700107,\n    -0.6480936519369755692524957869107476266696,\n    0.6480936519369755692524957869107476266696,\n    -0.7401241915785543642438281030999784255232,\n    0.7401241915785543642438281030999784255232,\n    -0.8200019859739029219539498726697452080761,\n    0.8200019859739029219539498726697452080761,\n    -0.8864155270044010342131543419821967550873,\n    0.8864155270044010342131543419821967550873,\n    -0.9382745520027327585236490017087214496548,\n    0.9382745520027327585236490017087214496548,\n    -0.9747285559713094981983919930081690617411,\n    0.9747285559713094981983919930081690617411,\n    -0.9951872199970213601799974097007368118745,\n    0.9951872199970213601799974097007368118745,\n  ],\n\n  // Legendre-Gauss weights with n=24 (w_i values, defined by a function linked to in the Bezier primer article)\n  Cvalues: [\n    0.1279381953467521569740561652246953718517,\n    0.1279381953467521569740561652246953718517,\n    0.1258374563468282961213753825111836887264,\n    0.1258374563468282961213753825111836887264,\n    0.121670472927803391204463153476262425607,\n    0.121670472927803391204463153476262425607,\n    0.1155056680537256013533444839067835598622,\n    0.1155056680537256013533444839067835598622,\n    0.1074442701159656347825773424466062227946,\n    0.1074442701159656347825773424466062227946,\n    0.0976186521041138882698806644642471544279,\n    0.0976186521041138882698806644642471544279,\n    0.086190161531953275917185202983742667185,\n    0.086190161531953275917185202983742667185,\n    0.0733464814110803057340336152531165181193,\n    0.0733464814110803057340336152531165181193,\n    0.0592985849154367807463677585001085845412,\n    0.0592985849154367807463677585001085845412,\n    0.0442774388174198061686027482113382288593,\n    0.0442774388174198061686027482113382288593,\n    0.0285313886289336631813078159518782864491,\n    0.0285313886289336631813078159518782864491,\n    0.0123412297999871995468056670700372915759,\n    0.0123412297999871995468056670700372915759,\n  ],\n\n  arcfn: function (t, derivativeFn) {\n    const d = derivativeFn(t);\n    let l = d.x * d.x + d.y * d.y;\n    if (typeof d.z !== \"undefined\") {\n      l += d.z * d.z;\n    }\n    return sqrt(l);\n  },\n\n  compute: function (t, points, _3d) {\n    // shortcuts\n    if (t === 0) {\n      points[0].t = 0;\n      return points[0];\n    }\n\n    const order = points.length - 1;\n\n    if (t === 1) {\n      points[order].t = 1;\n      return points[order];\n    }\n\n    const mt = 1 - t;\n    let p = points;\n\n    // constant?\n    if (order === 0) {\n      points[0].t = t;\n      return points[0];\n    }\n\n    // linear?\n    if (order === 1) {\n      const ret = {\n        x: mt * p[0].x + t * p[1].x,\n        y: mt * p[0].y + t * p[1].y,\n        t: t,\n      };\n      if (_3d) {\n        ret.z = mt * p[0].z + t * p[1].z;\n      }\n      return ret;\n    }\n\n    // quadratic/cubic curve?\n    if (order < 4) {\n      let mt2 = mt * mt,\n        t2 = t * t,\n        a,\n        b,\n        c,\n        d = 0;\n      if (order === 2) {\n        p = [p[0], p[1], p[2], ZERO];\n        a = mt2;\n        b = mt * t * 2;\n        c = t2;\n      } else if (order === 3) {\n        a = mt2 * mt;\n        b = mt2 * t * 3;\n        c = mt * t2 * 3;\n        d = t * t2;\n      }\n      const ret = {\n        x: a * p[0].x + b * p[1].x + c * p[2].x + d * p[3].x,\n        y: a * p[0].y + b * p[1].y + c * p[2].y + d * p[3].y,\n        t: t,\n      };\n      if (_3d) {\n        ret.z = a * p[0].z + b * p[1].z + c * p[2].z + d * p[3].z;\n      }\n      return ret;\n    }\n\n    // higher order curves: use de Casteljau's computation\n    const dCpts = JSON.parse(JSON.stringify(points));\n    while (dCpts.length > 1) {\n      for (let i = 0; i < dCpts.length - 1; i++) {\n        dCpts[i] = {\n          x: dCpts[i].x + (dCpts[i + 1].x - dCpts[i].x) * t,\n          y: dCpts[i].y + (dCpts[i + 1].y - dCpts[i].y) * t,\n        };\n        if (typeof dCpts[i].z !== \"undefined\") {\n          dCpts[i].z = dCpts[i].z + (dCpts[i + 1].z - dCpts[i].z) * t;\n        }\n      }\n      dCpts.splice(dCpts.length - 1, 1);\n    }\n    dCpts[0].t = t;\n    return dCpts[0];\n  },\n\n  computeWithRatios: function (t, points, ratios, _3d) {\n    const mt = 1 - t,\n      r = ratios,\n      p = points;\n\n    let f1 = r[0],\n      f2 = r[1],\n      f3 = r[2],\n      f4 = r[3],\n      d;\n\n    // spec for linear\n    f1 *= mt;\n    f2 *= t;\n\n    if (p.length === 2) {\n      d = f1 + f2;\n      return {\n        x: (f1 * p[0].x + f2 * p[1].x) / d,\n        y: (f1 * p[0].y + f2 * p[1].y) / d,\n        z: !_3d ? false : (f1 * p[0].z + f2 * p[1].z) / d,\n        t: t,\n      };\n    }\n\n    // upgrade to quadratic\n    f1 *= mt;\n    f2 *= 2 * mt;\n    f3 *= t * t;\n\n    if (p.length === 3) {\n      d = f1 + f2 + f3;\n      return {\n        x: (f1 * p[0].x + f2 * p[1].x + f3 * p[2].x) / d,\n        y: (f1 * p[0].y + f2 * p[1].y + f3 * p[2].y) / d,\n        z: !_3d ? false : (f1 * p[0].z + f2 * p[1].z + f3 * p[2].z) / d,\n        t: t,\n      };\n    }\n\n    // upgrade to cubic\n    f1 *= mt;\n    f2 *= 1.5 * mt;\n    f3 *= 3 * mt;\n    f4 *= t * t * t;\n\n    if (p.length === 4) {\n      d = f1 + f2 + f3 + f4;\n      return {\n        x: (f1 * p[0].x + f2 * p[1].x + f3 * p[2].x + f4 * p[3].x) / d,\n        y: (f1 * p[0].y + f2 * p[1].y + f3 * p[2].y + f4 * p[3].y) / d,\n        z: !_3d\n          ? false\n          : (f1 * p[0].z + f2 * p[1].z + f3 * p[2].z + f4 * p[3].z) / d,\n        t: t,\n      };\n    }\n  },\n\n  derive: function (points, _3d) {\n    const dpoints = [];\n    for (let p = points, d = p.length, c = d - 1; d > 1; d--, c--) {\n      const list = [];\n      for (let j = 0, dpt; j < c; j++) {\n        dpt = {\n          x: c * (p[j + 1].x - p[j].x),\n          y: c * (p[j + 1].y - p[j].y),\n        };\n        if (_3d) {\n          dpt.z = c * (p[j + 1].z - p[j].z);\n        }\n        list.push(dpt);\n      }\n      dpoints.push(list);\n      p = list;\n    }\n    return dpoints;\n  },\n\n  between: function (v, m, M) {\n    return (\n      (m <= v && v <= M) ||\n      utils.approximately(v, m) ||\n      utils.approximately(v, M)\n    );\n  },\n\n  approximately: function (a, b, precision) {\n    return abs(a - b) <= (precision || epsilon);\n  },\n\n  length: function (derivativeFn) {\n    const z = 0.5,\n      len = utils.Tvalues.length;\n\n    let sum = 0;\n\n    for (let i = 0, t; i < len; i++) {\n      t = z * utils.Tvalues[i] + z;\n      sum += utils.Cvalues[i] * utils.arcfn(t, derivativeFn);\n    }\n    return z * sum;\n  },\n\n  map: function (v, ds, de, ts, te) {\n    const d1 = de - ds,\n      d2 = te - ts,\n      v2 = v - ds,\n      r = v2 / d1;\n    return ts + d2 * r;\n  },\n\n  lerp: function (r, v1, v2) {\n    const ret = {\n      x: v1.x + r * (v2.x - v1.x),\n      y: v1.y + r * (v2.y - v1.y),\n    };\n    if (v1.z !== undefined && v2.z !== undefined) {\n      ret.z = v1.z + r * (v2.z - v1.z);\n    }\n    return ret;\n  },\n\n  pointToString: function (p) {\n    let s = p.x + \"/\" + p.y;\n    if (typeof p.z !== \"undefined\") {\n      s += \"/\" + p.z;\n    }\n    return s;\n  },\n\n  pointsToString: function (points) {\n    return \"[\" + points.map(utils.pointToString).join(\", \") + \"]\";\n  },\n\n  copy: function (obj) {\n    return JSON.parse(JSON.stringify(obj));\n  },\n\n  angle: function (o, v1, v2) {\n    const dx1 = v1.x - o.x,\n      dy1 = v1.y - o.y,\n      dx2 = v2.x - o.x,\n      dy2 = v2.y - o.y,\n      cross = dx1 * dy2 - dy1 * dx2,\n      dot = dx1 * dx2 + dy1 * dy2;\n    return atan2(cross, dot);\n  },\n\n  // round as string, to avoid rounding errors\n  round: function (v, d) {\n    const s = \"\" + v;\n    const pos = s.indexOf(\".\");\n    return parseFloat(s.substring(0, pos + 1 + d));\n  },\n\n  dist: function (p1, p2) {\n    const dx = p1.x - p2.x,\n      dy = p1.y - p2.y;\n    return sqrt(dx * dx + dy * dy);\n  },\n\n  closest: function (LUT, point) {\n    let mdist = pow(2, 63),\n      mpos,\n      d;\n    LUT.forEach(function (p, idx) {\n      d = utils.dist(point, p);\n      if (d < mdist) {\n        mdist = d;\n        mpos = idx;\n      }\n    });\n    return { mdist: mdist, mpos: mpos };\n  },\n\n  abcratio: function (t, n) {\n    // see ratio(t) note on http://pomax.github.io/bezierinfo/#abc\n    if (n !== 2 && n !== 3) {\n      return false;\n    }\n    if (typeof t === \"undefined\") {\n      t = 0.5;\n    } else if (t === 0 || t === 1) {\n      return t;\n    }\n    const bottom = pow(t, n) + pow(1 - t, n),\n      top = bottom - 1;\n    return abs(top / bottom);\n  },\n\n  projectionratio: function (t, n) {\n    // see u(t) note on http://pomax.github.io/bezierinfo/#abc\n    if (n !== 2 && n !== 3) {\n      return false;\n    }\n    if (typeof t === \"undefined\") {\n      t = 0.5;\n    } else if (t === 0 || t === 1) {\n      return t;\n    }\n    const top = pow(1 - t, n),\n      bottom = pow(t, n) + top;\n    return top / bottom;\n  },\n\n  lli8: function (x1, y1, x2, y2, x3, y3, x4, y4) {\n    const nx =\n        (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4),\n      ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4),\n      d = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n    if (d == 0) {\n      return false;\n    }\n    return { x: nx / d, y: ny / d };\n  },\n\n  lli4: function (p1, p2, p3, p4) {\n    const x1 = p1.x,\n      y1 = p1.y,\n      x2 = p2.x,\n      y2 = p2.y,\n      x3 = p3.x,\n      y3 = p3.y,\n      x4 = p4.x,\n      y4 = p4.y;\n    return utils.lli8(x1, y1, x2, y2, x3, y3, x4, y4);\n  },\n\n  lli: function (v1, v2) {\n    return utils.lli4(v1, v1.c, v2, v2.c);\n  },\n\n  makeline: function (p1, p2) {\n    return new Bezier(\n      p1.x,\n      p1.y,\n      (p1.x + p2.x) / 2,\n      (p1.y + p2.y) / 2,\n      p2.x,\n      p2.y\n    );\n  },\n\n  findbbox: function (sections) {\n    let mx = nMax,\n      my = nMax,\n      MX = nMin,\n      MY = nMin;\n    sections.forEach(function (s) {\n      const bbox = s.bbox();\n      if (mx > bbox.x.min) mx = bbox.x.min;\n      if (my > bbox.y.min) my = bbox.y.min;\n      if (MX < bbox.x.max) MX = bbox.x.max;\n      if (MY < bbox.y.max) MY = bbox.y.max;\n    });\n    return {\n      x: { min: mx, mid: (mx + MX) / 2, max: MX, size: MX - mx },\n      y: { min: my, mid: (my + MY) / 2, max: MY, size: MY - my },\n    };\n  },\n\n  shapeintersections: function (\n    s1,\n    bbox1,\n    s2,\n    bbox2,\n    curveIntersectionThreshold\n  ) {\n    if (!utils.bboxoverlap(bbox1, bbox2)) return [];\n    const intersections = [];\n    const a1 = [s1.startcap, s1.forward, s1.back, s1.endcap];\n    const a2 = [s2.startcap, s2.forward, s2.back, s2.endcap];\n    a1.forEach(function (l1) {\n      if (l1.virtual) return;\n      a2.forEach(function (l2) {\n        if (l2.virtual) return;\n        const iss = l1.intersects(l2, curveIntersectionThreshold);\n        if (iss.length > 0) {\n          iss.c1 = l1;\n          iss.c2 = l2;\n          iss.s1 = s1;\n          iss.s2 = s2;\n          intersections.push(iss);\n        }\n      });\n    });\n    return intersections;\n  },\n\n  makeshape: function (forward, back, curveIntersectionThreshold) {\n    const bpl = back.points.length;\n    const fpl = forward.points.length;\n    const start = utils.makeline(back.points[bpl - 1], forward.points[0]);\n    const end = utils.makeline(forward.points[fpl - 1], back.points[0]);\n    const shape = {\n      startcap: start,\n      forward: forward,\n      back: back,\n      endcap: end,\n      bbox: utils.findbbox([start, forward, back, end]),\n    };\n    shape.intersections = function (s2) {\n      return utils.shapeintersections(\n        shape,\n        shape.bbox,\n        s2,\n        s2.bbox,\n        curveIntersectionThreshold\n      );\n    };\n    return shape;\n  },\n\n  getminmax: function (curve, d, list) {\n    if (!list) return { min: 0, max: 0 };\n    let min = nMax,\n      max = nMin,\n      t,\n      c;\n    if (list.indexOf(0) === -1) {\n      list = [0].concat(list);\n    }\n    if (list.indexOf(1) === -1) {\n      list.push(1);\n    }\n    for (let i = 0, len = list.length; i < len; i++) {\n      t = list[i];\n      c = curve.get(t);\n      if (c[d] < min) {\n        min = c[d];\n      }\n      if (c[d] > max) {\n        max = c[d];\n      }\n    }\n    return { min: min, mid: (min + max) / 2, max: max, size: max - min };\n  },\n\n  align: function (points, line) {\n    const tx = line.p1.x,\n      ty = line.p1.y,\n      a = -atan2(line.p2.y - ty, line.p2.x - tx),\n      d = function (v) {\n        return {\n          x: (v.x - tx) * cos(a) - (v.y - ty) * sin(a),\n          y: (v.x - tx) * sin(a) + (v.y - ty) * cos(a),\n        };\n      };\n    return points.map(d);\n  },\n\n  roots: function (points, line) {\n    line = line || { p1: { x: 0, y: 0 }, p2: { x: 1, y: 0 } };\n\n    const order = points.length - 1;\n    const aligned = utils.align(points, line);\n    const reduce = function (t) {\n      return 0 <= t && t <= 1;\n    };\n\n    if (order === 2) {\n      const a = aligned[0].y,\n        b = aligned[1].y,\n        c = aligned[2].y,\n        d = a - 2 * b + c;\n      if (d !== 0) {\n        const m1 = -sqrt(b * b - a * c),\n          m2 = -a + b,\n          v1 = -(m1 + m2) / d,\n          v2 = -(-m1 + m2) / d;\n        return [v1, v2].filter(reduce);\n      } else if (b !== c && d === 0) {\n        return [(2 * b - c) / (2 * b - 2 * c)].filter(reduce);\n      }\n      return [];\n    }\n\n    // see http://www.trans4mind.com/personal_development/mathematics/polynomials/cubicAlgebra.htm\n    const pa = aligned[0].y,\n      pb = aligned[1].y,\n      pc = aligned[2].y,\n      pd = aligned[3].y;\n\n    let d = -pa + 3 * pb - 3 * pc + pd,\n      a = 3 * pa - 6 * pb + 3 * pc,\n      b = -3 * pa + 3 * pb,\n      c = pa;\n\n    if (utils.approximately(d, 0)) {\n      // this is not a cubic curve.\n      if (utils.approximately(a, 0)) {\n        // in fact, this is not a quadratic curve either.\n        if (utils.approximately(b, 0)) {\n          // in fact in fact, there are no solutions.\n          return [];\n        }\n        // linear solution:\n        return [-c / b].filter(reduce);\n      }\n      // quadratic solution:\n      const q = sqrt(b * b - 4 * a * c),\n        a2 = 2 * a;\n      return [(q - b) / a2, (-b - q) / a2].filter(reduce);\n    }\n\n    // at this point, we know we need a cubic solution:\n\n    a /= d;\n    b /= d;\n    c /= d;\n\n    const p = (3 * b - a * a) / 3,\n      p3 = p / 3,\n      q = (2 * a * a * a - 9 * a * b + 27 * c) / 27,\n      q2 = q / 2,\n      discriminant = q2 * q2 + p3 * p3 * p3;\n\n    let u1, v1, x1, x2, x3;\n    if (discriminant < 0) {\n      const mp3 = -p / 3,\n        mp33 = mp3 * mp3 * mp3,\n        r = sqrt(mp33),\n        t = -q / (2 * r),\n        cosphi = t < -1 ? -1 : t > 1 ? 1 : t,\n        phi = acos(cosphi),\n        crtr = crt(r),\n        t1 = 2 * crtr;\n      x1 = t1 * cos(phi / 3) - a / 3;\n      x2 = t1 * cos((phi + tau) / 3) - a / 3;\n      x3 = t1 * cos((phi + 2 * tau) / 3) - a / 3;\n      return [x1, x2, x3].filter(reduce);\n    } else if (discriminant === 0) {\n      u1 = q2 < 0 ? crt(-q2) : -crt(q2);\n      x1 = 2 * u1 - a / 3;\n      x2 = -u1 - a / 3;\n      return [x1, x2].filter(reduce);\n    } else {\n      const sd = sqrt(discriminant);\n      u1 = crt(-q2 + sd);\n      v1 = crt(q2 + sd);\n      return [u1 - v1 - a / 3].filter(reduce);\n    }\n  },\n\n  droots: function (p) {\n    // quadratic roots are easy\n    if (p.length === 3) {\n      const a = p[0],\n        b = p[1],\n        c = p[2],\n        d = a - 2 * b + c;\n      if (d !== 0) {\n        const m1 = -sqrt(b * b - a * c),\n          m2 = -a + b,\n          v1 = -(m1 + m2) / d,\n          v2 = -(-m1 + m2) / d;\n        return [v1, v2];\n      } else if (b !== c && d === 0) {\n        return [(2 * b - c) / (2 * (b - c))];\n      }\n      return [];\n    }\n\n    // linear roots are even easier\n    if (p.length === 2) {\n      const a = p[0],\n        b = p[1];\n      if (a !== b) {\n        return [a / (a - b)];\n      }\n      return [];\n    }\n\n    return [];\n  },\n\n  curvature: function (t, d1, d2, _3d, kOnly) {\n    let num,\n      dnm,\n      adk,\n      dk,\n      k = 0,\n      r = 0;\n\n    //\n    // We're using the following formula for curvature:\n    //\n    //              x'y\" - y'x\"\n    //   k(t) = ------------------\n    //           (x'² + y'²)^(3/2)\n    //\n    // from https://en.wikipedia.org/wiki/Radius_of_curvature#Definition\n    //\n    // With it corresponding 3D counterpart:\n    //\n    //          sqrt( (y'z\" - y\"z')² + (z'x\" - z\"x')² + (x'y\" - x\"y')²)\n    //   k(t) = -------------------------------------------------------\n    //                     (x'² + y'² + z'²)^(3/2)\n    //\n\n    const d = utils.compute(t, d1);\n    const dd = utils.compute(t, d2);\n    const qdsum = d.x * d.x + d.y * d.y;\n\n    if (_3d) {\n      num = sqrt(\n        pow(d.y * dd.z - dd.y * d.z, 2) +\n          pow(d.z * dd.x - dd.z * d.x, 2) +\n          pow(d.x * dd.y - dd.x * d.y, 2)\n      );\n      dnm = pow(qdsum + d.z * d.z, 3 / 2);\n    } else {\n      num = d.x * dd.y - d.y * dd.x;\n      dnm = pow(qdsum, 3 / 2);\n    }\n\n    if (num === 0 || dnm === 0) {\n      return { k: 0, r: 0 };\n    }\n\n    k = num / dnm;\n    r = dnm / num;\n\n    // We're also computing the derivative of kappa, because\n    // there is value in knowing the rate of change for the\n    // curvature along the curve. And we're just going to\n    // ballpark it based on an epsilon.\n    if (!kOnly) {\n      // compute k'(t) based on the interval before, and after it,\n      // to at least try to not introduce forward/backward pass bias.\n      const pk = utils.curvature(t - 0.001, d1, d2, _3d, true).k;\n      const nk = utils.curvature(t + 0.001, d1, d2, _3d, true).k;\n      dk = (nk - k + (k - pk)) / 2;\n      adk = (abs(nk - k) + abs(k - pk)) / 2;\n    }\n\n    return { k: k, r: r, dk: dk, adk: adk };\n  },\n\n  inflections: function (points) {\n    if (points.length < 4) return [];\n\n    // FIXME: TODO: add in inflection abstraction for quartic+ curves?\n\n    const p = utils.align(points, { p1: points[0], p2: points.slice(-1)[0] }),\n      a = p[2].x * p[1].y,\n      b = p[3].x * p[1].y,\n      c = p[1].x * p[2].y,\n      d = p[3].x * p[2].y,\n      v1 = 18 * (-3 * a + 2 * b + 3 * c - d),\n      v2 = 18 * (3 * a - b - 3 * c),\n      v3 = 18 * (c - a);\n\n    if (utils.approximately(v1, 0)) {\n      if (!utils.approximately(v2, 0)) {\n        let t = -v3 / v2;\n        if (0 <= t && t <= 1) return [t];\n      }\n      return [];\n    }\n\n    const d2 = 2 * v1;\n\n    if (utils.approximately(d2, 0)) return [];\n\n    const trm = v2 * v2 - 4 * v1 * v3;\n\n    if (trm < 0) return [];\n\n    const sq = Math.sqrt(trm);\n\n    return [(sq - v2) / d2, -(v2 + sq) / d2].filter(function (r) {\n      return 0 <= r && r <= 1;\n    });\n  },\n\n  bboxoverlap: function (b1, b2) {\n    const dims = [\"x\", \"y\"],\n      len = dims.length;\n\n    for (let i = 0, dim, l, t, d; i < len; i++) {\n      dim = dims[i];\n      l = b1[dim].mid;\n      t = b2[dim].mid;\n      d = (b1[dim].size + b2[dim].size) / 2;\n      if (abs(l - t) >= d) return false;\n    }\n    return true;\n  },\n\n  expandbox: function (bbox, _bbox) {\n    if (_bbox.x.min < bbox.x.min) {\n      bbox.x.min = _bbox.x.min;\n    }\n    if (_bbox.y.min < bbox.y.min) {\n      bbox.y.min = _bbox.y.min;\n    }\n    if (_bbox.z && _bbox.z.min < bbox.z.min) {\n      bbox.z.min = _bbox.z.min;\n    }\n    if (_bbox.x.max > bbox.x.max) {\n      bbox.x.max = _bbox.x.max;\n    }\n    if (_bbox.y.max > bbox.y.max) {\n      bbox.y.max = _bbox.y.max;\n    }\n    if (_bbox.z && _bbox.z.max > bbox.z.max) {\n      bbox.z.max = _bbox.z.max;\n    }\n    bbox.x.mid = (bbox.x.min + bbox.x.max) / 2;\n    bbox.y.mid = (bbox.y.min + bbox.y.max) / 2;\n    if (bbox.z) {\n      bbox.z.mid = (bbox.z.min + bbox.z.max) / 2;\n    }\n    bbox.x.size = bbox.x.max - bbox.x.min;\n    bbox.y.size = bbox.y.max - bbox.y.min;\n    if (bbox.z) {\n      bbox.z.size = bbox.z.max - bbox.z.min;\n    }\n  },\n\n  pairiteration: function (c1, c2, curveIntersectionThreshold) {\n    const c1b = c1.bbox(),\n      c2b = c2.bbox(),\n      r = 100000,\n      threshold = curveIntersectionThreshold || 0.5;\n\n    if (\n      c1b.x.size + c1b.y.size < threshold &&\n      c2b.x.size + c2b.y.size < threshold\n    ) {\n      return [\n        (((r * (c1._t1 + c1._t2)) / 2) | 0) / r +\n          \"/\" +\n          (((r * (c2._t1 + c2._t2)) / 2) | 0) / r,\n      ];\n    }\n\n    let cc1 = c1.split(0.5),\n      cc2 = c2.split(0.5),\n      pairs = [\n        { left: cc1.left, right: cc2.left },\n        { left: cc1.left, right: cc2.right },\n        { left: cc1.right, right: cc2.right },\n        { left: cc1.right, right: cc2.left },\n      ];\n\n    pairs = pairs.filter(function (pair) {\n      return utils.bboxoverlap(pair.left.bbox(), pair.right.bbox());\n    });\n\n    let results = [];\n\n    if (pairs.length === 0) return results;\n\n    pairs.forEach(function (pair) {\n      results = results.concat(\n        utils.pairiteration(pair.left, pair.right, threshold)\n      );\n    });\n\n    results = results.filter(function (v, i) {\n      return results.indexOf(v) === i;\n    });\n\n    return results;\n  },\n\n  getccenter: function (p1, p2, p3) {\n    const dx1 = p2.x - p1.x,\n      dy1 = p2.y - p1.y,\n      dx2 = p3.x - p2.x,\n      dy2 = p3.y - p2.y,\n      dx1p = dx1 * cos(quart) - dy1 * sin(quart),\n      dy1p = dx1 * sin(quart) + dy1 * cos(quart),\n      dx2p = dx2 * cos(quart) - dy2 * sin(quart),\n      dy2p = dx2 * sin(quart) + dy2 * cos(quart),\n      // chord midpoints\n      mx1 = (p1.x + p2.x) / 2,\n      my1 = (p1.y + p2.y) / 2,\n      mx2 = (p2.x + p3.x) / 2,\n      my2 = (p2.y + p3.y) / 2,\n      // midpoint offsets\n      mx1n = mx1 + dx1p,\n      my1n = my1 + dy1p,\n      mx2n = mx2 + dx2p,\n      my2n = my2 + dy2p,\n      // intersection of these lines:\n      arc = utils.lli8(mx1, my1, mx1n, my1n, mx2, my2, mx2n, my2n),\n      r = utils.dist(arc, p1);\n\n    // arc start/end values, over mid point:\n    let s = atan2(p1.y - arc.y, p1.x - arc.x),\n      m = atan2(p2.y - arc.y, p2.x - arc.x),\n      e = atan2(p3.y - arc.y, p3.x - arc.x),\n      _;\n\n    // determine arc direction (cw/ccw correction)\n    if (s < e) {\n      // if s<m<e, arc(s, e)\n      // if m<s<e, arc(e, s + tau)\n      // if s<e<m, arc(e, s + tau)\n      if (s > m || m > e) {\n        s += tau;\n      }\n      if (s > e) {\n        _ = e;\n        e = s;\n        s = _;\n      }\n    } else {\n      // if e<m<s, arc(e, s)\n      // if m<e<s, arc(s, e + tau)\n      // if e<s<m, arc(s, e + tau)\n      if (e < m && m < s) {\n        _ = e;\n        e = s;\n        s = _;\n      } else {\n        e += tau;\n      }\n    }\n    // assign and done.\n    arc.s = s;\n    arc.e = e;\n    arc.r = r;\n    return arc;\n  },\n\n  numberSort: function (a, b) {\n    return a - b;\n  },\n};\n\nexport { utils };\n","import { utils } from \"./utils.js\";\n\n/**\n * Poly Bezier\n * @param {[type]} curves [description]\n */\nclass PolyBezier {\n  constructor(curves) {\n    this.curves = [];\n    this._3d = false;\n    if (!!curves) {\n      this.curves = curves;\n      this._3d = this.curves[0]._3d;\n    }\n  }\n\n  valueOf() {\n    return this.toString();\n  }\n\n  toString() {\n    return (\n      \"[\" +\n      this.curves\n        .map(function (curve) {\n          return utils.pointsToString(curve.points);\n        })\n        .join(\", \") +\n      \"]\"\n    );\n  }\n\n  addCurve(curve) {\n    this.curves.push(curve);\n    this._3d = this._3d || curve._3d;\n  }\n\n  length() {\n    return this.curves\n      .map(function (v) {\n        return v.length();\n      })\n      .reduce(function (a, b) {\n        return a + b;\n      });\n  }\n\n  curve(idx) {\n    return this.curves[idx];\n  }\n\n  bbox() {\n    const c = this.curves;\n    var bbox = c[0].bbox();\n    for (var i = 1; i < c.length; i++) {\n      utils.expandbox(bbox, c[i].bbox());\n    }\n    return bbox;\n  }\n\n  offset(d) {\n    const offset = [];\n    this.curves.forEach(function (v) {\n      offset.push(...v.offset(d));\n    });\n    return new PolyBezier(offset);\n  }\n}\n\nexport { PolyBezier };\n","/**\n  A javascript Bezier curve library by Pomax.\n\n  Based on http://pomax.github.io/bezierinfo\n\n  This code is MIT licensed.\n**/\n\nimport { utils } from \"./utils.js\";\nimport { PolyBezier } from \"./poly-bezier.js\";\n\n// math-inlining.\nconst { abs, min, max, cos, sin, acos, sqrt } = Math;\nconst pi = Math.PI;\n// a zero coordinate, which is surprisingly useful\nconst ZERO = { x: 0, y: 0, z: 0 };\n\n/**\n * Bezier curve constructor.\n *\n * ...docs pending...\n */\nclass Bezier {\n  constructor(coords) {\n    let args =\n      coords && coords.forEach ? coords : Array.from(arguments).slice();\n    let coordlen = false;\n\n    if (typeof args[0] === \"object\") {\n      coordlen = args.length;\n      const newargs = [];\n      args.forEach(function (point) {\n        [\"x\", \"y\", \"z\"].forEach(function (d) {\n          if (typeof point[d] !== \"undefined\") {\n            newargs.push(point[d]);\n          }\n        });\n      });\n      args = newargs;\n    }\n\n    let higher = false;\n    const len = args.length;\n\n    if (coordlen) {\n      if (coordlen > 4) {\n        if (arguments.length !== 1) {\n          throw new Error(\n            \"Only new Bezier(point[]) is accepted for 4th and higher order curves\"\n          );\n        }\n        higher = true;\n      }\n    } else {\n      if (len !== 6 && len !== 8 && len !== 9 && len !== 12) {\n        if (arguments.length !== 1) {\n          throw new Error(\n            \"Only new Bezier(point[]) is accepted for 4th and higher order curves\"\n          );\n        }\n      }\n    }\n\n    const _3d = (this._3d =\n      (!higher && (len === 9 || len === 12)) ||\n      (coords && coords[0] && typeof coords[0].z !== \"undefined\"));\n\n    const points = (this.points = []);\n    for (let idx = 0, step = _3d ? 3 : 2; idx < len; idx += step) {\n      var point = {\n        x: args[idx],\n        y: args[idx + 1],\n      };\n      if (_3d) {\n        point.z = args[idx + 2];\n      }\n      points.push(point);\n    }\n    const order = (this.order = points.length - 1);\n\n    const dims = (this.dims = [\"x\", \"y\"]);\n    if (_3d) dims.push(\"z\");\n    this.dimlen = dims.length;\n\n    // is this curve, practically speaking, a straight line?\n    const aligned = utils.align(points, { p1: points[0], p2: points[order] });\n    const baselength = utils.dist(points[0], points[order]);\n    this._linear = aligned.reduce((t, p) => t + abs(p.y), 0) < baselength / 50;\n\n    this._lut = [];\n    this._t1 = 0;\n    this._t2 = 1;\n    this.update();\n  }\n\n  static quadraticFromPoints(p1, p2, p3, t) {\n    if (typeof t === \"undefined\") {\n      t = 0.5;\n    }\n    // shortcuts, although they're really dumb\n    if (t === 0) {\n      return new Bezier(p2, p2, p3);\n    }\n    if (t === 1) {\n      return new Bezier(p1, p2, p2);\n    }\n    // real fitting.\n    const abc = Bezier.getABC(2, p1, p2, p3, t);\n    return new Bezier(p1, abc.A, p3);\n  }\n\n  static cubicFromPoints(S, B, E, t, d1) {\n    if (typeof t === \"undefined\") {\n      t = 0.5;\n    }\n    const abc = Bezier.getABC(3, S, B, E, t);\n    if (typeof d1 === \"undefined\") {\n      d1 = utils.dist(B, abc.C);\n    }\n    const d2 = (d1 * (1 - t)) / t;\n\n    const selen = utils.dist(S, E),\n      lx = (E.x - S.x) / selen,\n      ly = (E.y - S.y) / selen,\n      bx1 = d1 * lx,\n      by1 = d1 * ly,\n      bx2 = d2 * lx,\n      by2 = d2 * ly;\n    // derivation of new hull coordinates\n    const e1 = { x: B.x - bx1, y: B.y - by1 },\n      e2 = { x: B.x + bx2, y: B.y + by2 },\n      A = abc.A,\n      v1 = { x: A.x + (e1.x - A.x) / (1 - t), y: A.y + (e1.y - A.y) / (1 - t) },\n      v2 = { x: A.x + (e2.x - A.x) / t, y: A.y + (e2.y - A.y) / t },\n      nc1 = { x: S.x + (v1.x - S.x) / t, y: S.y + (v1.y - S.y) / t },\n      nc2 = {\n        x: E.x + (v2.x - E.x) / (1 - t),\n        y: E.y + (v2.y - E.y) / (1 - t),\n      };\n    // ...done\n    return new Bezier(S, nc1, nc2, E);\n  }\n\n  static getUtils() {\n    return utils;\n  }\n\n  getUtils() {\n    return Bezier.getUtils();\n  }\n\n  static get PolyBezier() {\n    return PolyBezier;\n  }\n\n  valueOf() {\n    return this.toString();\n  }\n\n  toString() {\n    return utils.pointsToString(this.points);\n  }\n\n  toSVG() {\n    if (this._3d) return false;\n    const p = this.points,\n      x = p[0].x,\n      y = p[0].y,\n      s = [\"M\", x, y, this.order === 2 ? \"Q\" : \"C\"];\n    for (let i = 1, last = p.length; i < last; i++) {\n      s.push(p[i].x);\n      s.push(p[i].y);\n    }\n    return s.join(\" \");\n  }\n\n  setRatios(ratios) {\n    if (ratios.length !== this.points.length) {\n      throw new Error(\"incorrect number of ratio values\");\n    }\n    this.ratios = ratios;\n    this._lut = []; //  invalidate any precomputed LUT\n  }\n\n  verify() {\n    const print = this.coordDigest();\n    if (print !== this._print) {\n      this._print = print;\n      this.update();\n    }\n  }\n\n  coordDigest() {\n    return this.points\n      .map(function (c, pos) {\n        return \"\" + pos + c.x + c.y + (c.z ? c.z : 0);\n      })\n      .join(\"\");\n  }\n\n  update() {\n    // invalidate any precomputed LUT\n    this._lut = [];\n    this.dpoints = utils.derive(this.points, this._3d);\n    this.computedirection();\n  }\n\n  computedirection() {\n    const points = this.points;\n    const angle = utils.angle(points[0], points[this.order], points[1]);\n    this.clockwise = angle > 0;\n  }\n\n  length() {\n    return utils.length(this.derivative.bind(this));\n  }\n\n  static getABC(order = 2, S, B, E, t = 0.5) {\n    const u = utils.projectionratio(t, order),\n      um = 1 - u,\n      C = {\n        x: u * S.x + um * E.x,\n        y: u * S.y + um * E.y,\n      },\n      s = utils.abcratio(t, order),\n      A = {\n        x: B.x + (B.x - C.x) / s,\n        y: B.y + (B.y - C.y) / s,\n      };\n    return { A, B, C, S, E };\n  }\n\n  getABC(t, B) {\n    B = B || this.get(t);\n    let S = this.points[0];\n    let E = this.points[this.order];\n    return Bezier.getABC(this.order, S, B, E, t);\n  }\n\n  getLUT(steps) {\n    this.verify();\n    steps = steps || 100;\n    if (this._lut.length === steps + 1) {\n      return this._lut;\n    }\n    this._lut = [];\n    // n steps means n+1 points\n    steps++;\n    this._lut = [];\n    for (let i = 0, p, t; i < steps; i++) {\n      t = i / (steps - 1);\n      p = this.compute(t);\n      p.t = t;\n      this._lut.push(p);\n    }\n    return this._lut;\n  }\n\n  on(point, error) {\n    error = error || 5;\n    const lut = this.getLUT(),\n      hits = [];\n    for (let i = 0, c, t = 0; i < lut.length; i++) {\n      c = lut[i];\n      if (utils.dist(c, point) < error) {\n        hits.push(c);\n        t += i / lut.length;\n      }\n    }\n    if (!hits.length) return false;\n    return (t /= hits.length);\n  }\n\n  project(point) {\n    // step 1: coarse check\n    const LUT = this.getLUT(),\n      l = LUT.length - 1,\n      closest = utils.closest(LUT, point),\n      mpos = closest.mpos,\n      t1 = (mpos - 1) / l,\n      t2 = (mpos + 1) / l,\n      step = 0.1 / l;\n\n    // step 2: fine check\n    let mdist = closest.mdist,\n      t = t1,\n      ft = t,\n      p;\n    mdist += 1;\n    for (let d; t < t2 + step; t += step) {\n      p = this.compute(t);\n      d = utils.dist(point, p);\n      if (d < mdist) {\n        mdist = d;\n        ft = t;\n      }\n    }\n    ft = ft < 0 ? 0 : ft > 1 ? 1 : ft;\n    p = this.compute(ft);\n    p.t = ft;\n    p.d = mdist;\n    return p;\n  }\n\n  get(t) {\n    return this.compute(t);\n  }\n\n  point(idx) {\n    return this.points[idx];\n  }\n\n  compute(t) {\n    if (this.ratios) {\n      return utils.computeWithRatios(t, this.points, this.ratios, this._3d);\n    }\n    return utils.compute(t, this.points, this._3d, this.ratios);\n  }\n\n  raise() {\n    const p = this.points,\n      np = [p[0]],\n      k = p.length;\n    for (let i = 1, pi, pim; i < k; i++) {\n      pi = p[i];\n      pim = p[i - 1];\n      np[i] = {\n        x: ((k - i) / k) * pi.x + (i / k) * pim.x,\n        y: ((k - i) / k) * pi.y + (i / k) * pim.y,\n      };\n    }\n    np[k] = p[k - 1];\n    return new Bezier(np);\n  }\n\n  derivative(t) {\n    return utils.compute(t, this.dpoints[0], this._3d);\n  }\n\n  dderivative(t) {\n    return utils.compute(t, this.dpoints[1], this._3d);\n  }\n\n  align() {\n    let p = this.points;\n    return new Bezier(utils.align(p, { p1: p[0], p2: p[p.length - 1] }));\n  }\n\n  curvature(t) {\n    return utils.curvature(t, this.dpoints[0], this.dpoints[1], this._3d);\n  }\n\n  inflections() {\n    return utils.inflections(this.points);\n  }\n\n  normal(t) {\n    return this._3d ? this.__normal3(t) : this.__normal2(t);\n  }\n\n  __normal2(t) {\n    const d = this.derivative(t);\n    const q = sqrt(d.x * d.x + d.y * d.y);\n    return { t, x: -d.y / q, y: d.x / q };\n  }\n\n  __normal3(t) {\n    // see http://stackoverflow.com/questions/25453159\n    const r1 = this.derivative(t),\n      r2 = this.derivative(t + 0.01),\n      q1 = sqrt(r1.x * r1.x + r1.y * r1.y + r1.z * r1.z),\n      q2 = sqrt(r2.x * r2.x + r2.y * r2.y + r2.z * r2.z);\n    r1.x /= q1;\n    r1.y /= q1;\n    r1.z /= q1;\n    r2.x /= q2;\n    r2.y /= q2;\n    r2.z /= q2;\n    // cross product\n    const c = {\n      x: r2.y * r1.z - r2.z * r1.y,\n      y: r2.z * r1.x - r2.x * r1.z,\n      z: r2.x * r1.y - r2.y * r1.x,\n    };\n    const m = sqrt(c.x * c.x + c.y * c.y + c.z * c.z);\n    c.x /= m;\n    c.y /= m;\n    c.z /= m;\n    // rotation matrix\n    const R = [\n      c.x * c.x,\n      c.x * c.y - c.z,\n      c.x * c.z + c.y,\n      c.x * c.y + c.z,\n      c.y * c.y,\n      c.y * c.z - c.x,\n      c.x * c.z - c.y,\n      c.y * c.z + c.x,\n      c.z * c.z,\n    ];\n    // normal vector:\n    const n = {\n      t,\n      x: R[0] * r1.x + R[1] * r1.y + R[2] * r1.z,\n      y: R[3] * r1.x + R[4] * r1.y + R[5] * r1.z,\n      z: R[6] * r1.x + R[7] * r1.y + R[8] * r1.z,\n    };\n    return n;\n  }\n\n  hull(t) {\n    let p = this.points,\n      _p = [],\n      q = [],\n      idx = 0;\n    q[idx++] = p[0];\n    q[idx++] = p[1];\n    q[idx++] = p[2];\n    if (this.order === 3) {\n      q[idx++] = p[3];\n    }\n    // we lerp between all points at each iteration, until we have 1 point left.\n    while (p.length > 1) {\n      _p = [];\n      for (let i = 0, pt, l = p.length - 1; i < l; i++) {\n        pt = utils.lerp(t, p[i], p[i + 1]);\n        q[idx++] = pt;\n        _p.push(pt);\n      }\n      p = _p;\n    }\n    return q;\n  }\n\n  split(t1, t2) {\n    // shortcuts\n    if (t1 === 0 && !!t2) {\n      return this.split(t2).left;\n    }\n    if (t2 === 1) {\n      return this.split(t1).right;\n    }\n\n    // no shortcut: use \"de Casteljau\" iteration.\n    const q = this.hull(t1);\n    const result = {\n      left:\n        this.order === 2\n          ? new Bezier([q[0], q[3], q[5]])\n          : new Bezier([q[0], q[4], q[7], q[9]]),\n      right:\n        this.order === 2\n          ? new Bezier([q[5], q[4], q[2]])\n          : new Bezier([q[9], q[8], q[6], q[3]]),\n      span: q,\n    };\n\n    // make sure we bind _t1/_t2 information!\n    result.left._t1 = utils.map(0, 0, 1, this._t1, this._t2);\n    result.left._t2 = utils.map(t1, 0, 1, this._t1, this._t2);\n    result.right._t1 = utils.map(t1, 0, 1, this._t1, this._t2);\n    result.right._t2 = utils.map(1, 0, 1, this._t1, this._t2);\n\n    // if we have no t2, we're done\n    if (!t2) {\n      return result;\n    }\n\n    // if we have a t2, split again:\n    t2 = utils.map(t2, t1, 1, 0, 1);\n    return result.right.split(t2).left;\n  }\n\n  extrema() {\n    const result = {};\n    let roots = [];\n\n    this.dims.forEach(\n      function (dim) {\n        let mfn = function (v) {\n          return v[dim];\n        };\n        let p = this.dpoints[0].map(mfn);\n        result[dim] = utils.droots(p);\n        if (this.order === 3) {\n          p = this.dpoints[1].map(mfn);\n          result[dim] = result[dim].concat(utils.droots(p));\n        }\n        result[dim] = result[dim].filter(function (t) {\n          return t >= 0 && t <= 1;\n        });\n        roots = roots.concat(result[dim].sort(utils.numberSort));\n      }.bind(this)\n    );\n\n    result.values = roots.sort(utils.numberSort).filter(function (v, idx) {\n      return roots.indexOf(v) === idx;\n    });\n\n    return result;\n  }\n\n  bbox() {\n    const extrema = this.extrema(),\n      result = {};\n    this.dims.forEach(\n      function (d) {\n        result[d] = utils.getminmax(this, d, extrema[d]);\n      }.bind(this)\n    );\n    return result;\n  }\n\n  overlaps(curve) {\n    const lbbox = this.bbox(),\n      tbbox = curve.bbox();\n    return utils.bboxoverlap(lbbox, tbbox);\n  }\n\n  offset(t, d) {\n    if (typeof d !== \"undefined\") {\n      const c = this.get(t),\n        n = this.normal(t);\n      const ret = {\n        c: c,\n        n: n,\n        x: c.x + n.x * d,\n        y: c.y + n.y * d,\n      };\n      if (this._3d) {\n        ret.z = c.z + n.z * d;\n      }\n      return ret;\n    }\n    if (this._linear) {\n      const nv = this.normal(0),\n        coords = this.points.map(function (p) {\n          const ret = {\n            x: p.x + t * nv.x,\n            y: p.y + t * nv.y,\n          };\n          if (p.z && nv.z) {\n            ret.z = p.z + t * nv.z;\n          }\n          return ret;\n        });\n      return [new Bezier(coords)];\n    }\n    return this.reduce().map(function (s) {\n      if (s._linear) {\n        return s.offset(t)[0];\n      }\n      return s.scale(t);\n    });\n  }\n\n  simple() {\n    if (this.order === 3) {\n      const a1 = utils.angle(this.points[0], this.points[3], this.points[1]);\n      const a2 = utils.angle(this.points[0], this.points[3], this.points[2]);\n      if ((a1 > 0 && a2 < 0) || (a1 < 0 && a2 > 0)) return false;\n    }\n    const n1 = this.normal(0);\n    const n2 = this.normal(1);\n    let s = n1.x * n2.x + n1.y * n2.y;\n    if (this._3d) {\n      s += n1.z * n2.z;\n    }\n    return abs(acos(s)) < pi / 3;\n  }\n\n  reduce() {\n    // TODO: examine these var types in more detail...\n    let i,\n      t1 = 0,\n      t2 = 0,\n      step = 0.01,\n      segment,\n      pass1 = [],\n      pass2 = [];\n    // first pass: split on extrema\n    let extrema = this.extrema().values;\n    if (extrema.indexOf(0) === -1) {\n      extrema = [0].concat(extrema);\n    }\n    if (extrema.indexOf(1) === -1) {\n      extrema.push(1);\n    }\n\n    for (t1 = extrema[0], i = 1; i < extrema.length; i++) {\n      t2 = extrema[i];\n      segment = this.split(t1, t2);\n      segment._t1 = t1;\n      segment._t2 = t2;\n      pass1.push(segment);\n      t1 = t2;\n    }\n\n    // second pass: further reduce these segments to simple segments\n    pass1.forEach(function (p1) {\n      t1 = 0;\n      t2 = 0;\n      while (t2 <= 1) {\n        for (t2 = t1 + step; t2 <= 1 + step; t2 += step) {\n          segment = p1.split(t1, t2);\n          if (!segment.simple()) {\n            t2 -= step;\n            if (abs(t1 - t2) < step) {\n              // we can never form a reduction\n              return [];\n            }\n            segment = p1.split(t1, t2);\n            segment._t1 = utils.map(t1, 0, 1, p1._t1, p1._t2);\n            segment._t2 = utils.map(t2, 0, 1, p1._t1, p1._t2);\n            pass2.push(segment);\n            t1 = t2;\n            break;\n          }\n        }\n      }\n      if (t1 < 1) {\n        segment = p1.split(t1, 1);\n        segment._t1 = utils.map(t1, 0, 1, p1._t1, p1._t2);\n        segment._t2 = p1._t2;\n        pass2.push(segment);\n      }\n    });\n    return pass2;\n  }\n\n  translate(v, d1, d2) {\n    d2 = typeof d2 === \"number\" ? d2 : d1;\n\n    // TODO: make this take curves with control points outside\n    //       of the start-end interval into account\n\n    const o = this.order;\n    let d = this.points.map((_, i) => (1 - i / o) * d1 + (i / o) * d2);\n    return new Bezier(\n      this.points.map((p, i) => ({\n        x: p.x + v.x * d[i],\n        y: p.y + v.y * d[i],\n      }))\n    );\n  }\n\n  scale(d) {\n    const order = this.order;\n    let distanceFn = false;\n    if (typeof d === \"function\") {\n      distanceFn = d;\n    }\n    if (distanceFn && order === 2) {\n      return this.raise().scale(distanceFn);\n    }\n\n    // TODO: add special handling for non-linear degenerate curves.\n\n    const clockwise = this.clockwise;\n    const points = this.points;\n\n    if (this._linear) {\n      return this.translate(\n        this.normal(0),\n        distanceFn ? distanceFn(0) : d,\n        distanceFn ? distanceFn(1) : d\n      );\n    }\n\n    const r1 = distanceFn ? distanceFn(0) : d;\n    const r2 = distanceFn ? distanceFn(1) : d;\n    const v = [this.offset(0, 10), this.offset(1, 10)];\n    const np = [];\n    const o = utils.lli4(v[0], v[0].c, v[1], v[1].c);\n\n    if (!o) {\n      throw new Error(\"cannot scale this curve. Try reducing it first.\");\n    }\n\n    // move all points by distance 'd' wrt the origin 'o',\n    // and move end points by fixed distance along normal.\n    [0, 1].forEach(function (t) {\n      const p = (np[t * order] = utils.copy(points[t * order]));\n      p.x += (t ? r2 : r1) * v[t].n.x;\n      p.y += (t ? r2 : r1) * v[t].n.y;\n    });\n\n    if (!distanceFn) {\n      // move control points to lie on the intersection of the offset\n      // derivative vector, and the origin-through-control vector\n      [0, 1].forEach((t) => {\n        if (order === 2 && !!t) return;\n        const p = np[t * order];\n        const d = this.derivative(t);\n        const p2 = { x: p.x + d.x, y: p.y + d.y };\n        np[t + 1] = utils.lli4(p, p2, o, points[t + 1]);\n      });\n      return new Bezier(np);\n    }\n\n    // move control points by \"however much necessary to\n    // ensure the correct tangent to endpoint\".\n    [0, 1].forEach(function (t) {\n      if (order === 2 && !!t) return;\n      var p = points[t + 1];\n      var ov = {\n        x: p.x - o.x,\n        y: p.y - o.y,\n      };\n      var rc = distanceFn ? distanceFn((t + 1) / order) : d;\n      if (distanceFn && !clockwise) rc = -rc;\n      var m = sqrt(ov.x * ov.x + ov.y * ov.y);\n      ov.x /= m;\n      ov.y /= m;\n      np[t + 1] = {\n        x: p.x + rc * ov.x,\n        y: p.y + rc * ov.y,\n      };\n    });\n    return new Bezier(np);\n  }\n\n  outline(d1, d2, d3, d4) {\n    d2 = d2 === undefined ? d1 : d2;\n\n    if (this._linear) {\n      // TODO: find the actual extrema, because they might\n      //       be before the start, or past the end.\n\n      const n = this.normal(0);\n      const start = this.points[0];\n      const end = this.points[this.points.length - 1];\n      let s, mid, e;\n\n      if (d3 === undefined) {\n        d3 = d1;\n        d4 = d2;\n      }\n\n      s = { x: start.x + n.x * d1, y: start.y + n.y * d1 };\n      e = { x: end.x + n.x * d3, y: end.y + n.y * d3 };\n      mid = { x: (s.x + e.x) / 2, y: (s.y + e.y) / 2 };\n      const fline = [s, mid, e];\n\n      s = { x: start.x - n.x * d2, y: start.y - n.y * d2 };\n      e = { x: end.x - n.x * d4, y: end.y - n.y * d4 };\n      mid = { x: (s.x + e.x) / 2, y: (s.y + e.y) / 2 };\n      const bline = [e, mid, s];\n\n      const ls = utils.makeline(bline[2], fline[0]);\n      const le = utils.makeline(fline[2], bline[0]);\n      const segments = [ls, new Bezier(fline), le, new Bezier(bline)];\n      return new PolyBezier(segments);\n    }\n\n    const reduced = this.reduce(),\n      len = reduced.length,\n      fcurves = [];\n\n    let bcurves = [],\n      p,\n      alen = 0,\n      tlen = this.length();\n\n    const graduated = typeof d3 !== \"undefined\" && typeof d4 !== \"undefined\";\n\n    function linearDistanceFunction(s, e, tlen, alen, slen) {\n      return function (v) {\n        const f1 = alen / tlen,\n          f2 = (alen + slen) / tlen,\n          d = e - s;\n        return utils.map(v, 0, 1, s + f1 * d, s + f2 * d);\n      };\n    }\n\n    // form curve oulines\n    reduced.forEach(function (segment) {\n      const slen = segment.length();\n      if (graduated) {\n        fcurves.push(\n          segment.scale(linearDistanceFunction(d1, d3, tlen, alen, slen))\n        );\n        bcurves.push(\n          segment.scale(linearDistanceFunction(-d2, -d4, tlen, alen, slen))\n        );\n      } else {\n        fcurves.push(segment.scale(d1));\n        bcurves.push(segment.scale(-d2));\n      }\n      alen += slen;\n    });\n\n    // reverse the \"return\" outline\n    bcurves = bcurves\n      .map(function (s) {\n        p = s.points;\n        if (p[3]) {\n          s.points = [p[3], p[2], p[1], p[0]];\n        } else {\n          s.points = [p[2], p[1], p[0]];\n        }\n        return s;\n      })\n      .reverse();\n\n    // form the endcaps as lines\n    const fs = fcurves[0].points[0],\n      fe = fcurves[len - 1].points[fcurves[len - 1].points.length - 1],\n      bs = bcurves[len - 1].points[bcurves[len - 1].points.length - 1],\n      be = bcurves[0].points[0],\n      ls = utils.makeline(bs, fs),\n      le = utils.makeline(fe, be),\n      segments = [ls].concat(fcurves).concat([le]).concat(bcurves);\n\n    return new PolyBezier(segments);\n  }\n\n  outlineshapes(d1, d2, curveIntersectionThreshold) {\n    d2 = d2 || d1;\n    const outline = this.outline(d1, d2).curves;\n    const shapes = [];\n    for (let i = 1, len = outline.length; i < len / 2; i++) {\n      const shape = utils.makeshape(\n        outline[i],\n        outline[len - i],\n        curveIntersectionThreshold\n      );\n      shape.startcap.virtual = i > 1;\n      shape.endcap.virtual = i < len / 2 - 1;\n      shapes.push(shape);\n    }\n    return shapes;\n  }\n\n  intersects(curve, curveIntersectionThreshold) {\n    if (!curve) return this.selfintersects(curveIntersectionThreshold);\n    if (curve.p1 && curve.p2) {\n      return this.lineIntersects(curve);\n    }\n    if (curve instanceof Bezier) {\n      curve = curve.reduce();\n    }\n    return this.curveintersects(\n      this.reduce(),\n      curve,\n      curveIntersectionThreshold\n    );\n  }\n\n  lineIntersects(line) {\n    const mx = min(line.p1.x, line.p2.x),\n      my = min(line.p1.y, line.p2.y),\n      MX = max(line.p1.x, line.p2.x),\n      MY = max(line.p1.y, line.p2.y);\n    return utils.roots(this.points, line).filter((t) => {\n      var p = this.get(t);\n      return utils.between(p.x, mx, MX) && utils.between(p.y, my, MY);\n    });\n  }\n\n  selfintersects(curveIntersectionThreshold) {\n    // \"simple\" curves cannot intersect with their direct\n    // neighbour, so for each segment X we check whether\n    // it intersects [0:x-2][x+2:last].\n\n    const reduced = this.reduce(),\n      len = reduced.length - 2,\n      results = [];\n\n    for (let i = 0, result, left, right; i < len; i++) {\n      left = reduced.slice(i, i + 1);\n      right = reduced.slice(i + 2);\n      result = this.curveintersects(left, right, curveIntersectionThreshold);\n      results.push(...result);\n    }\n    return results;\n  }\n\n  curveintersects(c1, c2, curveIntersectionThreshold) {\n    const pairs = [];\n    // step 1: pair off any overlapping segments\n    c1.forEach(function (l) {\n      c2.forEach(function (r) {\n        if (l.overlaps(r)) {\n          pairs.push({ left: l, right: r });\n        }\n      });\n    });\n    // step 2: for each pairing, run through the convergence algorithm.\n    let intersections = [];\n    pairs.forEach(function (pair) {\n      const result = utils.pairiteration(\n        pair.left,\n        pair.right,\n        curveIntersectionThreshold\n      );\n      if (result.length > 0) {\n        intersections = intersections.concat(result);\n      }\n    });\n    return intersections;\n  }\n\n  arcs(errorThreshold) {\n    errorThreshold = errorThreshold || 0.5;\n    return this._iterate(errorThreshold, []);\n  }\n\n  _error(pc, np1, s, e) {\n    const q = (e - s) / 4,\n      c1 = this.get(s + q),\n      c2 = this.get(e - q),\n      ref = utils.dist(pc, np1),\n      d1 = utils.dist(pc, c1),\n      d2 = utils.dist(pc, c2);\n    return abs(d1 - ref) + abs(d2 - ref);\n  }\n\n  _iterate(errorThreshold, circles) {\n    let t_s = 0,\n      t_e = 1,\n      safety;\n    // we do a binary search to find the \"good `t` closest to no-longer-good\"\n    do {\n      safety = 0;\n\n      // step 1: start with the maximum possible arc\n      t_e = 1;\n\n      // points:\n      let np1 = this.get(t_s),\n        np2,\n        np3,\n        arc,\n        prev_arc;\n\n      // booleans:\n      let curr_good = false,\n        prev_good = false,\n        done;\n\n      // numbers:\n      let t_m = t_e,\n        prev_e = 1,\n        step = 0;\n\n      // step 2: find the best possible arc\n      do {\n        prev_good = curr_good;\n        prev_arc = arc;\n        t_m = (t_s + t_e) / 2;\n        step++;\n\n        np2 = this.get(t_m);\n        np3 = this.get(t_e);\n\n        arc = utils.getccenter(np1, np2, np3);\n\n        //also save the t values\n        arc.interval = {\n          start: t_s,\n          end: t_e,\n        };\n\n        let error = this._error(arc, np1, t_s, t_e);\n        curr_good = error <= errorThreshold;\n\n        done = prev_good && !curr_good;\n        if (!done) prev_e = t_e;\n\n        // this arc is fine: we can move 'e' up to see if we can find a wider arc\n        if (curr_good) {\n          // if e is already at max, then we're done for this arc.\n          if (t_e >= 1) {\n            // make sure we cap at t=1\n            arc.interval.end = prev_e = 1;\n            prev_arc = arc;\n            // if we capped the arc segment to t=1 we also need to make sure that\n            // the arc's end angle is correct with respect to the bezier end point.\n            if (t_e > 1) {\n              let d = {\n                x: arc.x + arc.r * cos(arc.e),\n                y: arc.y + arc.r * sin(arc.e),\n              };\n              arc.e += utils.angle({ x: arc.x, y: arc.y }, d, this.get(1));\n            }\n            break;\n          }\n          // if not, move it up by half the iteration distance\n          t_e = t_e + (t_e - t_s) / 2;\n        } else {\n          // this is a bad arc: we need to move 'e' down to find a good arc\n          t_e = t_m;\n        }\n      } while (!done && safety++ < 100);\n\n      if (safety >= 100) {\n        break;\n      }\n\n      // console.log(\"L835: [F] arc found\", t_s, prev_e, prev_arc.x, prev_arc.y, prev_arc.s, prev_arc.e);\n\n      prev_arc = prev_arc ? prev_arc : arc;\n      circles.push(prev_arc);\n      t_s = prev_e;\n    } while (t_e < 1);\n    return circles;\n  }\n}\n\nexport { Bezier };\n","import { Warpvas, utils } from 'warpvas';\nimport { Bezier } from 'bezier-js';\nimport type { Region } from 'warpvas/dist/warpvas.class';\n\ntype Coord = { x: number; y: number };\n\n/**\n * Warpvas 透视变形计算策略\n *\n * @param warpvas - 需要进行透视变形的贴图对象\n * @returns 返回三维数组，表示网格的分割点坐标：\n * - 第一维：行索引\n * - 第二维：列索引\n * - 第三维：点的坐标 {x, y}\n *\n * @throws {Error} 当四个顶点形成无效的透视形状时抛出错误\n *\n * @example\n * ```typescript\n * import { Warpvas } from 'warpvas';\n * import perspective from 'warpvas-perspective';\n *\n * const warpvas = new warpvas(image);\n * warpvas.setSplitStrategy(perspective);\n * warpvas.render();\n * ```\n *\n * @remarks\n * 当变形区域其中三个顶点形成三角形，而另一个被前面三角形包含时，透视失效会抛出错误，请预先处理该错误逻辑\n */\nconst strategy = {\n  name: 'perspective',\n  execute: (warpvas: Warpvas) => {\n    const splitPoints: Coord[][][] = [];\n\n    // 根据透视关系获取位置t值\n    const getT = (start: number, end: number, item: number, total: number) => {\n      if (start === end) return item / total;\n\n      const d = start / end - 1;\n      const dt = (item / total) * d;\n      const lt = (1 / (1 + dt)) * start;\n      const t = 1 - (lt - end) / (start - end);\n\n      // 限制t值 [0, 1]\n      return Math.min(1, Math.max(0, t));\n    };\n\n    // 判断是否有效透视\n    const isInvalid = (vertexs: Region) => {\n      const intersectionPoint1 = utils.calcIntersection(\n        vertexs.tl,\n        vertexs.tr,\n        vertexs.bl,\n        vertexs.br\n      );\n      const intersectionPoint2 = utils.calcIntersection(\n        vertexs.tl,\n        vertexs.bl,\n        vertexs.tr,\n        vertexs.br\n      );\n\n      const isInValidPerspective = (point: Coord | null) =>\n        point &&\n        Object.values(vertexs).some((vertex, index, arr) =>\n          utils.isTriangleContainsPoint(\n            point,\n            arr[index],\n            arr[(index + 1) % 4],\n            arr[(index + 2) % 4]\n          )\n        );\n\n      return (\n        isInValidPerspective(intersectionPoint1) ||\n        isInValidPerspective(intersectionPoint2)\n      );\n    };\n\n    warpvas.regionBoundaryCurves.forEach((row, rowIndex) => {\n      const _row: Coord[][] = [];\n      row.forEach((col, colIndex) => {\n        const _col: Coord[] = [];\n\n        const bounds = col;\n        const vertexs = {\n          tl: bounds.top.points[0],\n          tr: bounds.top.points[3],\n          bl: bounds.bottom.points[0],\n          br: bounds.bottom.points[3],\n        };\n\n        if (isInvalid(vertexs))\n          throw new Error(\n            '[Warpvas: Perspective] Invalid perspective shape: The four control points cannot form a triangle or cross each other'\n          );\n\n        const lengths = {\n          left: new Bezier(bounds.left.points).length(),\n          right: new Bezier(bounds.right.points).length(),\n          top: new Bezier(bounds.top.points).length(),\n          bottom: new Bezier(bounds.bottom.points).length(),\n        };\n\n        // 找点透视消失点\n        const verticalVanishingPoint = utils.calcIntersection(\n          vertexs.tl,\n          vertexs.bl,\n          vertexs.tr,\n          vertexs.br\n        );\n        const horizontalVanishingPoint = utils.calcIntersection(\n          vertexs.tl,\n          vertexs.tr,\n          vertexs.bl,\n          vertexs.br\n        );\n\n        const { vertical, horizontal } =\n          warpvas.regionCurves[rowIndex][colIndex];\n        const rows = horizontal.length - 1;\n        const cols = vertical.length - 1;\n\n        for (let row = 0; row < horizontal.length; row++) {\n          for (let col = 0; col < vertical.length; col++) {\n            // 找所在的两条线\n            // 找纵向线条\n            // 找纵向线条对应的两个端点\n            let vPoint1 = bounds.top.get(col / cols);\n            let vPoint2 = bounds.bottom.get(col / cols);\n            if (horizontalVanishingPoint) {\n              // 找顶部对应位置的t值\n              const ratio_tl_tr =\n                utils.calcCoordDistance(vertexs.tl, horizontalVanishingPoint) /\n                utils.calcCoordDistance(vertexs.tr, horizontalVanishingPoint);\n              const t1 = getT(\n                lengths.left,\n                lengths.left / ratio_tl_tr,\n                col,\n                cols\n              );\n              vPoint1 = bounds.top.get(t1);\n              // 找底部对应位置的t值\n              const ratio_bl_br =\n                utils.calcCoordDistance(vertexs.bl, horizontalVanishingPoint) /\n                utils.calcCoordDistance(vertexs.br, horizontalVanishingPoint);\n              const t2 = getT(\n                lengths.left,\n                lengths.left / ratio_bl_br,\n                col,\n                cols\n              );\n              vPoint2 = bounds.bottom.get(t2);\n            }\n\n            // 找横向线条\n            // 找横向线条对应的两个端点\n            let hPoint1 = bounds.left.get(row / rows);\n            let hPoint2 = bounds.right.get(row / rows);\n            if (verticalVanishingPoint) {\n              // 找左侧对应位置的t值\n              const ratio_tl_bl =\n                utils.calcCoordDistance(vertexs.tl, verticalVanishingPoint) /\n                utils.calcCoordDistance(vertexs.bl, verticalVanishingPoint);\n              const t1 = getT(\n                lengths.top,\n                lengths.top / ratio_tl_bl,\n                row,\n                rows\n              );\n              hPoint1 = bounds.left.get(t1);\n              // 找右侧对应位置的t值\n              const ratio_tr_br =\n                utils.calcCoordDistance(vertexs.tr, verticalVanishingPoint) /\n                utils.calcCoordDistance(vertexs.br, verticalVanishingPoint);\n              const t2 = getT(\n                lengths.top,\n                lengths.top / ratio_tr_br,\n                row,\n                rows\n              );\n              hPoint2 = bounds.right.get(t2);\n            }\n\n            // 找两条线条的交点\n            const point = utils.calcIntersection(\n              vPoint1,\n              vPoint2,\n              hPoint1,\n              hPoint2\n            );\n\n            // 平行的情况随便扔一个点进去就好，反正没有绘制效果\n            if (!point) {\n              _col.push(vPoint1);\n            } else {\n              _col.push(point);\n            }\n          }\n        }\n\n        _row.push(_col);\n      });\n      splitPoints.push(_row);\n    });\n\n    return splitPoints;\n  },\n};\n\nexport default strategy;\n"],"names":["SuppressedError","abs","cos","sin","acos","atan2","sqrt","pow","Math","crt","v","pi","PI","tau","quart","nMax","Number","MAX_SAFE_INTEGER","nMin","MIN_SAFE_INTEGER","ZERO","x","y","z","utils","Tvalues","Cvalues","arcfn","t","derivativeFn","d","l","compute","points","_3d","order","length","mt","p","ret","a","b","c","mt2","t2","dCpts","JSON","parse","stringify","i","splice","computeWithRatios","ratios","r","f1","f2","f3","f4","derive","dpoints","list","dpt","j","push","between","m","M","approximately","precision","len","sum","map","ds","de","ts","te","lerp","v1","v2","undefined","pointToString","s","pointsToString","join","copy","obj","angle","o","dx1","dy1","dx2","dy2","round","pos","indexOf","parseFloat","substring","dist","p1","p2","dx","dy","closest","LUT","point","mpos","mdist","forEach","idx","abcratio","n","bottom","projectionratio","top","lli8","x1","y1","x2","y2","x3","y3","x4","y4","lli4","p3","p4","lli","makeline","Bezier","findbbox","sections","mx","my","MX","MY","bbox","min","max","mid","size","shapeintersections","s1","bbox1","s2","bbox2","curveIntersectionThreshold","bboxoverlap","intersections","a1","startcap","forward","back","endcap","a2","l1","virtual","l2","iss","intersects","c1","c2","makeshape","bpl","fpl","start","end","shape","getminmax","curve","concat","get","align","line","tx","ty","roots","aligned","reduce","m1","m2","filter","pa","pb","pc","q","q2","discriminant","u1","mp3","phi","t1","sd","droots","curvature","d1","d2","kOnly","num","dnm","adk","dk","k","dd","qdsum","pk","nk","inflections","slice","v3","trm","sq","b1","b2","dims","dim","expandbox","_bbox","pairiteration","c1b","c2b","threshold","_t1","_t2","cc1","split","cc2","pairs","left","right","pair","results","getccenter","dx1p","dy1p","dx2p","dy2p","mx1","my1","mx2","my2","mx1n","my1n","mx2n","my2n","arc","_","e","numberSort","PolyBezier","constructor","curves","this","valueOf","toString","addCurve","offset","coords","args","Array","from","arguments","coordlen","newargs","higher","Error","step","dimlen","baselength","_linear","_lut","update","quadraticFromPoints","abc","getABC","A","cubicFromPoints","S","B","E","C","selen","lx","ly","bx1","by1","bx2","by2","e1","e2","nc1","nc2","getUtils","toSVG","last","setRatios","verify","print","coordDigest","_print","computedirection","clockwise","derivative","bind","u","um","getLUT","steps","on","error","lut","hits","project","ft","raise","np","pim","dderivative","normal","__normal3","__normal2","r1","r2","q1","R","hull","_p","pt","result","span","extrema","mfn","sort","values","overlaps","lbbox","tbbox","nv","scale","simple","n1","n2","segment","pass1","pass2","translate","distanceFn","ov","rc","outline","d3","d4","fline","bline","ls","le","segments","reduced","fcurves","bcurves","alen","tlen","graduated","linearDistanceFunction","slen","reverse","fs","fe","bs","be","outlineshapes","shapes","lineIntersects","curveintersects","selfintersects","arcs","errorThreshold","_iterate","_error","np1","ref","circles","safety","t_s","t_e","np2","np3","prev_arc","done","curr_good","prev_good","t_m","prev_e","interval","name","execute","warpvas","splitPoints","getT","item","total","regionBoundaryCurves","row","rowIndex","_row","col","colIndex","_col","bounds","vertexs","tl","tr","bl","br","intersectionPoint1","calcIntersection","intersectionPoint2","isInValidPerspective","Object","some","vertex","index","arr","isTriangleContainsPoint","isInvalid","lengths","verticalVanishingPoint","horizontalVanishingPoint","vertical","horizontal","regionCurves","rows","cols","vPoint1","vPoint2","ratio_tl_tr","calcCoordDistance","ratio_bl_br","hPoint1","hPoint2","ratio_tl_bl","ratio_tr_br"],"mappings":"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","x_google_ignoreList":[0,1,2,3]}