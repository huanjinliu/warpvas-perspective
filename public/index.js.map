{"version":3,"file":"index.js","sources":["../node_modules/.pnpm/warpvas@1.0.0/node_modules/warpvas/dist/index.esm.js","../dist/index.esm.js","../src/example/index.ts"],"sourcesContent":["function e(t,e,i,n){return new(i||(i=Promise))((function(r,o){function s(t){try{h(n.next(t))}catch(t){o(t)}}function a(t){try{h(n.throw(t))}catch(t){o(t)}}function h(t){var e;t.done?r(t.value):(e=t.value,e instanceof i?e:new i((function(t){t(e)}))).then(s,a)}h((n=n.apply(t,e||[])).next())}))}\"function\"==typeof SuppressedError&&SuppressedError;const{abs:i,cos:n,sin:r,acos:o,atan2:s,sqrt:a,pow:h}=Math;function c(t){return t<0?-h(-t,1/3):h(t,1/3)}const l=Math.PI,u=2*l,p=l/2,g=Number.MAX_SAFE_INTEGER||9007199254740991,x=Number.MIN_SAFE_INTEGER||-9007199254740991,f={x:0,y:0,z:0},y={Tvalues:[-.06405689286260563,.06405689286260563,-.1911188674736163,.1911188674736163,-.3150426796961634,.3150426796961634,-.4337935076260451,.4337935076260451,-.5454214713888396,.5454214713888396,-.6480936519369755,.6480936519369755,-.7401241915785544,.7401241915785544,-.820001985973903,.820001985973903,-.8864155270044011,.8864155270044011,-.9382745520027328,.9382745520027328,-.9747285559713095,.9747285559713095,-.9951872199970213,.9951872199970213],Cvalues:[.12793819534675216,.12793819534675216,.1258374563468283,.1258374563468283,.12167047292780339,.12167047292780339,.1155056680537256,.1155056680537256,.10744427011596563,.10744427011596563,.09761865210411388,.09761865210411388,.08619016153195327,.08619016153195327,.0733464814110803,.0733464814110803,.05929858491543678,.05929858491543678,.04427743881741981,.04427743881741981,.028531388628933663,.028531388628933663,.0123412297999872,.0123412297999872],arcfn:function(t,e){const i=e(t);let n=i.x*i.x+i.y*i.y;return void 0!==i.z&&(n+=i.z*i.z),a(n)},compute:function(t,e,i){if(0===t)return e[0].t=0,e[0];const n=e.length-1;if(1===t)return e[n].t=1,e[n];const r=1-t;let o=e;if(0===n)return e[0].t=t,e[0];if(1===n){const e={x:r*o[0].x+t*o[1].x,y:r*o[0].y+t*o[1].y,t:t};return i&&(e.z=r*o[0].z+t*o[1].z),e}if(n<4){let e,s,a,h=r*r,c=t*t,l=0;2===n?(o=[o[0],o[1],o[2],f],e=h,s=r*t*2,a=c):3===n&&(e=h*r,s=h*t*3,a=r*c*3,l=t*c);const u={x:e*o[0].x+s*o[1].x+a*o[2].x+l*o[3].x,y:e*o[0].y+s*o[1].y+a*o[2].y+l*o[3].y,t:t};return i&&(u.z=e*o[0].z+s*o[1].z+a*o[2].z+l*o[3].z),u}const s=JSON.parse(JSON.stringify(e));for(;s.length>1;){for(let e=0;e<s.length-1;e++)s[e]={x:s[e].x+(s[e+1].x-s[e].x)*t,y:s[e].y+(s[e+1].y-s[e].y)*t},void 0!==s[e].z&&(s[e].z=s[e].z+(s[e+1].z-s[e].z)*t);s.splice(s.length-1,1)}return s[0].t=t,s[0]},computeWithRatios:function(t,e,i,n){const r=1-t,o=i,s=e;let a,h=o[0],c=o[1],l=o[2],u=o[3];return h*=r,c*=t,2===s.length?(a=h+c,{x:(h*s[0].x+c*s[1].x)/a,y:(h*s[0].y+c*s[1].y)/a,z:!!n&&(h*s[0].z+c*s[1].z)/a,t:t}):(h*=r,c*=2*r,l*=t*t,3===s.length?(a=h+c+l,{x:(h*s[0].x+c*s[1].x+l*s[2].x)/a,y:(h*s[0].y+c*s[1].y+l*s[2].y)/a,z:!!n&&(h*s[0].z+c*s[1].z+l*s[2].z)/a,t:t}):(h*=r,c*=1.5*r,l*=3*r,u*=t*t*t,4===s.length?(a=h+c+l+u,{x:(h*s[0].x+c*s[1].x+l*s[2].x+u*s[3].x)/a,y:(h*s[0].y+c*s[1].y+l*s[2].y+u*s[3].y)/a,z:!!n&&(h*s[0].z+c*s[1].z+l*s[2].z+u*s[3].z)/a,t:t}):void 0))},derive:function(t,e){const i=[];for(let n=t,r=n.length,o=r-1;r>1;r--,o--){const t=[];for(let i,r=0;r<o;r++)i={x:o*(n[r+1].x-n[r].x),y:o*(n[r+1].y-n[r].y)},e&&(i.z=o*(n[r+1].z-n[r].z)),t.push(i);i.push(t),n=t}return i},between:function(t,e,i){return e<=t&&t<=i||y.approximately(t,e)||y.approximately(t,i)},approximately:function(t,e,n){return i(t-e)<=(n||1e-6)},length:function(t){const e=y.Tvalues.length;let i=0;for(let n,r=0;r<e;r++)n=.5*y.Tvalues[r]+.5,i+=y.Cvalues[r]*y.arcfn(n,t);return.5*i},map:function(t,e,i,n,r){return n+(r-n)*((t-e)/(i-e))},lerp:function(t,e,i){const n={x:e.x+t*(i.x-e.x),y:e.y+t*(i.y-e.y)};return void 0!==e.z&&void 0!==i.z&&(n.z=e.z+t*(i.z-e.z)),n},pointToString:function(t){let e=t.x+\"/\"+t.y;return void 0!==t.z&&(e+=\"/\"+t.z),e},pointsToString:function(t){return\"[\"+t.map(y.pointToString).join(\", \")+\"]\"},copy:function(t){return JSON.parse(JSON.stringify(t))},angle:function(t,e,i){const n=e.x-t.x,r=e.y-t.y,o=i.x-t.x,a=i.y-t.y;return s(n*a-r*o,n*o+r*a)},round:function(t,e){const i=\"\"+t,n=i.indexOf(\".\");return parseFloat(i.substring(0,n+1+e))},dist:function(t,e){const i=t.x-e.x,n=t.y-e.y;return a(i*i+n*n)},closest:function(t,e){let i,n,r=h(2,63);return t.forEach((function(t,o){n=y.dist(e,t),n<r&&(r=n,i=o)})),{mdist:r,mpos:i}},abcratio:function(t,e){if(2!==e&&3!==e)return!1;if(void 0===t)t=.5;else if(0===t||1===t)return t;const n=h(t,e)+h(1-t,e);return i((n-1)/n)},projectionratio:function(t,e){if(2!==e&&3!==e)return!1;if(void 0===t)t=.5;else if(0===t||1===t)return t;const i=h(1-t,e);return i/(h(t,e)+i)},lli8:function(t,e,i,n,r,o,s,a){const h=(t-i)*(o-a)-(e-n)*(r-s);return 0!=h&&{x:((t*n-e*i)*(r-s)-(t-i)*(r*a-o*s))/h,y:((t*n-e*i)*(o-a)-(e-n)*(r*a-o*s))/h}},lli4:function(t,e,i,n){const r=t.x,o=t.y,s=e.x,a=e.y,h=i.x,c=i.y,l=n.x,u=n.y;return y.lli8(r,o,s,a,h,c,l,u)},lli:function(t,e){return y.lli4(t,t.c,e,e.c)},makeline:function(t,e){return new T(t.x,t.y,(t.x+e.x)/2,(t.y+e.y)/2,e.x,e.y)},findbbox:function(t){let e=g,i=g,n=x,r=x;return t.forEach((function(t){const o=t.bbox();e>o.x.min&&(e=o.x.min),i>o.y.min&&(i=o.y.min),n<o.x.max&&(n=o.x.max),r<o.y.max&&(r=o.y.max)})),{x:{min:e,mid:(e+n)/2,max:n,size:n-e},y:{min:i,mid:(i+r)/2,max:r,size:r-i}}},shapeintersections:function(t,e,i,n,r){if(!y.bboxoverlap(e,n))return[];const o=[],s=[t.startcap,t.forward,t.back,t.endcap],a=[i.startcap,i.forward,i.back,i.endcap];return s.forEach((function(e){e.virtual||a.forEach((function(n){if(n.virtual)return;const s=e.intersects(n,r);s.length>0&&(s.c1=e,s.c2=n,s.s1=t,s.s2=i,o.push(s))}))})),o},makeshape:function(t,e,i){const n=e.points.length,r=t.points.length,o=y.makeline(e.points[n-1],t.points[0]),s=y.makeline(t.points[r-1],e.points[0]),a={startcap:o,forward:t,back:e,endcap:s,bbox:y.findbbox([o,t,e,s]),intersections:function(t){return y.shapeintersections(a,a.bbox,t,t.bbox,i)}};return a},getminmax:function(t,e,i){if(!i)return{min:0,max:0};let n,r,o=g,s=x;-1===i.indexOf(0)&&(i=[0].concat(i)),-1===i.indexOf(1)&&i.push(1);for(let a=0,h=i.length;a<h;a++)n=i[a],r=t.get(n),r[e]<o&&(o=r[e]),r[e]>s&&(s=r[e]);return{min:o,mid:(o+s)/2,max:s,size:s-o}},align:function(t,e){const i=e.p1.x,o=e.p1.y,a=-s(e.p2.y-o,e.p2.x-i);return t.map((function(t){return{x:(t.x-i)*n(a)-(t.y-o)*r(a),y:(t.x-i)*r(a)+(t.y-o)*n(a)}}))},roots:function(t,e){e=e||{p1:{x:0,y:0},p2:{x:1,y:0}};const i=t.length-1,r=y.align(t,e),s=function(t){return 0<=t&&t<=1};if(2===i){const t=r[0].y,e=r[1].y,i=r[2].y,n=t-2*e+i;if(0!==n){const r=-a(e*e-t*i),o=-t+e;return[-(r+o)/n,-(-r+o)/n].filter(s)}return e!==i&&0===n?[(2*e-i)/(2*e-2*i)].filter(s):[]}const h=r[0].y,l=r[1].y,p=r[2].y;let g=3*l-h-3*p+r[3].y,x=3*h-6*l+3*p,f=-3*h+3*l,d=h;if(y.approximately(g,0)){if(y.approximately(x,0))return y.approximately(f,0)?[]:[-d/f].filter(s);const t=a(f*f-4*x*d),e=2*x;return[(t-f)/e,(-f-t)/e].filter(s)}x/=g,f/=g,d/=g;const m=(3*f-x*x)/3,v=m/3,_=(2*x*x*x-9*x*f+27*d)/27,b=_/2,E=b*b+v*v*v;let w,C,z,T,R;if(E<0){const t=-m/3,e=a(t*t*t),i=-_/(2*e),r=o(i<-1?-1:i>1?1:i),h=2*c(e);return z=h*n(r/3)-x/3,T=h*n((r+u)/3)-x/3,R=h*n((r+2*u)/3)-x/3,[z,T,R].filter(s)}if(0===E)return w=b<0?c(-b):-c(b),z=2*w-x/3,T=-w-x/3,[z,T].filter(s);{const t=a(E);return w=c(-b+t),C=c(b+t),[w-C-x/3].filter(s)}},droots:function(t){if(3===t.length){const e=t[0],i=t[1],n=t[2],r=e-2*i+n;if(0!==r){const t=-a(i*i-e*n),o=-e+i;return[-(t+o)/r,-(-t+o)/r]}return i!==n&&0===r?[(2*i-n)/(2*(i-n))]:[]}if(2===t.length){const e=t[0],i=t[1];return e!==i?[e/(e-i)]:[]}return[]},curvature:function(t,e,n,r,o){let s,c,l,u,p=0,g=0;const x=y.compute(t,e),f=y.compute(t,n),d=x.x*x.x+x.y*x.y;if(r?(s=a(h(x.y*f.z-f.y*x.z,2)+h(x.z*f.x-f.z*x.x,2)+h(x.x*f.y-f.x*x.y,2)),c=h(d+x.z*x.z,1.5)):(s=x.x*f.y-x.y*f.x,c=h(d,1.5)),0===s||0===c)return{k:0,r:0};if(p=s/c,g=c/s,!o){const o=y.curvature(t-.001,e,n,r,!0).k,s=y.curvature(t+.001,e,n,r,!0).k;u=(s-p+(p-o))/2,l=(i(s-p)+i(p-o))/2}return{k:p,r:g,dk:u,adk:l}},inflections:function(t){if(t.length<4)return[];const e=y.align(t,{p1:t[0],p2:t.slice(-1)[0]}),i=e[2].x*e[1].y,n=e[3].x*e[1].y,r=e[1].x*e[2].y,o=18*(-3*i+2*n+3*r-e[3].x*e[2].y),s=18*(3*i-n-3*r),a=18*(r-i);if(y.approximately(o,0)){if(!y.approximately(s,0)){let t=-a/s;if(0<=t&&t<=1)return[t]}return[]}const h=2*o;if(y.approximately(h,0))return[];const c=s*s-4*o*a;if(c<0)return[];const l=Math.sqrt(c);return[(l-s)/h,-(s+l)/h].filter((function(t){return 0<=t&&t<=1}))},bboxoverlap:function(t,e){const n=[\"x\",\"y\"],r=n.length;for(let o,s,a,h,c=0;c<r;c++)if(o=n[c],s=t[o].mid,a=e[o].mid,h=(t[o].size+e[o].size)/2,i(s-a)>=h)return!1;return!0},expandbox:function(t,e){e.x.min<t.x.min&&(t.x.min=e.x.min),e.y.min<t.y.min&&(t.y.min=e.y.min),e.z&&e.z.min<t.z.min&&(t.z.min=e.z.min),e.x.max>t.x.max&&(t.x.max=e.x.max),e.y.max>t.y.max&&(t.y.max=e.y.max),e.z&&e.z.max>t.z.max&&(t.z.max=e.z.max),t.x.mid=(t.x.min+t.x.max)/2,t.y.mid=(t.y.min+t.y.max)/2,t.z&&(t.z.mid=(t.z.min+t.z.max)/2),t.x.size=t.x.max-t.x.min,t.y.size=t.y.max-t.y.min,t.z&&(t.z.size=t.z.max-t.z.min)},pairiteration:function(t,e,i){const n=t.bbox(),r=e.bbox(),o=1e5,s=i||.5;if(n.x.size+n.y.size<s&&r.x.size+r.y.size<s)return[(o*(t._t1+t._t2)/2|0)/o+\"/\"+(o*(e._t1+e._t2)/2|0)/o];let a=t.split(.5),h=e.split(.5),c=[{left:a.left,right:h.left},{left:a.left,right:h.right},{left:a.right,right:h.right},{left:a.right,right:h.left}];c=c.filter((function(t){return y.bboxoverlap(t.left.bbox(),t.right.bbox())}));let l=[];return 0===c.length||(c.forEach((function(t){l=l.concat(y.pairiteration(t.left,t.right,s))})),l=l.filter((function(t,e){return l.indexOf(t)===e}))),l},getccenter:function(t,e,i){const o=e.x-t.x,a=e.y-t.y,h=i.x-e.x,c=i.y-e.y,l=o*n(p)-a*r(p),g=o*r(p)+a*n(p),x=h*n(p)-c*r(p),f=h*r(p)+c*n(p),d=(t.x+e.x)/2,m=(t.y+e.y)/2,v=(e.x+i.x)/2,_=(e.y+i.y)/2,b=d+l,E=m+g,w=v+x,C=_+f,z=y.lli8(d,m,b,E,v,_,w,C),T=y.dist(z,t);let R,S=s(t.y-z.y,t.x-z.x),P=s(e.y-z.y,e.x-z.x),M=s(i.y-z.y,i.x-z.x);return S<M?((S>P||P>M)&&(S+=u),S>M&&(R=M,M=S,S=R)):M<P&&P<S?(R=M,M=S,S=R):M+=u,z.s=S,z.e=M,z.r=T,z},numberSort:function(t,e){return t-e}};class d{constructor(t){this.curves=[],this._3d=!1,t&&(this.curves=t,this._3d=this.curves[0]._3d)}valueOf(){return this.toString()}toString(){return\"[\"+this.curves.map((function(t){return y.pointsToString(t.points)})).join(\", \")+\"]\"}addCurve(t){this.curves.push(t),this._3d=this._3d||t._3d}length(){return this.curves.map((function(t){return t.length()})).reduce((function(t,e){return t+e}))}curve(t){return this.curves[t]}bbox(){const t=this.curves;for(var e=t[0].bbox(),i=1;i<t.length;i++)y.expandbox(e,t[i].bbox());return e}offset(t){const e=[];return this.curves.forEach((function(i){e.push(...i.offset(t))})),new d(e)}}const{abs:m,min:v,max:_,cos:b,sin:E,acos:w,sqrt:C}=Math,z=Math.PI;class T{constructor(t){let e=t&&t.forEach?t:Array.from(arguments).slice(),i=!1;if(\"object\"==typeof e[0]){i=e.length;const t=[];e.forEach((function(e){[\"x\",\"y\",\"z\"].forEach((function(i){void 0!==e[i]&&t.push(e[i])}))})),e=t}let n=!1;const r=e.length;if(i){if(i>4){if(1!==arguments.length)throw new Error(\"Only new Bezier(point[]) is accepted for 4th and higher order curves\");n=!0}}else if(6!==r&&8!==r&&9!==r&&12!==r&&1!==arguments.length)throw new Error(\"Only new Bezier(point[]) is accepted for 4th and higher order curves\");const o=this._3d=!n&&(9===r||12===r)||t&&t[0]&&void 0!==t[0].z,s=this.points=[];for(let t=0,i=o?3:2;t<r;t+=i){var a={x:e[t],y:e[t+1]};o&&(a.z=e[t+2]),s.push(a)}const h=this.order=s.length-1,c=this.dims=[\"x\",\"y\"];o&&c.push(\"z\"),this.dimlen=c.length;const l=y.align(s,{p1:s[0],p2:s[h]}),u=y.dist(s[0],s[h]);this._linear=l.reduce(((t,e)=>t+m(e.y)),0)<u/50,this._lut=[],this._t1=0,this._t2=1,this.update()}static quadraticFromPoints(t,e,i,n){if(void 0===n&&(n=.5),0===n)return new T(e,e,i);if(1===n)return new T(t,e,e);const r=T.getABC(2,t,e,i,n);return new T(t,r.A,i)}static cubicFromPoints(t,e,i,n,r){void 0===n&&(n=.5);const o=T.getABC(3,t,e,i,n);void 0===r&&(r=y.dist(e,o.C));const s=r*(1-n)/n,a=y.dist(t,i),h=(i.x-t.x)/a,c=(i.y-t.y)/a,l=r*h,u=r*c,p=s*h,g=s*c,x=e.x-l,f=e.y-u,d=e.x+p,m=e.y+g,v=o.A,_=v.x+(x-v.x)/(1-n),b=v.y+(f-v.y)/(1-n),E=v.x+(d-v.x)/n,w=v.y+(m-v.y)/n,C={x:t.x+(_-t.x)/n,y:t.y+(b-t.y)/n},z={x:i.x+(E-i.x)/(1-n),y:i.y+(w-i.y)/(1-n)};return new T(t,C,z,i)}static getUtils(){return y}getUtils(){return T.getUtils()}static get PolyBezier(){return d}valueOf(){return this.toString()}toString(){return y.pointsToString(this.points)}toSVG(){if(this._3d)return!1;const t=this.points,e=[\"M\",t[0].x,t[0].y,2===this.order?\"Q\":\"C\"];for(let i=1,n=t.length;i<n;i++)e.push(t[i].x),e.push(t[i].y);return e.join(\" \")}setRatios(t){if(t.length!==this.points.length)throw new Error(\"incorrect number of ratio values\");this.ratios=t,this._lut=[]}verify(){const t=this.coordDigest();t!==this._print&&(this._print=t,this.update())}coordDigest(){return this.points.map((function(t,e){return\"\"+e+t.x+t.y+(t.z?t.z:0)})).join(\"\")}update(){this._lut=[],this.dpoints=y.derive(this.points,this._3d),this.computedirection()}computedirection(){const t=this.points,e=y.angle(t[0],t[this.order],t[1]);this.clockwise=e>0}length(){return y.length(this.derivative.bind(this))}static getABC(t=2,e,i,n,r=.5){const o=y.projectionratio(r,t),s=1-o,a={x:o*e.x+s*n.x,y:o*e.y+s*n.y},h=y.abcratio(r,t);return{A:{x:i.x+(i.x-a.x)/h,y:i.y+(i.y-a.y)/h},B:i,C:a,S:e,E:n}}getABC(t,e){e=e||this.get(t);let i=this.points[0],n=this.points[this.order];return T.getABC(this.order,i,e,n,t)}getLUT(t){if(this.verify(),t=t||100,this._lut.length===t+1)return this._lut;this._lut=[],t++,this._lut=[];for(let e,i,n=0;n<t;n++)i=n/(t-1),e=this.compute(i),e.t=i,this._lut.push(e);return this._lut}on(e,i){i=i||5;const n=this.getLUT(),r=[];for(let t,o=0,s=0;o<n.length;o++)t=n[o],y.dist(t,e)<i&&(r.push(t),s+=o/n.length);return!!r.length&&(t/=r.length)}project(t){const e=this.getLUT(),i=e.length-1,n=y.closest(e,t),r=n.mpos,o=(r-1)/i,s=(r+1)/i,a=.1/i;let h,c=n.mdist,l=o,u=l;c+=1;for(let e;l<s+a;l+=a)h=this.compute(l),e=y.dist(t,h),e<c&&(c=e,u=l);return u=u<0?0:u>1?1:u,h=this.compute(u),h.t=u,h.d=c,h}get(t){return this.compute(t)}point(t){return this.points[t]}compute(t){return this.ratios?y.computeWithRatios(t,this.points,this.ratios,this._3d):y.compute(t,this.points,this._3d,this.ratios)}raise(){const t=this.points,e=[t[0]],i=t.length;for(let n,r,o=1;o<i;o++)n=t[o],r=t[o-1],e[o]={x:(i-o)/i*n.x+o/i*r.x,y:(i-o)/i*n.y+o/i*r.y};return e[i]=t[i-1],new T(e)}derivative(t){return y.compute(t,this.dpoints[0],this._3d)}dderivative(t){return y.compute(t,this.dpoints[1],this._3d)}align(){let t=this.points;return new T(y.align(t,{p1:t[0],p2:t[t.length-1]}))}curvature(t){return y.curvature(t,this.dpoints[0],this.dpoints[1],this._3d)}inflections(){return y.inflections(this.points)}normal(t){return this._3d?this.__normal3(t):this.__normal2(t)}__normal2(t){const e=this.derivative(t),i=C(e.x*e.x+e.y*e.y);return{t:t,x:-e.y/i,y:e.x/i}}__normal3(t){const e=this.derivative(t),i=this.derivative(t+.01),n=C(e.x*e.x+e.y*e.y+e.z*e.z),r=C(i.x*i.x+i.y*i.y+i.z*i.z);e.x/=n,e.y/=n,e.z/=n,i.x/=r,i.y/=r,i.z/=r;const o={x:i.y*e.z-i.z*e.y,y:i.z*e.x-i.x*e.z,z:i.x*e.y-i.y*e.x},s=C(o.x*o.x+o.y*o.y+o.z*o.z);o.x/=s,o.y/=s,o.z/=s;const a=[o.x*o.x,o.x*o.y-o.z,o.x*o.z+o.y,o.x*o.y+o.z,o.y*o.y,o.y*o.z-o.x,o.x*o.z-o.y,o.y*o.z+o.x,o.z*o.z];return{t:t,x:a[0]*e.x+a[1]*e.y+a[2]*e.z,y:a[3]*e.x+a[4]*e.y+a[5]*e.z,z:a[6]*e.x+a[7]*e.y+a[8]*e.z}}hull(t){let e=this.points,i=[],n=[],r=0;for(n[r++]=e[0],n[r++]=e[1],n[r++]=e[2],3===this.order&&(n[r++]=e[3]);e.length>1;){i=[];for(let o,s=0,a=e.length-1;s<a;s++)o=y.lerp(t,e[s],e[s+1]),n[r++]=o,i.push(o);e=i}return n}split(t,e){if(0===t&&e)return this.split(e).left;if(1===e)return this.split(t).right;const i=this.hull(t),n={left:2===this.order?new T([i[0],i[3],i[5]]):new T([i[0],i[4],i[7],i[9]]),right:2===this.order?new T([i[5],i[4],i[2]]):new T([i[9],i[8],i[6],i[3]]),span:i};return n.left._t1=y.map(0,0,1,this._t1,this._t2),n.left._t2=y.map(t,0,1,this._t1,this._t2),n.right._t1=y.map(t,0,1,this._t1,this._t2),n.right._t2=y.map(1,0,1,this._t1,this._t2),e?(e=y.map(e,t,1,0,1),n.right.split(e).left):n}extrema(){const t={};let e=[];return this.dims.forEach(function(i){let n=function(t){return t[i]},r=this.dpoints[0].map(n);t[i]=y.droots(r),3===this.order&&(r=this.dpoints[1].map(n),t[i]=t[i].concat(y.droots(r))),t[i]=t[i].filter((function(t){return t>=0&&t<=1})),e=e.concat(t[i].sort(y.numberSort))}.bind(this)),t.values=e.sort(y.numberSort).filter((function(t,i){return e.indexOf(t)===i})),t}bbox(){const t=this.extrema(),e={};return this.dims.forEach(function(i){e[i]=y.getminmax(this,i,t[i])}.bind(this)),e}overlaps(t){const e=this.bbox(),i=t.bbox();return y.bboxoverlap(e,i)}offset(t,e){if(void 0!==e){const i=this.get(t),n=this.normal(t),r={c:i,n:n,x:i.x+n.x*e,y:i.y+n.y*e};return this._3d&&(r.z=i.z+n.z*e),r}if(this._linear){const e=this.normal(0),i=this.points.map((function(i){const n={x:i.x+t*e.x,y:i.y+t*e.y};return i.z&&e.z&&(n.z=i.z+t*e.z),n}));return[new T(i)]}return this.reduce().map((function(e){return e._linear?e.offset(t)[0]:e.scale(t)}))}simple(){if(3===this.order){const t=y.angle(this.points[0],this.points[3],this.points[1]),e=y.angle(this.points[0],this.points[3],this.points[2]);if(t>0&&e<0||t<0&&e>0)return!1}const t=this.normal(0),e=this.normal(1);let i=t.x*e.x+t.y*e.y;return this._3d&&(i+=t.z*e.z),m(w(i))<z/3}reduce(){let t,e,i=0,n=0,r=.01,o=[],s=[],a=this.extrema().values;for(-1===a.indexOf(0)&&(a=[0].concat(a)),-1===a.indexOf(1)&&a.push(1),i=a[0],t=1;t<a.length;t++)n=a[t],e=this.split(i,n),e._t1=i,e._t2=n,o.push(e),i=n;return o.forEach((function(t){for(i=0,n=0;n<=1;)for(n=i+r;n<=1.01;n+=r)if(e=t.split(i,n),!e.simple()){if(n-=r,m(i-n)<r)return[];e=t.split(i,n),e._t1=y.map(i,0,1,t._t1,t._t2),e._t2=y.map(n,0,1,t._t1,t._t2),s.push(e),i=n;break}i<1&&(e=t.split(i,1),e._t1=y.map(i,0,1,t._t1,t._t2),e._t2=t._t2,s.push(e))})),s}translate(t,e,i){i=\"number\"==typeof i?i:e;const n=this.order;let r=this.points.map(((t,r)=>(1-r/n)*e+r/n*i));return new T(this.points.map(((e,i)=>({x:e.x+t.x*r[i],y:e.y+t.y*r[i]}))))}scale(t){const e=this.order;let i=!1;if(\"function\"==typeof t&&(i=t),i&&2===e)return this.raise().scale(i);const n=this.clockwise,r=this.points;if(this._linear)return this.translate(this.normal(0),i?i(0):t,i?i(1):t);const o=i?i(0):t,s=i?i(1):t,a=[this.offset(0,10),this.offset(1,10)],h=[],c=y.lli4(a[0],a[0].c,a[1],a[1].c);if(!c)throw new Error(\"cannot scale this curve. Try reducing it first.\");return[0,1].forEach((function(t){const i=h[t*e]=y.copy(r[t*e]);i.x+=(t?s:o)*a[t].n.x,i.y+=(t?s:o)*a[t].n.y})),i?([0,1].forEach((function(o){if(2!==e||!o){var s=r[o+1],a={x:s.x-c.x,y:s.y-c.y},l=i?i((o+1)/e):t;i&&!n&&(l=-l);var u=C(a.x*a.x+a.y*a.y);a.x/=u,a.y/=u,h[o+1]={x:s.x+l*a.x,y:s.y+l*a.y}}})),new T(h)):([0,1].forEach((t=>{if(2===e&&t)return;const i=h[t*e],n=this.derivative(t),o={x:i.x+n.x,y:i.y+n.y};h[t+1]=y.lli4(i,o,c,r[t+1])})),new T(h))}outline(t,e,i,n){if(e=void 0===e?t:e,this._linear){const r=this.normal(0),o=this.points[0],s=this.points[this.points.length-1];let a,h,c;void 0===i&&(i=t,n=e),a={x:o.x+r.x*t,y:o.y+r.y*t},c={x:s.x+r.x*i,y:s.y+r.y*i},h={x:(a.x+c.x)/2,y:(a.y+c.y)/2};const l=[a,h,c];a={x:o.x-r.x*e,y:o.y-r.y*e},c={x:s.x-r.x*n,y:s.y-r.y*n},h={x:(a.x+c.x)/2,y:(a.y+c.y)/2};const u=[c,h,a],p=y.makeline(u[2],l[0]),g=y.makeline(l[2],u[0]),x=[p,new T(l),g,new T(u)];return new d(x)}const r=this.reduce(),o=r.length,s=[];let a,h=[],c=0,l=this.length();const u=void 0!==i&&void 0!==n;function p(t,e,i,n,r){return function(o){const s=n/i,a=(n+r)/i,h=e-t;return y.map(o,0,1,t+s*h,t+a*h)}}r.forEach((function(r){const o=r.length();u?(s.push(r.scale(p(t,i,l,c,o))),h.push(r.scale(p(-e,-n,l,c,o)))):(s.push(r.scale(t)),h.push(r.scale(-e))),c+=o})),h=h.map((function(t){return a=t.points,a[3]?t.points=[a[3],a[2],a[1],a[0]]:t.points=[a[2],a[1],a[0]],t})).reverse();const g=s[0].points[0],x=s[o-1].points[s[o-1].points.length-1],f=h[o-1].points[h[o-1].points.length-1],m=h[0].points[0],v=y.makeline(f,g),_=y.makeline(x,m),b=[v].concat(s).concat([_]).concat(h);return new d(b)}outlineshapes(t,e,i){e=e||t;const n=this.outline(t,e).curves,r=[];for(let t=1,e=n.length;t<e/2;t++){const o=y.makeshape(n[t],n[e-t],i);o.startcap.virtual=t>1,o.endcap.virtual=t<e/2-1,r.push(o)}return r}intersects(t,e){return t?t.p1&&t.p2?this.lineIntersects(t):(t instanceof T&&(t=t.reduce()),this.curveintersects(this.reduce(),t,e)):this.selfintersects(e)}lineIntersects(t){const e=v(t.p1.x,t.p2.x),i=v(t.p1.y,t.p2.y),n=_(t.p1.x,t.p2.x),r=_(t.p1.y,t.p2.y);return y.roots(this.points,t).filter((t=>{var o=this.get(t);return y.between(o.x,e,n)&&y.between(o.y,i,r)}))}selfintersects(t){const e=this.reduce(),i=e.length-2,n=[];for(let r,o,s,a=0;a<i;a++)o=e.slice(a,a+1),s=e.slice(a+2),r=this.curveintersects(o,s,t),n.push(...r);return n}curveintersects(t,e,i){const n=[];t.forEach((function(t){e.forEach((function(e){t.overlaps(e)&&n.push({left:t,right:e})}))}));let r=[];return n.forEach((function(t){const e=y.pairiteration(t.left,t.right,i);e.length>0&&(r=r.concat(e))})),r}arcs(t){return t=t||.5,this._iterate(t,[])}_error(t,e,i,n){const r=(n-i)/4,o=this.get(i+r),s=this.get(n-r),a=y.dist(t,e),h=y.dist(t,o),c=y.dist(t,s);return m(h-a)+m(c-a)}_iterate(t,e){let i,n=0,r=1;do{i=0,r=1;let o,s,a,h,c,l=this.get(n),u=!1,p=!1,g=r,x=1;do{if(p=u,h=a,g=(n+r)/2,o=this.get(g),s=this.get(r),a=y.getccenter(l,o,s),a.interval={start:n,end:r},u=this._error(a,l,n,r)<=t,c=p&&!u,c||(x=r),u){if(r>=1){if(a.interval.end=x=1,h=a,r>1){let t={x:a.x+a.r*b(a.e),y:a.y+a.r*E(a.e)};a.e+=y.angle({x:a.x,y:a.y},t,this.get(1))}break}r+=(r-n)/2}else r=g}while(!c&&i++<100);if(i>=100)break;h=h||a,e.push(h),n=x}while(r<1);return e}}const R=(t,e,i)=>{if(t.x===e.x)return{x:t.x,y:i.y};if(t.y===e.y)return{x:i.x,y:t.y};const n=(e.y-t.y)/(e.x-t.x),r=-1/n,o=(-n*t.x+t.y+r*i.x-i.y)/(r-n);return{x:o,y:n*(o-t.x)+t.y}},S=(t,e)=>Math.sqrt(Math.pow(e.x-t.x,2)+Math.pow(e.y-t.y,2)),P=(t,e,i)=>{const n=Math.min(t.x,e.x,i.x),r=Math.max(t.x,e.x,i.x),o=Math.min(t.y,e.y,i.y);return{width:r-n,height:Math.max(t.y,e.y,i.y)-o}},M=(t,e,i)=>{const n=Object.assign({},t),r={x:e.x-t.x,y:e.y-t.y};if(0===r.x&&0===r.y)return n;if(0===r.x)n.y+=i*Math.sign(r.y);else if(0===r.y)n.x+=i*Math.sign(r.x);else{const t=Math.sqrt(Math.pow(r.x,2)+Math.pow(r.y,2));n.x+=r.x*(i/t),n.y+=r.y*(i/t)}return n},O=(t,e)=>{const[i,n,r]=t,[o,s,a]=e,h=.1/Math.abs([...t,...e].reduce(((t,e)=>Math.min(t,e.x,e.y)),-1)),c=(t,e,i)=>{const[n,r,o,s]=t.map(Number),[a,h,c,l]=e.map(Number),[u,p,g,x]=i.map(Number),f=o-r*c/h,y=c-h*g/p,d=l-h*x/p,m=a-h*u/p,v=(f/y*d-(s-r*l/h))/(f/y*m-(n-r*a/h)),_=(d-m*v)/y;return{x:v,y:(s-n*v-o*_)/r,z:_}},l=[o.x+h,o.y+h,1,i.x+h],u=[s.x+h,s.y+h,1,n.x+h],p=[a.x+h,a.y+h,1,r.x+h],g=c(l,u,p);l[3]=i.y+h,u[3]=n.y+h,p[3]=r.y+h;const x=c(l,u,p),f=g.x,y=g.y,d=g.z;return[f,x.x,y,x.y,d,x.z]},B=(t,e,i,n,r=.1)=>{const o=(t,e,i)=>Math.abs(t.x*(e.y-i.y)+e.x*(i.y-t.y)+i.x*(t.y-e.y))/2,s=o(e,i,n);return o(e,i,t)+o(i,n,t)+o(n,e,t)<=s+r};var I=Object.freeze({__proto__:null,calcBoundingBox:P,calcCoordDistance:S,calcExpandCoord:(t,e,i,n=1)=>{const r=R(e,i,t),o=S(t,r),s=M(t,r,o+n);return{x:s.x-r.x+e.x,y:s.y-r.y+e.y}},calcIntersection:(t,e,i,n)=>{const r=(t,e)=>Math.abs(t-e)<Math.pow(.1,12);if(r(t.x,e.x)&&r(i.x,n.x))return null;if(r(t.y,e.y)&&r(i.y,n.y))return null;const o=1e4*(e.y-t.y)/Math.round(1e4*(e.x-t.x)),s=1e4*(n.y-i.y)/Math.round(1e4*(n.x-i.x)),a=t.y-o*t.x,h=i.y-s*i.x;if(Math.abs(o)===1/0)return{x:t.x,y:s*t.x+h};if(Math.abs(s)===1/0)return{x:i.x,y:o*i.x+a};const c=(h-a)/(o-s);return{x:c,y:o*c+a}},calcMatrix:O,calcPerpendicularIntersection:R,calcRelativeCoord:M,isTriangleContainsPoint:B});const A=(t,e,i,n,r)=>{var o;const{x:s,y:a,sourceScale:h=1,destinationScale:c=1}=n,{gridColor:l={r:255,g:0,b:0,a:1},enableContentDisplay:u=!0,enableGridDisplay:p=!1,enableGridVertexDisplay:g=!1}=null!==(o=t.renderingConfig)&&void 0!==o?o:{},{calcBoundingBox:x,calcPerpendicularIntersection:f,calcCoordDistance:y,calcRelativeCoord:d,calcMatrix:m}=r,v=(t,e,i,n=1)=>{const r=f(e,i,t),o=y(t,r),s=d(t,r,o+n);return{x:s.x-r.x+e.x,y:s.y-r.y+e.y}},_=i.getContext(\"2d\");_.clearRect(0,0,i.width,i.height);const b=Math.ceil(1/(h*c));_.save(),_.transform(h*c,0,0,h*c,s*h*c,a*h*c);const E=(t,i,n,r,o,s,a)=>{const c=[t,n,o],f=new Path2D;for(let t=0;t<3;t++){const e=c[t],i=c[(t+1)%3],n=c[(t+2)%3],r=v(e,i,n,b),o=v(e,n,i,b);f.lineTo(r.x,r.y),f.lineTo(o.x,o.y)}if(u){_.save(),_.clip(f);const c=m([t,n,o],[i,r,s]);_.transform(...c);const l=x(i,r,s),u=(a.x-1)*h,p=(a.y-1)*h,g=(l.width+2)*h,y=(l.height+2)*h,d=a.x-1/h,v=a.y-1/h,b=l.width+2/h,E=l.height+2/h;_.drawImage(e,u,p,g,y,d,v,b,E),_.restore()}if(g){const e=Math.floor(2/h);_.fillStyle=`rgba(${l.r}, ${l.g}, ${l.b}, ${l.a})`,_.fillRect(t.x-e/2,t.y-e/2,e,e)}if(p){const t=Math.floor(1/h);_.lineWidth=t,_.strokeStyle=\"rgba(255, 0, 0, 0.5)\",_.stroke(f)}};return t.regionPoints.forEach(((e,i)=>{e.forEach(((e,n)=>{const r=e,o=t.regionCurves[i][n].vertical.length-1;r.forEach(((e,s)=>{const a=r[s],h=r[s+1],c=r[s+o+2],l=r[s+o+1],u=t.originalRegionPoints[i][n][s],p=t.originalRegionPoints[i][n][s+1],g=t.originalRegionPoints[i][n][s+o+2],x=t.originalRegionPoints[i][n][s+o+1];h&&c&&s%(o+1)<o&&(E(a,u,h,p,l,x,u),E(c,g,h,p,l,x,u))}))}))})),_.restore(),i},L=(t,e,i,n)=>{const{width:r,height:o,sourceScale:s=1,destinationScale:a=1}=n;(i=null!=i?i:document.createElement(\"canvas\")).width=r*a*s,i.height=o*a*s;return A(t,e,i,n,{calcBoundingBox:P,calcPerpendicularIntersection:R,calcCoordDistance:S,calcRelativeCoord:M,calcMatrix:O})},F=(t,e,i,n)=>{var r;const{x:o,y:s,width:a,height:h,sourceScale:c=1}=n,{enableAntialias:l=!0,gridColor:u={r:255,g:0,b:0,a:1},enableContentDisplay:p=!0,enableGridDisplay:g=!1,enableGridVertexDisplay:x=!1}=null!==(r=t.renderingConfig)&&void 0!==r?r:{},{width:f,height:y}=e,d=i.getContext(\"webgl\",{antialias:l});if(!d)throw Error(\"[Warpvas] Failed to initialize WebGL. Your browser or device may not support it.\");const m={before:[],after:[]};t.regionPoints.forEach(((e,i)=>{e.forEach(((e,n)=>{const r=e,o=t.regionCurves[i][n].vertical.length-1;r.forEach(((e,s)=>{const a=r[s],h=r[s+1],c=r[s+o+2],l=r[s+o+1],u=t.originalRegionPoints[i][n][s],p=t.originalRegionPoints[i][n][s+1],g=t.originalRegionPoints[i][n][s+o+2],x=t.originalRegionPoints[i][n][s+o+1];h&&c&&s%(o+1)<o&&(m.before.push(u,p,x,g,p,x),m.after.push(a,h,l,c,h,l))}))}))}));const v=\"\\n      attribute vec4 aVertexPosition;\\n      attribute vec2 aTextureCoord;\\n      varying highp vec2 vTextureCoord;\\n      void main(void) {\\n          gl_Position = aVertexPosition;\\n          gl_PointSize = 2.0;\\n          vTextureCoord = aTextureCoord;\\n      }\\n  \",_=(t,e)=>{const i=d.createShader(t);return i?(d.shaderSource(i,e),d.compileShader(i),d.getShaderParameter(i,d.COMPILE_STATUS)?i:(console.error(\"[Warpvas] Shader compilation error:\",d.getShaderInfoLog(i)),d.deleteShader(i),null)):(console.error(\"[Warpvas] Failed to create shader.\"),null)},b=(t,e)=>{const i=_(d.VERTEX_SHADER,t);if(!i)return console.error(\"[Warpvas] Failed to initialize vertex shader.\"),null;const n=_(d.FRAGMENT_SHADER,e);if(!n)return console.error(\"[Warpvas] Failed to initialize fragment shader.\"),null;const r=d.createProgram();return r?(d.attachShader(r,i),d.attachShader(r,n),d.linkProgram(r),d.getProgramParameter(r,d.LINK_STATUS)?r:(console.error(\"[Warpvas] Shader program linking error:\",d.getProgramInfoLog(r)),null)):(console.error(\"[Warpvas] Failed to create shader program.\"),null)},E=t=>!(t&t-1),w=b(v,\"\\n      varying highp vec2 vTextureCoord;\\n      uniform sampler2D uSampler;\\n      void main(void) {\\n          gl_FragColor = texture2D(uSampler, vTextureCoord);\\n      }\\n  \");if(!w)throw Error(\"[Warpvas] Failed to initialize shader program.\");const C={program:w,attribLocations:{vertexPosition:d.getAttribLocation(w,\"aVertexPosition\"),textureCoord:d.getAttribLocation(w,\"aTextureCoord\")},uniformLocations:{uSampler:d.getUniformLocation(w,\"uSampler\")}},z=d.createTexture();if(!z)throw Error(\"[Warpvas] Failed to create WebGL texture object.\");d.bindTexture(d.TEXTURE_2D,z),d.texImage2D(d.TEXTURE_2D,0,d.RGBA,d.RGBA,d.UNSIGNED_BYTE,e),E(e.width)&&E(e.height)&&d.generateMipmap(d.TEXTURE_2D),d.enable(d.BLEND),d.blendFunc(d.SRC_ALPHA,d.ONE_MINUS_SRC_ALPHA),d.texParameteri(d.TEXTURE_2D,d.TEXTURE_WRAP_S,d.CLAMP_TO_EDGE),d.texParameteri(d.TEXTURE_2D,d.TEXTURE_WRAP_T,d.CLAMP_TO_EDGE),d.texParameteri(d.TEXTURE_2D,d.TEXTURE_MIN_FILTER,d.LINEAR),d.viewport(0,0,i.width,i.height);return((t,e,i)=>{d.clearColor(0,0,0,0),d.clear(d.COLOR_BUFFER_BIT);const n=d.FLOAT,r=!1,o=4*Float32Array.BYTES_PER_ELEMENT;d.bindBuffer(d.ARRAY_BUFFER,e.position),d.vertexAttribPointer(t.attribLocations.vertexPosition,2,n,r,o,0),d.enableVertexAttribArray(t.attribLocations.vertexPosition),d.bindBuffer(d.ARRAY_BUFFER,e.textureCoord),d.vertexAttribPointer(t.attribLocations.textureCoord,2,n,r,o,0),d.enableVertexAttribArray(t.attribLocations.textureCoord),d.useProgram(t.program),d.activeTexture(d.TEXTURE0),d.bindTexture(d.TEXTURE_2D,i),d.uniform1i(t.uniformLocations.uSampler,0),p&&d.drawArrays(d.TRIANGLES,0,m.before.length);const{r:s,g:a,b:h,a:c}=u,l=`${(s/255).toFixed(1)}, ${(a/255).toFixed(1)}, ${(h/255).toFixed(1)}, ${c.toFixed(1)}`,f=b(v,`\\n      void main(void) {\\n        gl_FragColor = vec4(${l});\\n      }\\n    `);if(!f)throw Error(\"[Warpvas] Failed to initialize outline shader program.\");d.bindBuffer(d.ARRAY_BUFFER,e.position),d.vertexAttribPointer(d.getAttribLocation(f,\"aVertexPosition\"),2,n,r,0,0),d.enableVertexAttribArray(d.getAttribLocation(f,\"aVertexPosition\")),d.bindBuffer(d.ARRAY_BUFFER,e.textureCoord),d.vertexAttribPointer(d.getAttribLocation(f,\"aTextureCoord\"),2,n,r,0,0),d.enableVertexAttribArray(d.getAttribLocation(f,\"aTextureCoord\")),d.useProgram(f),g&&d.drawArrays(d.LINES,0,2*m.before.length),x&&d.drawArrays(d.POINTS,0,2*m.before.length)})(C,(()=>{const t=d.createBuffer();d.bindBuffer(d.ARRAY_BUFFER,t);const e=m.before.map(((t,e)=>{const i=[t.x/(f/c),t.y/(y/c)];return(e+1)%3==0?i.push(m.before[e-2].x/(f/c),m.before[e-2].y/(y/c)):i.push(m.before[e+1].x/(f/c),m.before[e+1].y/(y/c)),i})).flat(1);d.bufferData(d.ARRAY_BUFFER,new Float32Array(e),d.STATIC_DRAW);const i=d.createBuffer();d.bindBuffer(d.ARRAY_BUFFER,i);const n=m.after.map(((t,e)=>{const i=[(t.x+o)/(a/2)-1,-((t.y+s)/(h/2)-1)];return(e+1)%3==0?i.push((m.after[e-2].x+o)/(a/2)-1,-((m.after[e-2].y+s)/(h/2)-1)):i.push((m.after[e+1].x+o)/(a/2)-1,-((m.after[e+1].y+s)/(h/2)-1)),i})).flat(1);return d.bufferData(d.ARRAY_BUFFER,new Float32Array(n),d.STATIC_DRAW),{position:i,textureCoord:t}})(),z),i},D=(t,e,i,n)=>{const{width:r,height:o,sourceScale:s=1,destinationScale:a=1}=n;(i=null!=i?i:document.createElement(\"canvas\")).width=r*a*s,i.height=o*a*s;return F(t,e,i,n)},U=\"WORKER_MESSAGE\",W=\"JOB_RESULT\",G=t=>t instanceof ArrayBuffer||t instanceof MessagePort||self.ImageBitmap&&t instanceof ImageBitmap,k=()=>{const t=[];let e,i=new Map;const n={collect:t=>{for(let e in t)i.set(e,t[e]);return n},onMessage:t=>(e=t,n),create:n=>{const r=n.toString(),o=`\\n        // 将收集到的变量声明和定义加入脚本字符串，后面函数执行的时候便不会出现not defined的错误了\\n        $collections = {};\\n        ${Object.entries(Object.fromEntries(i)).reduce(((t,[e,i])=>t+`$collections['${e}']=`+(\"function\"==typeof i?`${i};`:`JSON.parse(\\`${JSON.stringify(i)}\\`);`)),\"\")}\\n  \\n        // 声明定义用于判断是否是可转移对象的函数\\n        $isTransferables = ${G}\\n  \\n        // 在脚本中声明并定义一个包含工作流程的函数体\\n        $job=${r};\\n  \\n        // 给worker线程添加消息监听，等待主线程的发号施令\\n        onmessage=e=>{\\n          const { index, args } = e.data;\\n  \\n          Promise.resolve(\\n            $job.apply($job, args.concat([{\\n              collections: $collections,\\n              postMessage: (message) => postMessage({ type: '${U}', message }),\\n              close: self.close,\\n            }]))\\n          ).then(result => {\\n            postMessage({ type: '${W}', message: { index, result } }, [result].filter($isTransferables))\\n          }).catch(error => {\\n            postMessage({ type: '${W}', message: { index, error } })\\n          })\\n        }\\n      `,s=URL.createObjectURL(new Blob([o],{type:\"text/javascript\"})),a=new Worker(s);return a.onmessage=function(i){const n=i.data;if(n.type===U&&e&&e.call(e,n.message),n.type===W){const{index:e,result:i,error:r}=n.message,{done:o}=t[e];o(r,i)}},{run:(...e)=>new Promise(((i,n)=>{const r=t.length;t.push({done:(t,e)=>{t?n(t):i(e)}}),a.postMessage({index:r,args:e},e.filter(G))})),terminate:()=>{a.terminate(),URL.revokeObjectURL(s),t.length=0,i.clear(),e=void 0}}}};return n},N=(t,i,n,r)=>e(void 0,void 0,void 0,(function*(){const{regionPoints:e,renderingConfig:o,regionCurves:s,originalRegionPoints:a}=t,h={renderingConfig:o,regionCurves:s.map((t=>t.map((t=>({horizontal:{length:t.horizontal.length},vertical:{length:t.vertical.length}}))))),regionPoints:e,originalRegionPoints:a},c=k().collect({warpvas:h,options:r,createWarpedCanvas:A,calcBoundingBox:P,calcPerpendicularIntersection:R,calcCoordDistance:S,calcRelativeCoord:M,calcMatrix:O}).create(((t,{collections:e})=>{const{options:i,warpvas:n,createWarpedCanvas:r,calcBoundingBox:o,calcPerpendicularIntersection:s,calcCoordDistance:a,calcRelativeCoord:h,calcMatrix:c}=e,{width:l,height:u,sourceScale:p=1,destinationScale:g=1}=i,x=new OffscreenCanvas(l*g*p,u*g*p),f=new OffscreenCanvas(t.width,t.height),y=f.getContext(\"2d\");null==y||y.putImageData(t,0,0);return r(n,f,x,i,{calcBoundingBox:o,calcPerpendicularIntersection:s,calcCoordDistance:a,calcRelativeCoord:h,calcMatrix:c}).transferToImageBitmap()})),l=yield c.run(i);return c.terminate(),(n=null!=n?n:document.createElement(\"canvas\")).width=l.width,n.height=l.height,n.getContext(\"2d\").drawImage(l,0,0),n})),H=(t,i,n,r)=>e(void 0,void 0,void 0,(function*(){const{regionPoints:e,renderingConfig:o,regionCurves:s,originalRegionPoints:a}=t,h={renderingConfig:o,regionCurves:s.map((t=>t.map((t=>({horizontal:{length:t.horizontal.length},vertical:{length:t.vertical.length}}))))),regionPoints:e,originalRegionPoints:a},c=k().collect({warpvas:h,options:r,createWarpedCanvas:F}).create(((t,{collections:e})=>{const{options:i,warpvas:n,createWarpedCanvas:r}=e,{width:o,height:s,sourceScale:a=1,destinationScale:h=1}=i;return r(n,t,new OffscreenCanvas(o*h*a,s*h*a),i).transferToImageBitmap()})),l=yield c.run(i);return c.terminate(),(n=null!=n?n:document.createElement(\"canvas\")).width=l.width,n.height=l.height,n.getContext(\"2d\").drawImage(l,0,0),n}));var $,j;!function(t){t.TOP_LEFT=\"tl\",t.TOP_RIGHT=\"tr\",t.BOTTOM_LEFT=\"bl\",t.BOTTOM_RIGHT=\"br\"}($||($={})),function(t){t.TOP=\"top\",t.BOTTOM=\"bottom\",t.LEFT=\"left\",t.RIGHT=\"right\"}(j||(j={}));class V{constructor(t,e=1,i=1){if(this.splitPoints=[],this.originalRegions=[],this.originalRegionPoints=[],this.regionBoundaryCurves=[],this.regionCurves=[],this.regionPoints=[],this.splitUnit=.05,this.splitStrategy={name:\"default\",execute:V.strategy},this.renderingContext=\"webgl\",this.renderingConfig={padding:0,enableAntialias:!0,enableSafeRendering:!0,enableContentDisplay:!0,enableGridDisplay:!1,enableGridVertexDisplay:!1,gridColor:{r:255,g:0,b:0,a:1}},this._safeModeEnabled=!1,this._cacheSourceSize=null,this._cacheSourceImageData=null,this._cacheInputCanvas=null,this._cacheOutputCanvas=null,this._inputLimitScale=1,this._outputLimitScale=1,!(t instanceof HTMLCanvasElement||t instanceof HTMLImageElement))throw new TypeError(\"[Warpvas] source must be either HTMLCanvasElement or HTMLImageElement!\");if(t instanceof HTMLImageElement){const e=document.createElement(\"canvas\"),i=e.getContext(\"2d\");if(!i)throw new Error(\"Failed to get 2D rendering context for canvas\");e.width=t.naturalWidth,e.height=t.naturalHeight,i.drawImage(t,0,0),this.source=e}else this.source=t;this.splitPoints=this._initializeSplitPoints(e,i),this.setWarpState(this.splitPoints)}get maxSplitUnitPixel(){return this.splitUnit*this.source.width}get scale(){return{x:this._inputLimitScale*this._outputLimitScale,y:this._inputLimitScale*this._outputLimitScale}}static strategy(t){if(!t.regionCurves)return[];const e=[];return t.regionBoundaryCurves.forEach(((i,n)=>{const r=[];i.forEach(((e,i)=>{const o=[],{vertical:s,horizontal:a}=t.regionCurves[n][i];for(let t=0;t<a.length;t++)for(let e=0;e<s.length;e++){const i=s[e].get(t/(a.length-1)),n=a[t].get(e/(s.length-1));o.push({x:(i.x+n.x)/2,y:(i.y+n.y)/2})}r.push(o)})),e.push(r)})),e}static serializeWarpState(t){const{splitPoints:e,regionBounds:i}=t,n=[e.length,i.length,i[0].length];e.forEach((t=>{n.push(t.x,t.y)}));const r=[\"top\",\"right\",\"bottom\",\"left\"];i.forEach((t=>t.forEach((t=>[r.forEach((e=>t[e].forEach((t=>{n.push(t.x,t.y)}))))]))));const o=new Float32Array(n),s=new Uint8Array(o.buffer);return btoa(String.fromCharCode.apply(null,s))}static deserializeWarpState(t){const e=atob(t),i=new Uint8Array(e.length);for(let t=0;t<e.length;t++)i[t]=e.charCodeAt(t);const n=new Float32Array(i.buffer),r=Array.from(n),o=[\"top\",\"right\",\"bottom\",\"left\"],s=r[0],a=r[1],h=r[2];let c=3;const l=[];for(let t=0;t<s;t++)l.push({x:r[c],y:r[c+1]}),c+=2;const u=[];for(let t=0;t<a;t++){const t=[];for(let e=0;e<h;e++){const e={};for(const t of o){e[t]=[];for(let i=0;i<4;i++)e[t].push({x:r[c],y:r[c+1]}),c+=2}t.push(e)}u.push(t)}return{splitPoints:l,regionBounds:u}}_initializeSplitPoints(t=1,e=1){const i=Math.max(Math.floor(t),1),n=Math.max(Math.floor(e),1),r=[];for(let o=1;o<i;o++)for(let i=1;i<n;i++)o===i&&r.push({x:i/e,y:o/t});return r}_initializeOriginalRegions(){const{width:t,height:e}=this.source;let i=[],n=[];this.splitPoints.forEach((t=>{t.x<0||t.x>1||t.y<0||t.y>1||(i.push(t.x),n.push(t.y))})),i=[...new Set([0,...i,1])],n=[...new Set([0,...n,1])],i.sort(((t,e)=>t-e)),n.sort(((t,e)=>t-e));const r=[];for(let o=0;o<n.length-1;o++){r.push([]);for(let s=0;s<i.length-1;s++)r[r.length-1].push({tl:{x:i[s]*t,y:n[o]*e},tr:{x:i[s+1]*t,y:n[o]*e},bl:{x:i[s]*t,y:n[o+1]*e},br:{x:i[s+1]*t,y:n[o+1]*e}})}return r}_calculateSamplingPoints(t){const e=t.tr.x-t.tl.x,i=t.bl.y-t.tl.y,n=Math.max(Math.ceil(e/this.maxSplitUnitPixel),1)+1,r=Math.max(Math.ceil(i/this.maxSplitUnitPixel),1)+1;return{hts:Array.from({length:n}).map(((t,e)=>e/(n-1))),vts:Array.from({length:r}).map(((t,e)=>e/(r-1)))}}_initializeOriginalRegionPoints(){return this.originalRegions.map((t=>t.map((t=>{const{hts:e,vts:i}=this._calculateSamplingPoints(t),n=[],{tl:r,tr:o,bl:s}=t,a=o.x-r.x,h=s.y-r.y;for(let t=0;t<i.length;t++)for(let o=0;o<e.length;o++)n.push({x:r.x+a*e[o],y:r.y+h*i[t]});return n}))))}_initializeBoundaryControlPoints(t){const e=[];return t.forEach((t=>{e.push([]),t.forEach((t=>{const{tl:i,tr:n,br:r,bl:o}=t,s={top:[i,n],bottom:[o,r],left:[i,o],right:[n,r]},a={};for(const t in s){const[e,i]=s[t];a[t]=[e,{x:e.x+1*(i.x-e.x)/3,y:e.y+1*(i.y-e.y)/3},{x:i.x-1*(i.x-e.x)/3,y:i.y-1*(i.y-e.y)/3},i]}e[e.length-1].push(a)}))})),e}_generateRegionCurves(t,e,i){const n={horizontal:[],vertical:[]};return e.forEach((e=>{if(0===e)return void n.vertical.push(t.left);if(1===e)return void n.vertical.push(t.right);const i=t.top.get(e),r=t.bottom.get(e),o=new T([i,{x:i.x+((t.left.points[1].x-t.left.points[0].x)*(1-e)+(t.right.points[1].x-t.right.points[0].x)*e),y:i.y+((t.left.points[1].y-t.left.points[0].y)*(1-e)+(t.right.points[1].y-t.right.points[0].y)*e)},{x:r.x+((t.left.points[2].x-t.left.points[3].x)*(1-e)+(t.right.points[2].x-t.right.points[3].x)*e),y:r.y+((t.left.points[2].y-t.left.points[3].y)*(1-e)+(t.right.points[2].y-t.right.points[3].y)*e)},r]);n.vertical.push(o)})),i.forEach((e=>{if(0===e)return void n.horizontal.push(t.top);if(1===e)return void n.horizontal.push(t.bottom);const i=t.left.get(e),r=t.right.get(e),o=new T([i,{x:i.x+((t.top.points[1].x-t.top.points[0].x)*(1-e)+(t.bottom.points[1].x-t.bottom.points[0].x)*e),y:i.y+((t.top.points[1].y-t.top.points[0].y)*(1-e)+(t.bottom.points[1].y-t.bottom.points[0].y)*e)},{x:r.x+((t.top.points[2].x-t.top.points[3].x)*(1-e)+(t.bottom.points[2].x-t.bottom.points[3].x)*e),y:r.y+((t.top.points[2].y-t.top.points[3].y)*(1-e)+(t.bottom.points[2].y-t.bottom.points[3].y)*e)},r]);n.horizontal.push(o)})),n}_generateAllRegionCurves(t){const e=[];return t.forEach(((t,i)=>{const n=[];e.push(n),t.forEach(((t,e)=>{const r=t,o=this.originalRegions[i][e],{hts:s,vts:a}=this._calculateSamplingPoints(o);n.push(this._generateRegionCurves(r,s,a))}))})),e}setSplitUnit(t){return this.splitUnit=t<=0?1:Math.min(1,t),this.originalRegionPoints=this._initializeOriginalRegionPoints(),this}setSplitStrategy(t){return this.splitStrategy=t,this}setInputLimitSize(t){return this._inputLimitSize=t,t||(this._inputLimitScale=1,this._cacheInputCanvas=null),this._cacheSourceImageData=null,this}setOutputLimitSize(t){return this._outputLimitSize=t,t||(this._outputLimitScale=1),this}setRenderingContext(t){return this.renderingContext=t,this}setRenderingCanvas(t){return this._cacheOutputCanvas=t,this}setRenderingConfig(t){return this.renderingConfig=Object.assign(Object.assign({},this.renderingConfig),t),this}getBoundingBoxInfo(){const{padding:t}=this.renderingConfig,e=this.regionCurves.length,i=this.regionCurves[0].length,n={left:1/0,right:-1/0,top:1/0,bottom:-1/0};for(let t=0;t<e;t++)for(let e=0;e<i;e++){const i=this.regionCurves[t][e];Object.values(i).forEach((t=>{const e=t.length;for(let i=0;i<e;i++){const e=t[i].bbox();n.left=Math.min(n.left,e.x.min),n.right=Math.max(n.right,e.x.max),n.top=Math.min(n.top,e.y.min),n.bottom=Math.max(n.bottom,e.y.max)}}))}return{offsetX:-n.left+t,offsetY:-n.top+t,width:n.right-n.left+2*t,height:n.bottom-n.top+2*t}}_cloneCanvas(t,e=t.width,i=t.height){const n=document.createElement(\"canvas\");n.width=e,n.height=i;const r=n.getContext(\"2d\");return null==r||r.drawImage(t,0,0,e,i),n}_createLinearBezier(t,e){return[t,{x:t.x+1*(e.x-t.x)/3,y:t.y+1*(e.y-t.y)/3},{x:e.x-1*(e.x-t.x)/3,y:e.y-1*(e.y-t.y)/3},e]}_mergeBezierCurves(t,e){const i=(t,e,i)=>{const{x:n,y:r}=e,{x:o,y:s}=i,a=Math.atan2(r,n),h=Math.atan2(s,o)-a,c=Math.sqrt(Math.pow(o,2)+Math.pow(s,2))*Math.cos(h),l=c*Math.cos(a),u=c*Math.sin(a);return{x:t.x+l,y:t.y+u}},n=i(t[1],{x:t[1].x-t[0].x,y:t[1].y-t[0].y},{x:e[1].x-e[0].x,y:e[1].y-e[0].y}),r=i(e[2],{x:e[2].x-e[3].x,y:e[2].y-e[3].y},{x:t[2].x-t[3].x,y:t[2].y-t[3].y});return[t[0],n,r,e[3]]}_findConnectedVertex(t,e){const i={top:[[\"left\",0],[\"right\",0]],bottom:[[\"left\",3],[\"right\",3]],left:[[\"top\",0],[\"bottom\",0]],right:[[\"top\",3],[\"bottom\",3]]}[t];if(!i||![\"first\",\"last\"].includes(e))throw TypeError(`[Warpvas] Invalid vertex connection parameters: direction=\"${t}\", position=\"${e}\"\\nExpected values:\\n- direction: \"top\" | \"bottom\" | \"left\" | \"right\"\\n- position: \"first\" | \"last\"`);const n=i[{first:0,last:1}[e]];return{direction:n[0],position:{0:\"first\",3:\"last\"}[n[1]]}}_setSingleRegionVertexCoord(t,e,i,n,r=!0){const o=(i,n,o)=>{var s,a;const h=null===(a=null===(s=this.regionBoundaryCurves[t])||void 0===s?void 0:s[e])||void 0===a?void 0:a[i];if(!h)return;const c=\"first\"===n?o:h.points[0],l=\"last\"===n?o:h.points[3];h.points.forEach(((t,e)=>{if(!r&&[1,2].includes(e))return;const i=this._createLinearBezier(c,l)[e];t.x=i.x,t.y=i.y}))},[s,a]={[$.TOP_LEFT]:[\"top\",\"first\"],[$.TOP_RIGHT]:[\"top\",\"last\"],[$.BOTTOM_LEFT]:[\"bottom\",\"first\"],[$.BOTTOM_RIGHT]:[\"bottom\",\"last\"]}[i];o(s,a,n);const h=this._findConnectedVertex(s,a);o(h.direction,h.position,n)}updateVertexCoord(t,e,i,n,r=!0){this._setSingleRegionVertexCoord(t,e,i,n,r);return{[$.TOP_LEFT]:[{row:t-1,col:e-1,type:$.BOTTOM_RIGHT},{row:t-1,col:e,type:$.BOTTOM_LEFT},{row:t,col:e-1,type:$.TOP_RIGHT}],[$.TOP_RIGHT]:[{row:t-1,col:e+1,type:$.BOTTOM_LEFT},{row:t,col:e+1,type:$.TOP_LEFT},{row:t-1,col:e,type:$.BOTTOM_RIGHT}],[$.BOTTOM_LEFT]:[{row:t,col:e-1,type:$.BOTTOM_RIGHT},{row:t+1,col:e,type:$.TOP_LEFT},{row:t+1,col:e-1,type:$.TOP_RIGHT}],[$.BOTTOM_RIGHT]:[{row:t,col:e+1,type:$.BOTTOM_LEFT},{row:t+1,col:e,type:$.TOP_RIGHT},{row:t+1,col:e+1,type:$.TOP_LEFT}]}[i].forEach((({row:t,col:e,type:i})=>{this._setSingleRegionVertexCoord(t,e,i,n,r)})),this}updateRegionBoundCoords(t,e,i,n){return this.regionBoundaryCurves=this._initializeRegionBoundaryCurves(this.forEachRegionBoundCoords(((r,o,s,a)=>r===t&&o===e&&i===s?n:a.points.map((t=>({x:t.x,y:t.y})))))),this.updateVertexCoord(t,e,{top:$.TOP_LEFT,right:$.TOP_RIGHT,bottom:$.BOTTOM_LEFT,left:$.TOP_LEFT}[i],n[0],!1),this.updateVertexCoord(t,e,{top:$.TOP_RIGHT,right:$.BOTTOM_RIGHT,bottom:$.BOTTOM_RIGHT,left:$.BOTTOM_LEFT}[i],n[3],!1),this}forEachRegionBoundCoords(t=((t,e,i,n)=>n.points)){const e=[];return this.regionBoundaryCurves.forEach(((i,n)=>{e.push([]),i.forEach(((i,r)=>{e[e.length-1].push([\"top\",\"right\",\"left\",\"bottom\"].reduce(((e,o)=>(e[o]=t(n,r,o,i[o]),e)),{}))}))})),e}_initializeRegionBoundaryCurves(t){const e=[];return t.forEach(((t,i)=>{e.push([]),t.forEach(((t,n)=>{var r,o,s,a;const h={};for(const c in t){switch(c){case\"top\":{const t=null===(o=null===(r=e[i-1])||void 0===r?void 0:r[n])||void 0===o?void 0:o.bottom;t&&(h[c]=t);break}case\"left\":{const t=null===(a=null===(s=e[i])||void 0===s?void 0:s[n-1])||void 0===a?void 0:a.right;t&&(h[c]=t);break}}if(!h[c]){const e=t[c];h[c]=new T(e[0].x,e[0].y,e[1].x,e[1].y,e[2].x,e[2].y,e[3].x,e[3].y)}}e[e.length-1].push(h)}))})),e}getWarpState(){const t=this.forEachRegionBoundCoords();return{splitPoints:this.splitPoints,regionBounds:t}}setWarpState(t,e=null){this.splitPoints=t;const{width:i,height:n}=this.source;if(this._cacheSourceSize={width:i,height:n},this.originalRegions=this._initializeOriginalRegions(),this.originalRegionPoints=this._initializeOriginalRegionPoints(),e)this.regionBoundaryCurves=this._initializeRegionBoundaryCurves(e);else{const t=this._initializeBoundaryControlPoints(this.originalRegions);this.regionBoundaryCurves=this._initializeRegionBoundaryCurves(t)}return this}resetWarpState(t=1,e=1){return this.splitPoints=this._initializeSplitPoints(t,e),this.setWarpState(this.splitPoints)}isUnwarped(){const t=this.forEachRegionBoundCoords(((t,e,i,n)=>n.points.map((t=>({x:t.x/this.source.width,y:t.y/this.source.height})))));return 0===this.splitPoints.length&&Object.entries(t[0][0]).every((([t,e])=>{const i=[\"right\",\"bottom\"].includes(t)?1:0,n={top:\"y\",bottom:\"y\",left:\"x\",right:\"x\"}[t],r={top:\"x\",bottom:\"x\",left:\"y\",right:\"y\"}[t];return e.every((t=>t[n]===i))&&0===e[0][r]&&Math.abs(e[1][r]-1/3)<Number.EPSILON&&Math.abs(e[2][r]-2/3)<Number.EPSILON&&1===e[3][r]}))}getHitInfo(t){let e=null;try{this.forEachSplitRegion((([i,n,r,o],s,a,h,c,l)=>{const u=B(t,i,n,o),p=B(t,r,n,o);if(u||p)throw e={rowIndex:c,colIndex:l,row:a,col:h,after:[i,n,r,o],before:s,clickPart:u?0:1},Error()}))}catch(t){}return e}splitRegionByPoint(t,e,i,n=.05){const{tl:r,tr:o,bl:s}=this.originalRegions[t][e];let a=(i.x-r.x)/(o.x-r.x),h=(i.y-r.y)/(s.y-r.y);a<n&&(a=0),a>1-n&&(a=1),h<n&&(h=0),h>1-n&&(h=1);const c=[];this.regionBoundaryCurves.forEach(((e,i)=>{if(i!==t||0===h||1===h)return void c.push(e.map((t=>{const e={};for(const i in t)e[i]=t[i].points;return e})));const n=[],r=[];e.forEach((t=>{const{horizontal:e,vertical:i}=this._generateRegionCurves(t,[0,1],[0,h,1]),{left:o,right:s}=i[0].split(h),{left:a,right:c}=i[1].split(h);n.push({left:o.points,right:a.points,top:e[0].points,bottom:e[1].points}),r.push({left:s.points,right:c.points,top:e[1].points,bottom:e[2].points})})),c.push(n,r)})),0!==a&&1!==a&&c.forEach(((t,i)=>{const{horizontal:n,vertical:r}=this._generateRegionCurves({left:new T(t[e].left),right:new T(t[e].right),top:new T(t[e].top),bottom:new T(t[e].bottom)},[0,a,1],[0,1]),{left:o,right:s}=n[0].split(a),{left:h,right:l}=n[1].split(a);c[i].splice(e,1,{left:r[0].points,right:r[1].points,top:o.points,bottom:h.points},{left:r[1].points,right:r[2].points,top:s.points,bottom:l.points})})),this.setWarpState([...this.splitPoints,{x:(0===a?r.x:1===a?o.x:i.x)/this.source.width,y:(0===h?r.y:1===h?s.y:i.y)/this.source.height}],c)}removeRegion(...t){const e=[],{width:i,height:n}=this.source,r=(r,o,s)=>{t.some((t=>t.row===o||t.column===s))||0===o&&0===s||o===this.originalRegions.length&&0===s||0===o&&s===this.originalRegions[0].length||o===this.originalRegions.length&&s===this.originalRegions[0].length||e.some((t=>t.x===r.x||0===s||s===this.originalRegions[0].length))&&e.some((t=>t.y===r.y||0===o||o===this.originalRegions.length))||e.push({x:r.x/i,y:r.y/n})};this.originalRegions.forEach(((t,e)=>{t.forEach(((i,n)=>{const{tl:o,tr:s,bl:a,br:h}=i;r(o,e,n),n===t.length-1&&r(s,e,n+1),e===this.originalRegions.length-1&&(r(a,e+1,n),n===t.length-1&&r(h,e+1,n+1))}))}));const o=this.forEachRegionBoundCoords(),s=[...new Set(t.map((t=>t.row)))];s.sort(((t,e)=>e-t)),s.forEach((t=>{const e=o[t],i=o[t-1];e&&i&&o.splice(t-1,2,i.map(((t,i)=>({top:t.top,left:this._mergeBezierCurves(t.left,e[i].left),right:this._mergeBezierCurves(t.right,e[i].right),bottom:e[i].bottom}))))}));const a=[...new Set(t.map((t=>t.column)))];a.sort(((t,e)=>e-t)),a.forEach((t=>{o.forEach((e=>{const i=e[t],n=e[t-1];i&&n&&e.splice(t-1,2,{top:this._mergeBezierCurves(n.top,i.top),left:n.left,right:i.right,bottom:this._mergeBezierCurves(n.bottom,i.bottom)})}))})),this.setWarpState(e,o)}forEachSplitRegion(t){this.regionPoints.forEach(((e,i)=>{e.forEach(((e,n)=>{const r=e,o=this.regionCurves[i][n].vertical.length-1;r.forEach(((e,s)=>{const a=Math.floor(s/(o+1)),h=s%(o+1),c=r[s],l=r[s+1],u=r[s+o+2],p=r[s+o+1],g=this.originalRegionPoints[i][n][s],x=this.originalRegionPoints[i][n][s+1],f=this.originalRegionPoints[i][n][s+o+2],y=this.originalRegionPoints[i][n][s+o+1];l&&u&&s%(o+1)<o&&t([c,l,u,p],[g,x,f,y],a,h,i,n)}))}))}))}_generateRenderOptions(){var t,e;!this._cacheSourceSize||this._cacheSourceSize.width===this.source.width&&this._cacheSourceSize.height===this.source.height||this.setWarpState(this.splitPoints),this.regionCurves=this._generateAllRegionCurves(this.regionBoundaryCurves),this.regionPoints=this.splitStrategy.execute(this);const{offsetX:i,offsetY:n,width:r,height:o}=this.getBoundingBoxInfo();if(this._inputLimitSize&&!this._cacheInputCanvas){const t=this._inputLimitSize,{width:e,height:i}=this.source,n={width:t.width?Math.min(1,t.width/e):0,height:t.height?Math.min(1,t.height/i):0};n.width=n.width||n.height,n.height=n.height||n.width;const r=Math.min(n.width,n.height),o=document.createElement(\"canvas\");o.width=Math.ceil(e*r),o.height=Math.ceil(i*r);const s=o.getContext(\"2d\");null==s||s.drawImage(this.source,0,0,o.width,o.height),this._inputLimitScale=r,this._cacheInputCanvas=o}if(this._outputLimitSize){let t=1;this._outputLimitSize.width&&(t=Math.min(t,this._outputLimitSize.width/r)),this._outputLimitSize.height&&(t=Math.min(t,this._outputLimitSize.height/o)),this._outputLimitScale=t}let s=null!==(t=this._cacheInputCanvas)&&void 0!==t?t:this.source;const a=null!==(e=this._cacheOutputCanvas)&&void 0!==e?e:null;s===a&&(console.warn(\"[Warpvas] Do not use the same canvas as both input and output. This will require creating a copy of the input canvas before each render operation.\"),s=this._cloneCanvas(s));return{inputCanvas:s,outputCanvas:a,options:{x:i,y:n,width:r,height:o,sourceScale:this._inputLimitScale,destinationScale:this._outputLimitScale}}}_getInputCanvasImageData(t=!0){var e;if(t&&this._cacheSourceImageData)return this._cacheSourceImageData;const i=null!==(e=this._cacheInputCanvas)&&void 0!==e?e:this.source,n=i.getContext(\"2d\");if(!n)throw new Error(\"[Warpvas] Failed to get 2D rendering context. Please ensure that:\\n1. The inputCanvas is a valid <canvas> element\\n2. The browser supports Canvas API\\n3. The canvas has not been tainted by cross-origin content\");const r=n.getImageData(0,0,i.width,i.height);return this._cacheSourceImageData=r,r}render(){const{inputCanvas:t,outputCanvas:e,options:i}=this._generateRenderOptions();if(this._safeModeEnabled)return L(this,t,e,i);const n={\"2d\":L,webgl:D}[this.renderingContext];try{return n(this,t,e,i)}catch(n){if(this.renderingConfig.enableSafeRendering&&\"webgl\"===this.renderingContext)return this._safeModeEnabled=!0,L(this,t,e,i);throw n}}renderWithWorker(t=!0){return e(this,void 0,void 0,(function*(){const{outputCanvas:e,options:i}=this._generateRenderOptions(),n=this._getInputCanvasImageData(t);if(this._safeModeEnabled)return H(this,n,e,i);const r={\"2d\":N,webgl:H}[this.renderingContext];try{return r(this,n,e,i)}catch(t){if(this.renderingConfig.enableSafeRendering&&\"webgl\"===this.renderingContext)return this._safeModeEnabled=!0,H(this,n,e,i);throw t}}))}dispose(){this._safeModeEnabled=!1,this._cacheInputCanvas&&(this._cacheInputCanvas.width=0,this._cacheInputCanvas.height=0,this._cacheInputCanvas=null),this._cacheOutputCanvas&&(this._cacheOutputCanvas.width=0,this._cacheOutputCanvas.height=0,this._cacheOutputCanvas=null),this._cacheSourceImageData=null,this._cacheSourceSize=null,this.splitPoints=[],this.originalRegions=[],this.originalRegionPoints=[],this.regionBoundaryCurves=[],this.regionCurves=[],this.regionPoints=[]}}export{V as Warpvas,I as utils};\n//# sourceMappingURL=index.esm.js.map\n","\"function\"==typeof SuppressedError&&SuppressedError;const n=(t,n,e)=>{if(t.x===n.x)return{x:t.x,y:e.y};if(t.y===n.y)return{x:e.x,y:t.y};const r=(n.y-t.y)/(n.x-t.x),i=-1/r,s=(-r*t.x+t.y+i*e.x-e.y)/(i-r);return{x:s,y:r*(s-t.x)+t.y}},e=(t,n)=>Math.sqrt(Math.pow(n.x-t.x,2)+Math.pow(n.y-t.y,2)),r=(t,n,e)=>{const r=Object.assign({},t),i={x:n.x-t.x,y:n.y-t.y};if(0===i.x&&0===i.y)return r;if(0===i.x)r.y+=e*Math.sign(i.y);else if(0===i.y)r.x+=e*Math.sign(i.x);else{const t=Math.sqrt(Math.pow(i.x,2)+Math.pow(i.y,2));r.x+=i.x*(e/t),r.y+=i.y*(e/t)}return r};var i,s,o=Object.freeze({__proto__:null,calcBoundingBox:(t,n,e)=>{const r=Math.min(t.x,n.x,e.x),i=Math.max(t.x,n.x,e.x),s=Math.min(t.y,n.y,e.y);return{width:i-r,height:Math.max(t.y,n.y,e.y)-s}},calcCoordDistance:e,calcExpandCoord:(t,i,s,o=1)=>{const c=n(i,s,t),u=e(t,c),a=r(t,c,u+o);return{x:a.x-c.x+i.x,y:a.y-c.y+i.y}},calcIntersection:(t,n,e,r)=>{const i=(t,n)=>Math.abs(t-n)<Math.pow(.1,12);if(i(t.x,n.x)&&i(e.x,r.x))return null;if(i(t.y,n.y)&&i(e.y,r.y))return null;const s=1e4*(n.y-t.y)/Math.round(1e4*(n.x-t.x)),o=1e4*(r.y-e.y)/Math.round(1e4*(r.x-e.x)),c=t.y-s*t.x,u=e.y-o*e.x;if(Math.abs(s)===1/0)return{x:t.x,y:o*t.x+u};if(Math.abs(o)===1/0)return{x:e.x,y:s*e.x+c};const a=(u-c)/(s-o);return{x:a,y:s*a+c}},calcMatrix:(t,n)=>{const[e,r,i]=t,[s,o,c]=n,u=.1/Math.abs([...t,...n].reduce(((t,n)=>Math.min(t,n.x,n.y)),-1)),a=(t,n,e)=>{const[r,i,s,o]=t.map(Number),[c,u,a,h]=n.map(Number),[l,x,y,f]=e.map(Number),p=s-i*a/u,m=a-u*y/x,d=h-u*f/x,g=c-u*l/x,z=(p/m*d-(o-i*h/u))/(p/m*g-(r-i*c/u)),b=(d-g*z)/m;return{x:z,y:(o-r*z-s*b)/i,z:b}},h=[s.x+u,s.y+u,1,e.x+u],l=[o.x+u,o.y+u,1,r.x+u],x=[c.x+u,c.y+u,1,i.x+u],y=a(h,l,x);h[3]=e.y+u,l[3]=r.y+u,x[3]=i.y+u;const f=a(h,l,x),p=y.x,m=y.y,d=y.z;return[p,f.x,m,f.y,d,f.z]},calcPerpendicularIntersection:n,calcRelativeCoord:r,isTriangleContainsPoint:(t,n,e,r,i=.1)=>{const s=(t,n,e)=>Math.abs(t.x*(n.y-e.y)+n.x*(e.y-t.y)+e.x*(t.y-n.y))/2,o=s(n,e,r);return s(n,e,t)+s(e,r,t)+s(r,n,t)<=o+i}});!function(t){t.TOP_LEFT=\"tl\",t.TOP_RIGHT=\"tr\",t.BOTTOM_LEFT=\"bl\",t.BOTTOM_RIGHT=\"br\"}(i||(i={})),function(t){t.TOP=\"top\",t.BOTTOM=\"bottom\",t.LEFT=\"left\",t.RIGHT=\"right\"}(s||(s={}));const{abs:c,cos:u,sin:a,acos:h,atan2:l,sqrt:x,pow:y}=Math;function f(t){return t<0?-y(-t,1/3):y(t,1/3)}const p=Math.PI,m=2*p,d=p/2,g=Number.MAX_SAFE_INTEGER||9007199254740991,z=Number.MIN_SAFE_INTEGER||-9007199254740991,b={x:0,y:0,z:0},v={Tvalues:[-.06405689286260563,.06405689286260563,-.1911188674736163,.1911188674736163,-.3150426796961634,.3150426796961634,-.4337935076260451,.4337935076260451,-.5454214713888396,.5454214713888396,-.6480936519369755,.6480936519369755,-.7401241915785544,.7401241915785544,-.820001985973903,.820001985973903,-.8864155270044011,.8864155270044011,-.9382745520027328,.9382745520027328,-.9747285559713095,.9747285559713095,-.9951872199970213,.9951872199970213],Cvalues:[.12793819534675216,.12793819534675216,.1258374563468283,.1258374563468283,.12167047292780339,.12167047292780339,.1155056680537256,.1155056680537256,.10744427011596563,.10744427011596563,.09761865210411388,.09761865210411388,.08619016153195327,.08619016153195327,.0733464814110803,.0733464814110803,.05929858491543678,.05929858491543678,.04427743881741981,.04427743881741981,.028531388628933663,.028531388628933663,.0123412297999872,.0123412297999872],arcfn:function(t,n){const e=n(t);let r=e.x*e.x+e.y*e.y;return void 0!==e.z&&(r+=e.z*e.z),x(r)},compute:function(t,n,e){if(0===t)return n[0].t=0,n[0];const r=n.length-1;if(1===t)return n[r].t=1,n[r];const i=1-t;let s=n;if(0===r)return n[0].t=t,n[0];if(1===r){const n={x:i*s[0].x+t*s[1].x,y:i*s[0].y+t*s[1].y,t:t};return e&&(n.z=i*s[0].z+t*s[1].z),n}if(r<4){let n,o,c,u=i*i,a=t*t,h=0;2===r?(s=[s[0],s[1],s[2],b],n=u,o=i*t*2,c=a):3===r&&(n=u*i,o=u*t*3,c=i*a*3,h=t*a);const l={x:n*s[0].x+o*s[1].x+c*s[2].x+h*s[3].x,y:n*s[0].y+o*s[1].y+c*s[2].y+h*s[3].y,t:t};return e&&(l.z=n*s[0].z+o*s[1].z+c*s[2].z+h*s[3].z),l}const o=JSON.parse(JSON.stringify(n));for(;o.length>1;){for(let n=0;n<o.length-1;n++)o[n]={x:o[n].x+(o[n+1].x-o[n].x)*t,y:o[n].y+(o[n+1].y-o[n].y)*t},void 0!==o[n].z&&(o[n].z=o[n].z+(o[n+1].z-o[n].z)*t);o.splice(o.length-1,1)}return o[0].t=t,o[0]},computeWithRatios:function(t,n,e,r){const i=1-t,s=e,o=n;let c,u=s[0],a=s[1],h=s[2],l=s[3];return u*=i,a*=t,2===o.length?(c=u+a,{x:(u*o[0].x+a*o[1].x)/c,y:(u*o[0].y+a*o[1].y)/c,z:!!r&&(u*o[0].z+a*o[1].z)/c,t:t}):(u*=i,a*=2*i,h*=t*t,3===o.length?(c=u+a+h,{x:(u*o[0].x+a*o[1].x+h*o[2].x)/c,y:(u*o[0].y+a*o[1].y+h*o[2].y)/c,z:!!r&&(u*o[0].z+a*o[1].z+h*o[2].z)/c,t:t}):(u*=i,a*=1.5*i,h*=3*i,l*=t*t*t,4===o.length?(c=u+a+h+l,{x:(u*o[0].x+a*o[1].x+h*o[2].x+l*o[3].x)/c,y:(u*o[0].y+a*o[1].y+h*o[2].y+l*o[3].y)/c,z:!!r&&(u*o[0].z+a*o[1].z+h*o[2].z+l*o[3].z)/c,t:t}):void 0))},derive:function(t,n){const e=[];for(let r=t,i=r.length,s=i-1;i>1;i--,s--){const t=[];for(let e,i=0;i<s;i++)e={x:s*(r[i+1].x-r[i].x),y:s*(r[i+1].y-r[i].y)},n&&(e.z=s*(r[i+1].z-r[i].z)),t.push(e);e.push(t),r=t}return e},between:function(t,n,e){return n<=t&&t<=e||v.approximately(t,n)||v.approximately(t,e)},approximately:function(t,n,e){return c(t-n)<=(e||1e-6)},length:function(t){const n=v.Tvalues.length;let e=0;for(let r,i=0;i<n;i++)r=.5*v.Tvalues[i]+.5,e+=v.Cvalues[i]*v.arcfn(r,t);return.5*e},map:function(t,n,e,r,i){return r+(i-r)*((t-n)/(e-n))},lerp:function(t,n,e){const r={x:n.x+t*(e.x-n.x),y:n.y+t*(e.y-n.y)};return void 0!==n.z&&void 0!==e.z&&(r.z=n.z+t*(e.z-n.z)),r},pointToString:function(t){let n=t.x+\"/\"+t.y;return void 0!==t.z&&(n+=\"/\"+t.z),n},pointsToString:function(t){return\"[\"+t.map(v.pointToString).join(\", \")+\"]\"},copy:function(t){return JSON.parse(JSON.stringify(t))},angle:function(t,n,e){const r=n.x-t.x,i=n.y-t.y,s=e.x-t.x,o=e.y-t.y;return l(r*o-i*s,r*s+i*o)},round:function(t,n){const e=\"\"+t,r=e.indexOf(\".\");return parseFloat(e.substring(0,r+1+n))},dist:function(t,n){const e=t.x-n.x,r=t.y-n.y;return x(e*e+r*r)},closest:function(t,n){let e,r,i=y(2,63);return t.forEach((function(t,s){r=v.dist(n,t),r<i&&(i=r,e=s)})),{mdist:i,mpos:e}},abcratio:function(t,n){if(2!==n&&3!==n)return!1;if(void 0===t)t=.5;else if(0===t||1===t)return t;const e=y(t,n)+y(1-t,n);return c((e-1)/e)},projectionratio:function(t,n){if(2!==n&&3!==n)return!1;if(void 0===t)t=.5;else if(0===t||1===t)return t;const e=y(1-t,n);return e/(y(t,n)+e)},lli8:function(t,n,e,r,i,s,o,c){const u=(t-e)*(s-c)-(n-r)*(i-o);return 0!=u&&{x:((t*r-n*e)*(i-o)-(t-e)*(i*c-s*o))/u,y:((t*r-n*e)*(s-c)-(n-r)*(i*c-s*o))/u}},lli4:function(t,n,e,r){const i=t.x,s=t.y,o=n.x,c=n.y,u=e.x,a=e.y,h=r.x,l=r.y;return v.lli8(i,s,o,c,u,a,h,l)},lli:function(t,n){return v.lli4(t,t.c,n,n.c)},makeline:function(t,n){return new I(t.x,t.y,(t.x+n.x)/2,(t.y+n.y)/2,n.x,n.y)},findbbox:function(t){let n=g,e=g,r=z,i=z;return t.forEach((function(t){const s=t.bbox();n>s.x.min&&(n=s.x.min),e>s.y.min&&(e=s.y.min),r<s.x.max&&(r=s.x.max),i<s.y.max&&(i=s.y.max)})),{x:{min:n,mid:(n+r)/2,max:r,size:r-n},y:{min:e,mid:(e+i)/2,max:i,size:i-e}}},shapeintersections:function(t,n,e,r,i){if(!v.bboxoverlap(n,r))return[];const s=[],o=[t.startcap,t.forward,t.back,t.endcap],c=[e.startcap,e.forward,e.back,e.endcap];return o.forEach((function(n){n.virtual||c.forEach((function(r){if(r.virtual)return;const o=n.intersects(r,i);o.length>0&&(o.c1=n,o.c2=r,o.s1=t,o.s2=e,s.push(o))}))})),s},makeshape:function(t,n,e){const r=n.points.length,i=t.points.length,s=v.makeline(n.points[r-1],t.points[0]),o=v.makeline(t.points[i-1],n.points[0]),c={startcap:s,forward:t,back:n,endcap:o,bbox:v.findbbox([s,t,n,o]),intersections:function(t){return v.shapeintersections(c,c.bbox,t,t.bbox,e)}};return c},getminmax:function(t,n,e){if(!e)return{min:0,max:0};let r,i,s=g,o=z;-1===e.indexOf(0)&&(e=[0].concat(e)),-1===e.indexOf(1)&&e.push(1);for(let c=0,u=e.length;c<u;c++)r=e[c],i=t.get(r),i[n]<s&&(s=i[n]),i[n]>o&&(o=i[n]);return{min:s,mid:(s+o)/2,max:o,size:o-s}},align:function(t,n){const e=n.p1.x,r=n.p1.y,i=-l(n.p2.y-r,n.p2.x-e);return t.map((function(t){return{x:(t.x-e)*u(i)-(t.y-r)*a(i),y:(t.x-e)*a(i)+(t.y-r)*u(i)}}))},roots:function(t,n){n=n||{p1:{x:0,y:0},p2:{x:1,y:0}};const e=t.length-1,r=v.align(t,n),i=function(t){return 0<=t&&t<=1};if(2===e){const t=r[0].y,n=r[1].y,e=r[2].y,s=t-2*n+e;if(0!==s){const r=-x(n*n-t*e),o=-t+n;return[-(r+o)/s,-(-r+o)/s].filter(i)}return n!==e&&0===s?[(2*n-e)/(2*n-2*e)].filter(i):[]}const s=r[0].y,o=r[1].y,c=r[2].y;let a=3*o-s-3*c+r[3].y,l=3*s-6*o+3*c,y=-3*s+3*o,p=s;if(v.approximately(a,0)){if(v.approximately(l,0))return v.approximately(y,0)?[]:[-p/y].filter(i);const t=x(y*y-4*l*p),n=2*l;return[(t-y)/n,(-y-t)/n].filter(i)}l/=a,y/=a,p/=a;const d=(3*y-l*l)/3,g=d/3,z=(2*l*l*l-9*l*y+27*p)/27,b=z/2,_=b*b+g*g*g;let w,E,M,T,O;if(_<0){const t=-d/3,n=x(t*t*t),e=-z/(2*n),r=h(e<-1?-1:e>1?1:e),s=2*f(n);return M=s*u(r/3)-l/3,T=s*u((r+m)/3)-l/3,O=s*u((r+2*m)/3)-l/3,[M,T,O].filter(i)}if(0===_)return w=b<0?f(-b):-f(b),M=2*w-l/3,T=-w-l/3,[M,T].filter(i);{const t=x(_);return w=f(-b+t),E=f(b+t),[w-E-l/3].filter(i)}},droots:function(t){if(3===t.length){const n=t[0],e=t[1],r=t[2],i=n-2*e+r;if(0!==i){const t=-x(e*e-n*r),s=-n+e;return[-(t+s)/i,-(-t+s)/i]}return e!==r&&0===i?[(2*e-r)/(2*(e-r))]:[]}if(2===t.length){const n=t[0],e=t[1];return n!==e?[n/(n-e)]:[]}return[]},curvature:function(t,n,e,r,i){let s,o,u,a,h=0,l=0;const f=v.compute(t,n),p=v.compute(t,e),m=f.x*f.x+f.y*f.y;if(r?(s=x(y(f.y*p.z-p.y*f.z,2)+y(f.z*p.x-p.z*f.x,2)+y(f.x*p.y-p.x*f.y,2)),o=y(m+f.z*f.z,1.5)):(s=f.x*p.y-f.y*p.x,o=y(m,1.5)),0===s||0===o)return{k:0,r:0};if(h=s/o,l=o/s,!i){const i=v.curvature(t-.001,n,e,r,!0).k,s=v.curvature(t+.001,n,e,r,!0).k;a=(s-h+(h-i))/2,u=(c(s-h)+c(h-i))/2}return{k:h,r:l,dk:a,adk:u}},inflections:function(t){if(t.length<4)return[];const n=v.align(t,{p1:t[0],p2:t.slice(-1)[0]}),e=n[2].x*n[1].y,r=n[3].x*n[1].y,i=n[1].x*n[2].y,s=18*(-3*e+2*r+3*i-n[3].x*n[2].y),o=18*(3*e-r-3*i),c=18*(i-e);if(v.approximately(s,0)){if(!v.approximately(o,0)){let t=-c/o;if(0<=t&&t<=1)return[t]}return[]}const u=2*s;if(v.approximately(u,0))return[];const a=o*o-4*s*c;if(a<0)return[];const h=Math.sqrt(a);return[(h-o)/u,-(o+h)/u].filter((function(t){return 0<=t&&t<=1}))},bboxoverlap:function(t,n){const e=[\"x\",\"y\"],r=e.length;for(let i,s,o,u,a=0;a<r;a++)if(i=e[a],s=t[i].mid,o=n[i].mid,u=(t[i].size+n[i].size)/2,c(s-o)>=u)return!1;return!0},expandbox:function(t,n){n.x.min<t.x.min&&(t.x.min=n.x.min),n.y.min<t.y.min&&(t.y.min=n.y.min),n.z&&n.z.min<t.z.min&&(t.z.min=n.z.min),n.x.max>t.x.max&&(t.x.max=n.x.max),n.y.max>t.y.max&&(t.y.max=n.y.max),n.z&&n.z.max>t.z.max&&(t.z.max=n.z.max),t.x.mid=(t.x.min+t.x.max)/2,t.y.mid=(t.y.min+t.y.max)/2,t.z&&(t.z.mid=(t.z.min+t.z.max)/2),t.x.size=t.x.max-t.x.min,t.y.size=t.y.max-t.y.min,t.z&&(t.z.size=t.z.max-t.z.min)},pairiteration:function(t,n,e){const r=t.bbox(),i=n.bbox(),s=1e5,o=e||.5;if(r.x.size+r.y.size<o&&i.x.size+i.y.size<o)return[(s*(t._t1+t._t2)/2|0)/s+\"/\"+(s*(n._t1+n._t2)/2|0)/s];let c=t.split(.5),u=n.split(.5),a=[{left:c.left,right:u.left},{left:c.left,right:u.right},{left:c.right,right:u.right},{left:c.right,right:u.left}];a=a.filter((function(t){return v.bboxoverlap(t.left.bbox(),t.right.bbox())}));let h=[];return 0===a.length||(a.forEach((function(t){h=h.concat(v.pairiteration(t.left,t.right,o))})),h=h.filter((function(t,n){return h.indexOf(t)===n}))),h},getccenter:function(t,n,e){const r=n.x-t.x,i=n.y-t.y,s=e.x-n.x,o=e.y-n.y,c=r*u(d)-i*a(d),h=r*a(d)+i*u(d),x=s*u(d)-o*a(d),y=s*a(d)+o*u(d),f=(t.x+n.x)/2,p=(t.y+n.y)/2,g=(n.x+e.x)/2,z=(n.y+e.y)/2,b=f+c,_=p+h,w=g+x,E=z+y,M=v.lli8(f,p,b,_,g,z,w,E),T=v.dist(M,t);let O,C=l(t.y-M.y,t.x-M.x),k=l(n.y-M.y,n.x-M.x),S=l(e.y-M.y,e.x-M.x);return C<S?((C>k||k>S)&&(C+=m),C>S&&(O=S,S=C,C=O)):S<k&&k<C?(O=S,S=C,C=O):S+=m,M.s=C,M.e=S,M.r=T,M},numberSort:function(t,n){return t-n}};class _{constructor(t){this.curves=[],this._3d=!1,t&&(this.curves=t,this._3d=this.curves[0]._3d)}valueOf(){return this.toString()}toString(){return\"[\"+this.curves.map((function(t){return v.pointsToString(t.points)})).join(\", \")+\"]\"}addCurve(t){this.curves.push(t),this._3d=this._3d||t._3d}length(){return this.curves.map((function(t){return t.length()})).reduce((function(t,n){return t+n}))}curve(t){return this.curves[t]}bbox(){const t=this.curves;for(var n=t[0].bbox(),e=1;e<t.length;e++)v.expandbox(n,t[e].bbox());return n}offset(t){const n=[];return this.curves.forEach((function(e){n.push(...e.offset(t))})),new _(n)}}const{abs:w,min:E,max:M,cos:T,sin:O,acos:C,sqrt:k}=Math,S=Math.PI;class I{constructor(t){let n=t&&t.forEach?t:Array.from(arguments).slice(),e=!1;if(\"object\"==typeof n[0]){e=n.length;const t=[];n.forEach((function(n){[\"x\",\"y\",\"z\"].forEach((function(e){void 0!==n[e]&&t.push(n[e])}))})),n=t}let r=!1;const i=n.length;if(e){if(e>4){if(1!==arguments.length)throw new Error(\"Only new Bezier(point[]) is accepted for 4th and higher order curves\");r=!0}}else if(6!==i&&8!==i&&9!==i&&12!==i&&1!==arguments.length)throw new Error(\"Only new Bezier(point[]) is accepted for 4th and higher order curves\");const s=this._3d=!r&&(9===i||12===i)||t&&t[0]&&void 0!==t[0].z,o=this.points=[];for(let t=0,e=s?3:2;t<i;t+=e){var c={x:n[t],y:n[t+1]};s&&(c.z=n[t+2]),o.push(c)}const u=this.order=o.length-1,a=this.dims=[\"x\",\"y\"];s&&a.push(\"z\"),this.dimlen=a.length;const h=v.align(o,{p1:o[0],p2:o[u]}),l=v.dist(o[0],o[u]);this._linear=h.reduce(((t,n)=>t+w(n.y)),0)<l/50,this._lut=[],this._t1=0,this._t2=1,this.update()}static quadraticFromPoints(t,n,e,r){if(void 0===r&&(r=.5),0===r)return new I(n,n,e);if(1===r)return new I(t,n,n);const i=I.getABC(2,t,n,e,r);return new I(t,i.A,e)}static cubicFromPoints(t,n,e,r,i){void 0===r&&(r=.5);const s=I.getABC(3,t,n,e,r);void 0===i&&(i=v.dist(n,s.C));const o=i*(1-r)/r,c=v.dist(t,e),u=(e.x-t.x)/c,a=(e.y-t.y)/c,h=i*u,l=i*a,x=o*u,y=o*a,f=n.x-h,p=n.y-l,m=n.x+x,d=n.y+y,g=s.A,z=g.x+(f-g.x)/(1-r),b=g.y+(p-g.y)/(1-r),_=g.x+(m-g.x)/r,w=g.y+(d-g.y)/r,E={x:t.x+(z-t.x)/r,y:t.y+(b-t.y)/r},M={x:e.x+(_-e.x)/(1-r),y:e.y+(w-e.y)/(1-r)};return new I(t,E,M,e)}static getUtils(){return v}getUtils(){return I.getUtils()}static get PolyBezier(){return _}valueOf(){return this.toString()}toString(){return v.pointsToString(this.points)}toSVG(){if(this._3d)return!1;const t=this.points,n=[\"M\",t[0].x,t[0].y,2===this.order?\"Q\":\"C\"];for(let e=1,r=t.length;e<r;e++)n.push(t[e].x),n.push(t[e].y);return n.join(\" \")}setRatios(t){if(t.length!==this.points.length)throw new Error(\"incorrect number of ratio values\");this.ratios=t,this._lut=[]}verify(){const t=this.coordDigest();t!==this._print&&(this._print=t,this.update())}coordDigest(){return this.points.map((function(t,n){return\"\"+n+t.x+t.y+(t.z?t.z:0)})).join(\"\")}update(){this._lut=[],this.dpoints=v.derive(this.points,this._3d),this.computedirection()}computedirection(){const t=this.points,n=v.angle(t[0],t[this.order],t[1]);this.clockwise=n>0}length(){return v.length(this.derivative.bind(this))}static getABC(t=2,n,e,r,i=.5){const s=v.projectionratio(i,t),o=1-s,c={x:s*n.x+o*r.x,y:s*n.y+o*r.y},u=v.abcratio(i,t);return{A:{x:e.x+(e.x-c.x)/u,y:e.y+(e.y-c.y)/u},B:e,C:c,S:n,E:r}}getABC(t,n){n=n||this.get(t);let e=this.points[0],r=this.points[this.order];return I.getABC(this.order,e,n,r,t)}getLUT(t){if(this.verify(),t=t||100,this._lut.length===t+1)return this._lut;this._lut=[],t++,this._lut=[];for(let n,e,r=0;r<t;r++)e=r/(t-1),n=this.compute(e),n.t=e,this._lut.push(n);return this._lut}on(n,e){e=e||5;const r=this.getLUT(),i=[];for(let t,s=0,o=0;s<r.length;s++)t=r[s],v.dist(t,n)<e&&(i.push(t),o+=s/r.length);return!!i.length&&(t/=i.length)}project(t){const n=this.getLUT(),e=n.length-1,r=v.closest(n,t),i=r.mpos,s=(i-1)/e,o=(i+1)/e,c=.1/e;let u,a=r.mdist,h=s,l=h;a+=1;for(let n;h<o+c;h+=c)u=this.compute(h),n=v.dist(t,u),n<a&&(a=n,l=h);return l=l<0?0:l>1?1:l,u=this.compute(l),u.t=l,u.d=a,u}get(t){return this.compute(t)}point(t){return this.points[t]}compute(t){return this.ratios?v.computeWithRatios(t,this.points,this.ratios,this._3d):v.compute(t,this.points,this._3d,this.ratios)}raise(){const t=this.points,n=[t[0]],e=t.length;for(let r,i,s=1;s<e;s++)r=t[s],i=t[s-1],n[s]={x:(e-s)/e*r.x+s/e*i.x,y:(e-s)/e*r.y+s/e*i.y};return n[e]=t[e-1],new I(n)}derivative(t){return v.compute(t,this.dpoints[0],this._3d)}dderivative(t){return v.compute(t,this.dpoints[1],this._3d)}align(){let t=this.points;return new I(v.align(t,{p1:t[0],p2:t[t.length-1]}))}curvature(t){return v.curvature(t,this.dpoints[0],this.dpoints[1],this._3d)}inflections(){return v.inflections(this.points)}normal(t){return this._3d?this.__normal3(t):this.__normal2(t)}__normal2(t){const n=this.derivative(t),e=k(n.x*n.x+n.y*n.y);return{t:t,x:-n.y/e,y:n.x/e}}__normal3(t){const n=this.derivative(t),e=this.derivative(t+.01),r=k(n.x*n.x+n.y*n.y+n.z*n.z),i=k(e.x*e.x+e.y*e.y+e.z*e.z);n.x/=r,n.y/=r,n.z/=r,e.x/=i,e.y/=i,e.z/=i;const s={x:e.y*n.z-e.z*n.y,y:e.z*n.x-e.x*n.z,z:e.x*n.y-e.y*n.x},o=k(s.x*s.x+s.y*s.y+s.z*s.z);s.x/=o,s.y/=o,s.z/=o;const c=[s.x*s.x,s.x*s.y-s.z,s.x*s.z+s.y,s.x*s.y+s.z,s.y*s.y,s.y*s.z-s.x,s.x*s.z-s.y,s.y*s.z+s.x,s.z*s.z];return{t:t,x:c[0]*n.x+c[1]*n.y+c[2]*n.z,y:c[3]*n.x+c[4]*n.y+c[5]*n.z,z:c[6]*n.x+c[7]*n.y+c[8]*n.z}}hull(t){let n=this.points,e=[],r=[],i=0;for(r[i++]=n[0],r[i++]=n[1],r[i++]=n[2],3===this.order&&(r[i++]=n[3]);n.length>1;){e=[];for(let s,o=0,c=n.length-1;o<c;o++)s=v.lerp(t,n[o],n[o+1]),r[i++]=s,e.push(s);n=e}return r}split(t,n){if(0===t&&n)return this.split(n).left;if(1===n)return this.split(t).right;const e=this.hull(t),r={left:2===this.order?new I([e[0],e[3],e[5]]):new I([e[0],e[4],e[7],e[9]]),right:2===this.order?new I([e[5],e[4],e[2]]):new I([e[9],e[8],e[6],e[3]]),span:e};return r.left._t1=v.map(0,0,1,this._t1,this._t2),r.left._t2=v.map(t,0,1,this._t1,this._t2),r.right._t1=v.map(t,0,1,this._t1,this._t2),r.right._t2=v.map(1,0,1,this._t1,this._t2),n?(n=v.map(n,t,1,0,1),r.right.split(n).left):r}extrema(){const t={};let n=[];return this.dims.forEach(function(e){let r=function(t){return t[e]},i=this.dpoints[0].map(r);t[e]=v.droots(i),3===this.order&&(i=this.dpoints[1].map(r),t[e]=t[e].concat(v.droots(i))),t[e]=t[e].filter((function(t){return t>=0&&t<=1})),n=n.concat(t[e].sort(v.numberSort))}.bind(this)),t.values=n.sort(v.numberSort).filter((function(t,e){return n.indexOf(t)===e})),t}bbox(){const t=this.extrema(),n={};return this.dims.forEach(function(e){n[e]=v.getminmax(this,e,t[e])}.bind(this)),n}overlaps(t){const n=this.bbox(),e=t.bbox();return v.bboxoverlap(n,e)}offset(t,n){if(void 0!==n){const e=this.get(t),r=this.normal(t),i={c:e,n:r,x:e.x+r.x*n,y:e.y+r.y*n};return this._3d&&(i.z=e.z+r.z*n),i}if(this._linear){const n=this.normal(0),e=this.points.map((function(e){const r={x:e.x+t*n.x,y:e.y+t*n.y};return e.z&&n.z&&(r.z=e.z+t*n.z),r}));return[new I(e)]}return this.reduce().map((function(n){return n._linear?n.offset(t)[0]:n.scale(t)}))}simple(){if(3===this.order){const t=v.angle(this.points[0],this.points[3],this.points[1]),n=v.angle(this.points[0],this.points[3],this.points[2]);if(t>0&&n<0||t<0&&n>0)return!1}const t=this.normal(0),n=this.normal(1);let e=t.x*n.x+t.y*n.y;return this._3d&&(e+=t.z*n.z),w(C(e))<S/3}reduce(){let t,n,e=0,r=0,i=.01,s=[],o=[],c=this.extrema().values;for(-1===c.indexOf(0)&&(c=[0].concat(c)),-1===c.indexOf(1)&&c.push(1),e=c[0],t=1;t<c.length;t++)r=c[t],n=this.split(e,r),n._t1=e,n._t2=r,s.push(n),e=r;return s.forEach((function(t){for(e=0,r=0;r<=1;)for(r=e+i;r<=1.01;r+=i)if(n=t.split(e,r),!n.simple()){if(r-=i,w(e-r)<i)return[];n=t.split(e,r),n._t1=v.map(e,0,1,t._t1,t._t2),n._t2=v.map(r,0,1,t._t1,t._t2),o.push(n),e=r;break}e<1&&(n=t.split(e,1),n._t1=v.map(e,0,1,t._t1,t._t2),n._t2=t._t2,o.push(n))})),o}translate(t,n,e){e=\"number\"==typeof e?e:n;const r=this.order;let i=this.points.map(((t,i)=>(1-i/r)*n+i/r*e));return new I(this.points.map(((n,e)=>({x:n.x+t.x*i[e],y:n.y+t.y*i[e]}))))}scale(t){const n=this.order;let e=!1;if(\"function\"==typeof t&&(e=t),e&&2===n)return this.raise().scale(e);const r=this.clockwise,i=this.points;if(this._linear)return this.translate(this.normal(0),e?e(0):t,e?e(1):t);const s=e?e(0):t,o=e?e(1):t,c=[this.offset(0,10),this.offset(1,10)],u=[],a=v.lli4(c[0],c[0].c,c[1],c[1].c);if(!a)throw new Error(\"cannot scale this curve. Try reducing it first.\");return[0,1].forEach((function(t){const e=u[t*n]=v.copy(i[t*n]);e.x+=(t?o:s)*c[t].n.x,e.y+=(t?o:s)*c[t].n.y})),e?([0,1].forEach((function(s){if(2!==n||!s){var o=i[s+1],c={x:o.x-a.x,y:o.y-a.y},h=e?e((s+1)/n):t;e&&!r&&(h=-h);var l=k(c.x*c.x+c.y*c.y);c.x/=l,c.y/=l,u[s+1]={x:o.x+h*c.x,y:o.y+h*c.y}}})),new I(u)):([0,1].forEach((t=>{if(2===n&&t)return;const e=u[t*n],r=this.derivative(t),s={x:e.x+r.x,y:e.y+r.y};u[t+1]=v.lli4(e,s,a,i[t+1])})),new I(u))}outline(t,n,e,r){if(n=void 0===n?t:n,this._linear){const i=this.normal(0),s=this.points[0],o=this.points[this.points.length-1];let c,u,a;void 0===e&&(e=t,r=n),c={x:s.x+i.x*t,y:s.y+i.y*t},a={x:o.x+i.x*e,y:o.y+i.y*e},u={x:(c.x+a.x)/2,y:(c.y+a.y)/2};const h=[c,u,a];c={x:s.x-i.x*n,y:s.y-i.y*n},a={x:o.x-i.x*r,y:o.y-i.y*r},u={x:(c.x+a.x)/2,y:(c.y+a.y)/2};const l=[a,u,c],x=v.makeline(l[2],h[0]),y=v.makeline(h[2],l[0]),f=[x,new I(h),y,new I(l)];return new _(f)}const i=this.reduce(),s=i.length,o=[];let c,u=[],a=0,h=this.length();const l=void 0!==e&&void 0!==r;function x(t,n,e,r,i){return function(s){const o=r/e,c=(r+i)/e,u=n-t;return v.map(s,0,1,t+o*u,t+c*u)}}i.forEach((function(i){const s=i.length();l?(o.push(i.scale(x(t,e,h,a,s))),u.push(i.scale(x(-n,-r,h,a,s)))):(o.push(i.scale(t)),u.push(i.scale(-n))),a+=s})),u=u.map((function(t){return c=t.points,c[3]?t.points=[c[3],c[2],c[1],c[0]]:t.points=[c[2],c[1],c[0]],t})).reverse();const y=o[0].points[0],f=o[s-1].points[o[s-1].points.length-1],p=u[s-1].points[u[s-1].points.length-1],m=u[0].points[0],d=v.makeline(p,y),g=v.makeline(f,m),z=[d].concat(o).concat([g]).concat(u);return new _(z)}outlineshapes(t,n,e){n=n||t;const r=this.outline(t,n).curves,i=[];for(let t=1,n=r.length;t<n/2;t++){const s=v.makeshape(r[t],r[n-t],e);s.startcap.virtual=t>1,s.endcap.virtual=t<n/2-1,i.push(s)}return i}intersects(t,n){return t?t.p1&&t.p2?this.lineIntersects(t):(t instanceof I&&(t=t.reduce()),this.curveintersects(this.reduce(),t,n)):this.selfintersects(n)}lineIntersects(t){const n=E(t.p1.x,t.p2.x),e=E(t.p1.y,t.p2.y),r=M(t.p1.x,t.p2.x),i=M(t.p1.y,t.p2.y);return v.roots(this.points,t).filter((t=>{var s=this.get(t);return v.between(s.x,n,r)&&v.between(s.y,e,i)}))}selfintersects(t){const n=this.reduce(),e=n.length-2,r=[];for(let i,s,o,c=0;c<e;c++)s=n.slice(c,c+1),o=n.slice(c+2),i=this.curveintersects(s,o,t),r.push(...i);return r}curveintersects(t,n,e){const r=[];t.forEach((function(t){n.forEach((function(n){t.overlaps(n)&&r.push({left:t,right:n})}))}));let i=[];return r.forEach((function(t){const n=v.pairiteration(t.left,t.right,e);n.length>0&&(i=i.concat(n))})),i}arcs(t){return t=t||.5,this._iterate(t,[])}_error(t,n,e,r){const i=(r-e)/4,s=this.get(e+i),o=this.get(r-i),c=v.dist(t,n),u=v.dist(t,s),a=v.dist(t,o);return w(u-c)+w(a-c)}_iterate(t,n){let e,r=0,i=1;do{e=0,i=1;let s,o,c,u,a,h=this.get(r),l=!1,x=!1,y=i,f=1;do{if(x=l,u=c,y=(r+i)/2,s=this.get(y),o=this.get(i),c=v.getccenter(h,s,o),c.interval={start:r,end:i},l=this._error(c,h,r,i)<=t,a=x&&!l,a||(f=i),l){if(i>=1){if(c.interval.end=f=1,u=c,i>1){let t={x:c.x+c.r*T(c.e),y:c.y+c.r*O(c.e)};c.e+=v.angle({x:c.x,y:c.y},t,this.get(1))}break}i+=(i-r)/2}else i=y}while(!a&&e++<100);if(e>=100)break;u=u||c,n.push(u),r=f}while(i<1);return n}}const B={name:\"perspective\",execute:t=>{const n=[],e=(t,n,e,r)=>{if(t===n)return e/r;const i=1-(1/(1+e/r*(t/n-1))*t-n)/(t-n);return Math.min(1,Math.max(0,i))};return t.regionBoundaryCurves.forEach(((r,i)=>{const s=[];r.forEach(((n,r)=>{const c=[],u=n,a={tl:u.top.points[0],tr:u.top.points[3],bl:u.bottom.points[0],br:u.bottom.points[3]};if((t=>{const n=o.calcIntersection(t.tl,t.tr,t.bl,t.br),e=o.calcIntersection(t.tl,t.bl,t.tr,t.br),r=n=>n&&Object.values(t).some(((t,e,r)=>o.isTriangleContainsPoint(n,r[e],r[(e+1)%4],r[(e+2)%4])));return r(n)||r(e)})(a))throw new Error(\"[Warpvas: Perspective] Invalid perspective shape: The four control points cannot form a triangle or cross each other\");const h={left:new I(u.left.points).length(),right:new I(u.right.points).length(),top:new I(u.top.points).length(),bottom:new I(u.bottom.points).length()},l=o.calcIntersection(a.tl,a.bl,a.tr,a.br),x=o.calcIntersection(a.tl,a.tr,a.bl,a.br),{vertical:y,horizontal:f}=t.regionCurves[i][r],p=f.length-1,m=y.length-1;for(let t=0;t<f.length;t++)for(let n=0;n<y.length;n++){let r=u.top.get(n/m),i=u.bottom.get(n/m);if(x){const t=o.calcCoordDistance(a.tl,x)/o.calcCoordDistance(a.tr,x),s=e(h.left,h.left/t,n,m);r=u.top.get(s);const c=o.calcCoordDistance(a.bl,x)/o.calcCoordDistance(a.br,x),l=e(h.left,h.left/c,n,m);i=u.bottom.get(l)}let s=u.left.get(t/p),y=u.right.get(t/p);if(l){const n=o.calcCoordDistance(a.tl,l)/o.calcCoordDistance(a.bl,l),r=e(h.top,h.top/n,t,p);s=u.left.get(r);const i=o.calcCoordDistance(a.tr,l)/o.calcCoordDistance(a.br,l),c=e(h.top,h.top/i,t,p);y=u.right.get(c)}const f=o.calcIntersection(r,i,s,y);f?c.push(f):c.push(r)}s.push(c)})),n.push(s)})),n}};export{B as default};\n//# sourceMappingURL=index.esm.js.map\n","import { Warpvas } from 'warpvas';\nimport perspective from '@warpvas/perspective';\n\nconst main = async function () {\n  const image = new Image();\n  image.onload = () => {\n    const { naturalHeight: height } = image;\n    const warpvas = new Warpvas(image);\n    warpvas.setOutputLimitSize({ height: 300 });\n    warpvas.setSplitStrategy(perspective)\n    warpvas.setRenderingConfig({\n      enableGridDisplay: true,\n    })\n    warpvas.updateVertexCoord(0, 0, 'tl', { x: 0, y: height / 3 });\n    warpvas.updateVertexCoord(0, 0, 'bl', { x: 0, y: height / 3 * 2 });\n    document.body.appendChild(warpvas.render());\n  };\n  image.crossOrigin = \"Anonymous\";\n  image.src = \"https://i.imgur.com/pBVj9NN.png\";\n};\n\nmain();\n"],"names":["e","t","i","n","Promise","r","o","s","h","next","a","throw","done","value","then","apply","SuppressedError","x","y","Math","sqrt","pow","Object","assign","sign","freeze","__proto__","calcBoundingBox","min","max","width","height","calcCoordDistance","calcExpandCoord","c","u","calcIntersection","abs","round","calcMatrix","reduce","map","Number","l","f","p","m","d","g","z","b","calcPerpendicularIntersection","calcRelativeCoord","isTriangleContainsPoint","TOP_LEFT","TOP_RIGHT","BOTTOM_LEFT","BOTTOM_RIGHT","TOP","BOTTOM","LEFT","RIGHT","async","image","Image","onload","naturalHeight","warpvas","Warpvas","setOutputLimitSize","setSplitStrategy","perspective","setRenderingConfig","enableGridDisplay","updateVertexCoord","document","body","appendChild","render","crossOrigin","src","main"],"mappings":"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","x_google_ignoreList":[0]}