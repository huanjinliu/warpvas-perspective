!function(t,e){t&&!t.getElementById("livereloadscript")&&((e=t.createElement("script")).async=1,e.src="//"+(self.location.host||"localhost").split(":")[0]+":35729/livereload.js?snipver=1",e.id="livereloadscript",t.getElementsByTagName("head")[0].appendChild(e))}(self.document),function(){"use strict";function e(t,e,n,i){return new(n||(n=Promise))((function(r,o){function s(t){try{c(i.next(t))}catch(t){o(t)}}function a(t){try{c(i.throw(t))}catch(t){o(t)}}function c(t){var e;t.done?r(t.value):(e=t.value,e instanceof n?e:new n((function(t){t(e)}))).then(s,a)}c((i=i.apply(t,e||[])).next())}))}"function"==typeof SuppressedError&&SuppressedError;const{abs:n,cos:i,sin:r,acos:o,atan2:s,sqrt:a,pow:c}=Math;function h(t){return t<0?-c(-t,1/3):c(t,1/3)}const l=Math.PI,u=2*l,x=l/2,p=Number.MAX_SAFE_INTEGER||9007199254740991,f=Number.MIN_SAFE_INTEGER||-9007199254740991,y={x:0,y:0,z:0},g={Tvalues:[-.06405689286260563,.06405689286260563,-.1911188674736163,.1911188674736163,-.3150426796961634,.3150426796961634,-.4337935076260451,.4337935076260451,-.5454214713888396,.5454214713888396,-.6480936519369755,.6480936519369755,-.7401241915785544,.7401241915785544,-.820001985973903,.820001985973903,-.8864155270044011,.8864155270044011,-.9382745520027328,.9382745520027328,-.9747285559713095,.9747285559713095,-.9951872199970213,.9951872199970213],Cvalues:[.12793819534675216,.12793819534675216,.1258374563468283,.1258374563468283,.12167047292780339,.12167047292780339,.1155056680537256,.1155056680537256,.10744427011596563,.10744427011596563,.09761865210411388,.09761865210411388,.08619016153195327,.08619016153195327,.0733464814110803,.0733464814110803,.05929858491543678,.05929858491543678,.04427743881741981,.04427743881741981,.028531388628933663,.028531388628933663,.0123412297999872,.0123412297999872],arcfn:function(t,e){const n=e(t);let i=n.x*n.x+n.y*n.y;return void 0!==n.z&&(i+=n.z*n.z),a(i)},compute:function(t,e,n){if(0===t)return e[0].t=0,e[0];const i=e.length-1;if(1===t)return e[i].t=1,e[i];const r=1-t;let o=e;if(0===i)return e[0].t=t,e[0];if(1===i){const e={x:r*o[0].x+t*o[1].x,y:r*o[0].y+t*o[1].y,t:t};return n&&(e.z=r*o[0].z+t*o[1].z),e}if(i<4){let e,s,a,c=r*r,h=t*t,l=0;2===i?(o=[o[0],o[1],o[2],y],e=c,s=r*t*2,a=h):3===i&&(e=c*r,s=c*t*3,a=r*h*3,l=t*h);const u={x:e*o[0].x+s*o[1].x+a*o[2].x+l*o[3].x,y:e*o[0].y+s*o[1].y+a*o[2].y+l*o[3].y,t:t};return n&&(u.z=e*o[0].z+s*o[1].z+a*o[2].z+l*o[3].z),u}const s=JSON.parse(JSON.stringify(e));for(;s.length>1;){for(let e=0;e<s.length-1;e++)s[e]={x:s[e].x+(s[e+1].x-s[e].x)*t,y:s[e].y+(s[e+1].y-s[e].y)*t},void 0!==s[e].z&&(s[e].z=s[e].z+(s[e+1].z-s[e].z)*t);s.splice(s.length-1,1)}return s[0].t=t,s[0]},computeWithRatios:function(t,e,n,i){const r=1-t,o=n,s=e;let a,c=o[0],h=o[1],l=o[2],u=o[3];return c*=r,h*=t,2===s.length?(a=c+h,{x:(c*s[0].x+h*s[1].x)/a,y:(c*s[0].y+h*s[1].y)/a,z:!!i&&(c*s[0].z+h*s[1].z)/a,t:t}):(c*=r,h*=2*r,l*=t*t,3===s.length?(a=c+h+l,{x:(c*s[0].x+h*s[1].x+l*s[2].x)/a,y:(c*s[0].y+h*s[1].y+l*s[2].y)/a,z:!!i&&(c*s[0].z+h*s[1].z+l*s[2].z)/a,t:t}):(c*=r,h*=1.5*r,l*=3*r,u*=t*t*t,4===s.length?(a=c+h+l+u,{x:(c*s[0].x+h*s[1].x+l*s[2].x+u*s[3].x)/a,y:(c*s[0].y+h*s[1].y+l*s[2].y+u*s[3].y)/a,z:!!i&&(c*s[0].z+h*s[1].z+l*s[2].z+u*s[3].z)/a,t:t}):void 0))},derive:function(t,e){const n=[];for(let i=t,r=i.length,o=r-1;r>1;r--,o--){const t=[];for(let n,r=0;r<o;r++)n={x:o*(i[r+1].x-i[r].x),y:o*(i[r+1].y-i[r].y)},e&&(n.z=o*(i[r+1].z-i[r].z)),t.push(n);n.push(t),i=t}return n},between:function(t,e,n){return e<=t&&t<=n||g.approximately(t,e)||g.approximately(t,n)},approximately:function(t,e,i){return n(t-e)<=(i||1e-6)},length:function(t){const e=g.Tvalues.length;let n=0;for(let i,r=0;r<e;r++)i=.5*g.Tvalues[r]+.5,n+=g.Cvalues[r]*g.arcfn(i,t);return.5*n},map:function(t,e,n,i,r){return i+(t-e)/(n-e)*(r-i)},lerp:function(t,e,n){const i={x:e.x+t*(n.x-e.x),y:e.y+t*(n.y-e.y)};return void 0!==e.z&&void 0!==n.z&&(i.z=e.z+t*(n.z-e.z)),i},pointToString:function(t){let e=t.x+"/"+t.y;return void 0!==t.z&&(e+="/"+t.z),e},pointsToString:function(t){return"["+t.map(g.pointToString).join(", ")+"]"},copy:function(t){return JSON.parse(JSON.stringify(t))},angle:function(t,e,n){const i=e.x-t.x,r=e.y-t.y,o=n.x-t.x,a=n.y-t.y;return s(i*a-r*o,i*o+r*a)},round:function(t,e){const n=""+t,i=n.indexOf(".");return parseFloat(n.substring(0,i+1+e))},dist:function(t,e){const n=t.x-e.x,i=t.y-e.y;return a(n*n+i*i)},closest:function(t,e){let n,i,r=c(2,63);return t.forEach((function(t,o){i=g.dist(e,t),i<r&&(r=i,n=o)})),{mdist:r,mpos:n}},abcratio:function(t,e){if(2!==e&&3!==e)return!1;if(void 0===t)t=.5;else if(0===t||1===t)return t;const i=c(t,e)+c(1-t,e);return n((i-1)/i)},projectionratio:function(t,e){if(2!==e&&3!==e)return!1;if(void 0===t)t=.5;else if(0===t||1===t)return t;const n=c(1-t,e);return n/(c(t,e)+n)},lli8:function(t,e,n,i,r,o,s,a){const c=(t-n)*(o-a)-(e-i)*(r-s);return 0!=c&&{x:((t*i-e*n)*(r-s)-(t-n)*(r*a-o*s))/c,y:((t*i-e*n)*(o-a)-(e-i)*(r*a-o*s))/c}},lli4:function(t,e,n,i){const r=t.x,o=t.y,s=e.x,a=e.y,c=n.x,h=n.y,l=i.x,u=i.y;return g.lli8(r,o,s,a,c,h,l,u)},lli:function(t,e){return g.lli4(t,t.c,e,e.c)},makeline:function(t,e){return new T(t.x,t.y,(t.x+e.x)/2,(t.y+e.y)/2,e.x,e.y)},findbbox:function(t){let e=p,n=p,i=f,r=f;return t.forEach((function(t){const o=t.bbox();e>o.x.min&&(e=o.x.min),n>o.y.min&&(n=o.y.min),i<o.x.max&&(i=o.x.max),r<o.y.max&&(r=o.y.max)})),{x:{min:e,mid:(e+i)/2,max:i,size:i-e},y:{min:n,mid:(n+r)/2,max:r,size:r-n}}},shapeintersections:function(t,e,n,i,r){if(!g.bboxoverlap(e,i))return[];const o=[],s=[t.startcap,t.forward,t.back,t.endcap],a=[n.startcap,n.forward,n.back,n.endcap];return s.forEach((function(e){e.virtual||a.forEach((function(i){if(i.virtual)return;const s=e.intersects(i,r);s.length>0&&(s.c1=e,s.c2=i,s.s1=t,s.s2=n,o.push(s))}))})),o},makeshape:function(t,e,n){const i=e.points.length,r=t.points.length,o=g.makeline(e.points[i-1],t.points[0]),s=g.makeline(t.points[r-1],e.points[0]),a={startcap:o,forward:t,back:e,endcap:s,bbox:g.findbbox([o,t,e,s]),intersections:function(t){return g.shapeintersections(a,a.bbox,t,t.bbox,n)}};return a},getminmax:function(t,e,n){if(!n)return{min:0,max:0};let i,r,o=p,s=f;-1===n.indexOf(0)&&(n=[0].concat(n)),-1===n.indexOf(1)&&n.push(1);for(let a=0,c=n.length;a<c;a++)i=n[a],r=t.get(i),r[e]<o&&(o=r[e]),r[e]>s&&(s=r[e]);return{min:o,mid:(o+s)/2,max:s,size:s-o}},align:function(t,e){const n=e.p1.x,o=e.p1.y,a=-s(e.p2.y-o,e.p2.x-n);return t.map((function(t){return{x:(t.x-n)*i(a)-(t.y-o)*r(a),y:(t.x-n)*r(a)+(t.y-o)*i(a)}}))},roots:function(t,e){e=e||{p1:{x:0,y:0},p2:{x:1,y:0}};const n=t.length-1,r=g.align(t,e),s=function(t){return 0<=t&&t<=1};if(2===n){const t=r[0].y,e=r[1].y,n=r[2].y,i=t-2*e+n;if(0!==i){const r=-a(e*e-t*n),o=-t+e;return[-(r+o)/i,-(-r+o)/i].filter(s)}return e!==n&&0===i?[(2*e-n)/(2*e-2*n)].filter(s):[]}const c=r[0].y,l=r[1].y,x=r[2].y;let p=3*l-c-3*x+r[3].y,f=3*c-6*l+3*x,y=-3*c+3*l,d=c;if(g.approximately(p,0)){if(g.approximately(f,0))return g.approximately(y,0)?[]:[-d/y].filter(s);const t=a(y*y-4*f*d),e=2*f;return[(t-y)/e,(-y-t)/e].filter(s)}f/=p,y/=p,d/=p;const m=(3*y-f*f)/3,v=m/3,b=(2*f*f*f-9*f*y+27*d)/27,_=b/2,z=_*_+v*v*v;let w,E,C,T,S;if(z<0){const t=-m/3,e=a(t*t*t),n=-b/(2*e),r=o(n<-1?-1:n>1?1:n),c=2*h(e);return C=c*i(r/3)-f/3,T=c*i((r+u)/3)-f/3,S=c*i((r+2*u)/3)-f/3,[C,T,S].filter(s)}if(0===z)return w=_<0?h(-_):-h(_),C=2*w-f/3,T=-w-f/3,[C,T].filter(s);{const t=a(z);return w=h(-_+t),E=h(_+t),[w-E-f/3].filter(s)}},droots:function(t){if(3===t.length){const e=t[0],n=t[1],i=t[2],r=e-2*n+i;if(0!==r){const t=-a(n*n-e*i),o=-e+n;return[-(t+o)/r,-(-t+o)/r]}return n!==i&&0===r?[(2*n-i)/(2*(n-i))]:[]}if(2===t.length){const e=t[0],n=t[1];return e!==n?[e/(e-n)]:[]}return[]},curvature:function(t,e,i,r,o){let s,h,l,u,x=0,p=0;const f=g.compute(t,e),y=g.compute(t,i),d=f.x*f.x+f.y*f.y;if(r?(s=a(c(f.y*y.z-y.y*f.z,2)+c(f.z*y.x-y.z*f.x,2)+c(f.x*y.y-y.x*f.y,2)),h=c(d+f.z*f.z,1.5)):(s=f.x*y.y-f.y*y.x,h=c(d,1.5)),0===s||0===h)return{k:0,r:0};if(x=s/h,p=h/s,!o){const o=g.curvature(t-.001,e,i,r,!0).k,s=g.curvature(t+.001,e,i,r,!0).k;u=(s-x+(x-o))/2,l=(n(s-x)+n(x-o))/2}return{k:x,r:p,dk:u,adk:l}},inflections:function(t){if(t.length<4)return[];const e=g.align(t,{p1:t[0],p2:t.slice(-1)[0]}),n=e[2].x*e[1].y,i=e[3].x*e[1].y,r=e[1].x*e[2].y,o=18*(-3*n+2*i+3*r-e[3].x*e[2].y),s=18*(3*n-i-3*r),a=18*(r-n);if(g.approximately(o,0)){if(!g.approximately(s,0)){let t=-a/s;if(0<=t&&t<=1)return[t]}return[]}const c=2*o;if(g.approximately(c,0))return[];const h=s*s-4*o*a;if(h<0)return[];const l=Math.sqrt(h);return[(l-s)/c,-(s+l)/c].filter((function(t){return 0<=t&&t<=1}))},bboxoverlap:function(t,e){const i=["x","y"],r=i.length;for(let o,s,a,c,h=0;h<r;h++)if(o=i[h],s=t[o].mid,a=e[o].mid,c=(t[o].size+e[o].size)/2,n(s-a)>=c)return!1;return!0},expandbox:function(t,e){e.x.min<t.x.min&&(t.x.min=e.x.min),e.y.min<t.y.min&&(t.y.min=e.y.min),e.z&&e.z.min<t.z.min&&(t.z.min=e.z.min),e.x.max>t.x.max&&(t.x.max=e.x.max),e.y.max>t.y.max&&(t.y.max=e.y.max),e.z&&e.z.max>t.z.max&&(t.z.max=e.z.max),t.x.mid=(t.x.min+t.x.max)/2,t.y.mid=(t.y.min+t.y.max)/2,t.z&&(t.z.mid=(t.z.min+t.z.max)/2),t.x.size=t.x.max-t.x.min,t.y.size=t.y.max-t.y.min,t.z&&(t.z.size=t.z.max-t.z.min)},pairiteration:function(t,e,n){const i=t.bbox(),r=e.bbox(),o=1e5,s=n||.5;if(i.x.size+i.y.size<s&&r.x.size+r.y.size<s)return[(o*(t._t1+t._t2)/2|0)/o+"/"+(o*(e._t1+e._t2)/2|0)/o];let a=t.split(.5),c=e.split(.5),h=[{left:a.left,right:c.left},{left:a.left,right:c.right},{left:a.right,right:c.right},{left:a.right,right:c.left}];h=h.filter((function(t){return g.bboxoverlap(t.left.bbox(),t.right.bbox())}));let l=[];return 0===h.length||(h.forEach((function(t){l=l.concat(g.pairiteration(t.left,t.right,s))})),l=l.filter((function(t,e){return l.indexOf(t)===e}))),l},getccenter:function(t,e,n){const o=e.x-t.x,a=e.y-t.y,c=n.x-e.x,h=n.y-e.y,l=o*i(x)-a*r(x),p=o*r(x)+a*i(x),f=c*i(x)-h*r(x),y=c*r(x)+h*i(x),d=(t.x+e.x)/2,m=(t.y+e.y)/2,v=(e.x+n.x)/2,b=(e.y+n.y)/2,_=d+l,z=m+p,w=v+f,E=b+y,C=g.lli8(d,m,_,z,v,b,w,E),T=g.dist(C,t);let S,R=s(t.y-C.y,t.x-C.x),P=s(e.y-C.y,e.x-C.x),M=s(n.y-C.y,n.x-C.x);return R<M?((R>P||P>M)&&(R+=u),R>M&&(S=M,M=R,R=S)):M<P&&P<R?(S=M,M=R,R=S):M+=u,C.s=R,C.e=M,C.r=T,C},numberSort:function(t,e){return t-e}};let d=class t{constructor(t){this.curves=[],this._3d=!1,t&&(this.curves=t,this._3d=this.curves[0]._3d)}valueOf(){return this.toString()}toString(){return"["+this.curves.map((function(t){return g.pointsToString(t.points)})).join(", ")+"]"}addCurve(t){this.curves.push(t),this._3d=this._3d||t._3d}length(){return this.curves.map((function(t){return t.length()})).reduce((function(t,e){return t+e}))}curve(t){return this.curves[t]}bbox(){const t=this.curves;for(var e=t[0].bbox(),n=1;n<t.length;n++)g.expandbox(e,t[n].bbox());return e}offset(e){const n=[];return this.curves.forEach((function(t){n.push(...t.offset(e))})),new t(n)}};const{abs:m,min:v,max:b,cos:_,sin:z,acos:w,sqrt:E}=Math,C=Math.PI;let T=class e{constructor(t){let e=t&&t.forEach?t:Array.from(arguments).slice(),n=!1;if("object"==typeof e[0]){n=e.length;const t=[];e.forEach((function(e){["x","y","z"].forEach((function(n){void 0!==e[n]&&t.push(e[n])}))})),e=t}let i=!1;const r=e.length;if(n){if(n>4){if(1!==arguments.length)throw new Error("Only new Bezier(point[]) is accepted for 4th and higher order curves");i=!0}}else if(6!==r&&8!==r&&9!==r&&12!==r&&1!==arguments.length)throw new Error("Only new Bezier(point[]) is accepted for 4th and higher order curves");const o=this._3d=!i&&(9===r||12===r)||t&&t[0]&&void 0!==t[0].z,s=this.points=[];for(let t=0,n=o?3:2;t<r;t+=n){var a={x:e[t],y:e[t+1]};o&&(a.z=e[t+2]),s.push(a)}const c=this.order=s.length-1,h=this.dims=["x","y"];o&&h.push("z"),this.dimlen=h.length;const l=g.align(s,{p1:s[0],p2:s[c]}),u=g.dist(s[0],s[c]);this._linear=l.reduce(((t,e)=>t+m(e.y)),0)<u/50,this._lut=[],this._t1=0,this._t2=1,this.update()}static quadraticFromPoints(t,n,i,r){if(void 0===r&&(r=.5),0===r)return new e(n,n,i);if(1===r)return new e(t,n,n);const o=e.getABC(2,t,n,i,r);return new e(t,o.A,i)}static cubicFromPoints(t,n,i,r,o){void 0===r&&(r=.5);const s=e.getABC(3,t,n,i,r);void 0===o&&(o=g.dist(n,s.C));const a=o*(1-r)/r,c=g.dist(t,i),h=(i.x-t.x)/c,l=(i.y-t.y)/c,u=o*h,x=o*l,p=a*h,f=a*l,y=n.x-u,d=n.y-x,m=n.x+p,v=n.y+f,b=s.A,_=b.x+(y-b.x)/(1-r),z=b.y+(d-b.y)/(1-r),w=b.x+(m-b.x)/r,E=b.y+(v-b.y)/r,C={x:t.x+(_-t.x)/r,y:t.y+(z-t.y)/r},T={x:i.x+(w-i.x)/(1-r),y:i.y+(E-i.y)/(1-r)};return new e(t,C,T,i)}static getUtils(){return g}getUtils(){return e.getUtils()}static get PolyBezier(){return d}valueOf(){return this.toString()}toString(){return g.pointsToString(this.points)}toSVG(){if(this._3d)return!1;const t=this.points,e=["M",t[0].x,t[0].y,2===this.order?"Q":"C"];for(let n=1,i=t.length;n<i;n++)e.push(t[n].x),e.push(t[n].y);return e.join(" ")}setRatios(t){if(t.length!==this.points.length)throw new Error("incorrect number of ratio values");this.ratios=t,this._lut=[]}verify(){const t=this.coordDigest();t!==this._print&&(this._print=t,this.update())}coordDigest(){return this.points.map((function(t,e){return""+e+t.x+t.y+(t.z?t.z:0)})).join("")}update(){this._lut=[],this.dpoints=g.derive(this.points,this._3d),this.computedirection()}computedirection(){const t=this.points,e=g.angle(t[0],t[this.order],t[1]);this.clockwise=e>0}length(){return g.length(this.derivative.bind(this))}static getABC(t=2,e,n,i,r=.5){const o=g.projectionratio(r,t),s=1-o,a={x:o*e.x+s*i.x,y:o*e.y+s*i.y},c=g.abcratio(r,t);return{A:{x:n.x+(n.x-a.x)/c,y:n.y+(n.y-a.y)/c},B:n,C:a,S:e,E:i}}getABC(t,n){n=n||this.get(t);let i=this.points[0],r=this.points[this.order];return e.getABC(this.order,i,n,r,t)}getLUT(t){if(this.verify(),t=t||100,this._lut.length===t+1)return this._lut;this._lut=[],t++,this._lut=[];for(let e,n,i=0;i<t;i++)n=i/(t-1),e=this.compute(n),e.t=n,this._lut.push(e);return this._lut}on(e,n){n=n||5;const i=this.getLUT(),r=[];for(let t,o=0,s=0;o<i.length;o++)t=i[o],g.dist(t,e)<n&&(r.push(t),s+=o/i.length);return!!r.length&&(t/=r.length)}project(t){const e=this.getLUT(),n=e.length-1,i=g.closest(e,t),r=i.mpos,o=(r-1)/n,s=(r+1)/n,a=.1/n;let c,h=i.mdist,l=o,u=l;h+=1;for(let e;l<s+a;l+=a)c=this.compute(l),e=g.dist(t,c),e<h&&(h=e,u=l);return u=u<0?0:u>1?1:u,c=this.compute(u),c.t=u,c.d=h,c}get(t){return this.compute(t)}point(t){return this.points[t]}compute(t){return this.ratios?g.computeWithRatios(t,this.points,this.ratios,this._3d):g.compute(t,this.points,this._3d,this.ratios)}raise(){const t=this.points,n=[t[0]],i=t.length;for(let e,r,o=1;o<i;o++)e=t[o],r=t[o-1],n[o]={x:(i-o)/i*e.x+o/i*r.x,y:(i-o)/i*e.y+o/i*r.y};return n[i]=t[i-1],new e(n)}derivative(t){return g.compute(t,this.dpoints[0],this._3d)}dderivative(t){return g.compute(t,this.dpoints[1],this._3d)}align(){let t=this.points;return new e(g.align(t,{p1:t[0],p2:t[t.length-1]}))}curvature(t){return g.curvature(t,this.dpoints[0],this.dpoints[1],this._3d)}inflections(){return g.inflections(this.points)}normal(t){return this._3d?this.__normal3(t):this.__normal2(t)}__normal2(t){const e=this.derivative(t),n=E(e.x*e.x+e.y*e.y);return{t:t,x:-e.y/n,y:e.x/n}}__normal3(t){const e=this.derivative(t),n=this.derivative(t+.01),i=E(e.x*e.x+e.y*e.y+e.z*e.z),r=E(n.x*n.x+n.y*n.y+n.z*n.z);e.x/=i,e.y/=i,e.z/=i,n.x/=r,n.y/=r,n.z/=r;const o={x:n.y*e.z-n.z*e.y,y:n.z*e.x-n.x*e.z,z:n.x*e.y-n.y*e.x},s=E(o.x*o.x+o.y*o.y+o.z*o.z);o.x/=s,o.y/=s,o.z/=s;const a=[o.x*o.x,o.x*o.y-o.z,o.x*o.z+o.y,o.x*o.y+o.z,o.y*o.y,o.y*o.z-o.x,o.x*o.z-o.y,o.y*o.z+o.x,o.z*o.z];return{t:t,x:a[0]*e.x+a[1]*e.y+a[2]*e.z,y:a[3]*e.x+a[4]*e.y+a[5]*e.z,z:a[6]*e.x+a[7]*e.y+a[8]*e.z}}hull(t){let e=this.points,n=[],i=[],r=0;for(i[r++]=e[0],i[r++]=e[1],i[r++]=e[2],3===this.order&&(i[r++]=e[3]);e.length>1;){n=[];for(let o,s=0,a=e.length-1;s<a;s++)o=g.lerp(t,e[s],e[s+1]),i[r++]=o,n.push(o);e=n}return i}split(t,n){if(0===t&&n)return this.split(n).left;if(1===n)return this.split(t).right;const i=this.hull(t),r={left:2===this.order?new e([i[0],i[3],i[5]]):new e([i[0],i[4],i[7],i[9]]),right:2===this.order?new e([i[5],i[4],i[2]]):new e([i[9],i[8],i[6],i[3]]),span:i};return r.left._t1=g.map(0,0,1,this._t1,this._t2),r.left._t2=g.map(t,0,1,this._t1,this._t2),r.right._t1=g.map(t,0,1,this._t1,this._t2),r.right._t2=g.map(1,0,1,this._t1,this._t2),n?(n=g.map(n,t,1,0,1),r.right.split(n).left):r}extrema(){const t={};let e=[];return this.dims.forEach(function(n){let i=function(t){return t[n]},r=this.dpoints[0].map(i);t[n]=g.droots(r),3===this.order&&(r=this.dpoints[1].map(i),t[n]=t[n].concat(g.droots(r))),t[n]=t[n].filter((function(t){return t>=0&&t<=1})),e=e.concat(t[n].sort(g.numberSort))}.bind(this)),t.values=e.sort(g.numberSort).filter((function(t,n){return e.indexOf(t)===n})),t}bbox(){const t=this.extrema(),e={};return this.dims.forEach(function(n){e[n]=g.getminmax(this,n,t[n])}.bind(this)),e}overlaps(t){const e=this.bbox(),n=t.bbox();return g.bboxoverlap(e,n)}offset(t,n){if(void 0!==n){const e=this.get(t),i=this.normal(t),r={c:e,n:i,x:e.x+i.x*n,y:e.y+i.y*n};return this._3d&&(r.z=e.z+i.z*n),r}if(this._linear){const n=this.normal(0),i=this.points.map((function(e){const i={x:e.x+t*n.x,y:e.y+t*n.y};return e.z&&n.z&&(i.z=e.z+t*n.z),i}));return[new e(i)]}return this.reduce().map((function(e){return e._linear?e.offset(t)[0]:e.scale(t)}))}simple(){if(3===this.order){const t=g.angle(this.points[0],this.points[3],this.points[1]),e=g.angle(this.points[0],this.points[3],this.points[2]);if(t>0&&e<0||t<0&&e>0)return!1}const t=this.normal(0),e=this.normal(1);let n=t.x*e.x+t.y*e.y;return this._3d&&(n+=t.z*e.z),m(w(n))<C/3}reduce(){let t,e,n=0,i=0,r=.01,o=[],s=[],a=this.extrema().values;for(-1===a.indexOf(0)&&(a=[0].concat(a)),-1===a.indexOf(1)&&a.push(1),n=a[0],t=1;t<a.length;t++)i=a[t],e=this.split(n,i),e._t1=n,e._t2=i,o.push(e),n=i;return o.forEach((function(t){for(n=0,i=0;i<=1;)for(i=n+r;i<=1.01;i+=r)if(e=t.split(n,i),!e.simple()){if(i-=r,m(n-i)<r)return[];e=t.split(n,i),e._t1=g.map(n,0,1,t._t1,t._t2),e._t2=g.map(i,0,1,t._t1,t._t2),s.push(e),n=i;break}n<1&&(e=t.split(n,1),e._t1=g.map(n,0,1,t._t1,t._t2),e._t2=t._t2,s.push(e))})),s}translate(t,n,i){i="number"==typeof i?i:n;const r=this.order;let o=this.points.map(((t,e)=>(1-e/r)*n+e/r*i));return new e(this.points.map(((e,n)=>({x:e.x+t.x*o[n],y:e.y+t.y*o[n]}))))}scale(t){const n=this.order;let i=!1;if("function"==typeof t&&(i=t),i&&2===n)return this.raise().scale(i);const r=this.clockwise,o=this.points;if(this._linear)return this.translate(this.normal(0),i?i(0):t,i?i(1):t);const s=i?i(0):t,a=i?i(1):t,c=[this.offset(0,10),this.offset(1,10)],h=[],l=g.lli4(c[0],c[0].c,c[1],c[1].c);if(!l)throw new Error("cannot scale this curve. Try reducing it first.");return[0,1].forEach((function(t){const e=h[t*n]=g.copy(o[t*n]);e.x+=(t?a:s)*c[t].n.x,e.y+=(t?a:s)*c[t].n.y})),i?([0,1].forEach((function(e){if(2!==n||!e){var s=o[e+1],a={x:s.x-l.x,y:s.y-l.y},c=i?i((e+1)/n):t;i&&!r&&(c=-c);var u=E(a.x*a.x+a.y*a.y);a.x/=u,a.y/=u,h[e+1]={x:s.x+c*a.x,y:s.y+c*a.y}}})),new e(h)):([0,1].forEach((t=>{if(2===n&&t)return;const e=h[t*n],i=this.derivative(t),r={x:e.x+i.x,y:e.y+i.y};h[t+1]=g.lli4(e,r,l,o[t+1])})),new e(h))}outline(t,n,i,r){if(n=void 0===n?t:n,this._linear){const o=this.normal(0),s=this.points[0],a=this.points[this.points.length-1];let c,h,l;void 0===i&&(i=t,r=n),c={x:s.x+o.x*t,y:s.y+o.y*t},l={x:a.x+o.x*i,y:a.y+o.y*i},h={x:(c.x+l.x)/2,y:(c.y+l.y)/2};const u=[c,h,l];c={x:s.x-o.x*n,y:s.y-o.y*n},l={x:a.x-o.x*r,y:a.y-o.y*r},h={x:(c.x+l.x)/2,y:(c.y+l.y)/2};const x=[l,h,c],p=g.makeline(x[2],u[0]),f=g.makeline(u[2],x[0]),y=[p,new e(u),f,new e(x)];return new d(y)}const o=this.reduce(),s=o.length,a=[];let c,h=[],l=0,u=this.length();const x=void 0!==i&&void 0!==r;function p(t,e,n,i,r){return function(o){const s=i/n,a=(i+r)/n,c=e-t;return g.map(o,0,1,t+s*c,t+a*c)}}o.forEach((function(e){const o=e.length();x?(a.push(e.scale(p(t,i,u,l,o))),h.push(e.scale(p(-n,-r,u,l,o)))):(a.push(e.scale(t)),h.push(e.scale(-n))),l+=o})),h=h.map((function(t){return c=t.points,c[3]?t.points=[c[3],c[2],c[1],c[0]]:t.points=[c[2],c[1],c[0]],t})).reverse();const f=a[0].points[0],y=a[s-1].points[a[s-1].points.length-1],m=h[s-1].points[h[s-1].points.length-1],v=h[0].points[0],b=g.makeline(m,f),_=g.makeline(y,v),z=[b].concat(a).concat([_]).concat(h);return new d(z)}outlineshapes(t,e,n){e=e||t;const i=this.outline(t,e).curves,r=[];for(let t=1,e=i.length;t<e/2;t++){const o=g.makeshape(i[t],i[e-t],n);o.startcap.virtual=t>1,o.endcap.virtual=t<e/2-1,r.push(o)}return r}intersects(t,n){return t?t.p1&&t.p2?this.lineIntersects(t):(t instanceof e&&(t=t.reduce()),this.curveintersects(this.reduce(),t,n)):this.selfintersects(n)}lineIntersects(t){const e=v(t.p1.x,t.p2.x),n=v(t.p1.y,t.p2.y),i=b(t.p1.x,t.p2.x),r=b(t.p1.y,t.p2.y);return g.roots(this.points,t).filter((t=>{var o=this.get(t);return g.between(o.x,e,i)&&g.between(o.y,n,r)}))}selfintersects(t){const e=this.reduce(),n=e.length-2,i=[];for(let r,o,s,a=0;a<n;a++)o=e.slice(a,a+1),s=e.slice(a+2),r=this.curveintersects(o,s,t),i.push(...r);return i}curveintersects(t,e,n){const i=[];t.forEach((function(t){e.forEach((function(e){t.overlaps(e)&&i.push({left:t,right:e})}))}));let r=[];return i.forEach((function(t){const e=g.pairiteration(t.left,t.right,n);e.length>0&&(r=r.concat(e))})),r}arcs(t){return t=t||.5,this._iterate(t,[])}_error(t,e,n,i){const r=(i-n)/4,o=this.get(n+r),s=this.get(i-r),a=g.dist(t,e),c=g.dist(t,o),h=g.dist(t,s);return m(c-a)+m(h-a)}_iterate(t,e){let n,i=0,r=1;do{n=0,r=1;let o,s,a,c,h,l=this.get(i),u=!1,x=!1,p=r,f=1;do{if(x=u,c=a,p=(i+r)/2,o=this.get(p),s=this.get(r),a=g.getccenter(l,o,s),a.interval={start:i,end:r},u=this._error(a,l,i,r)<=t,h=x&&!u,h||(f=r),u){if(r>=1){if(a.interval.end=f=1,c=a,r>1){let t={x:a.x+a.r*_(a.e),y:a.y+a.r*z(a.e)};a.e+=g.angle({x:a.x,y:a.y},t,this.get(1))}break}r+=(r-i)/2}else r=p}while(!h&&n++<100);if(n>=100)break;c=c||a,e.push(c),i=f}while(r<1);return e}};const S=(t,e,n)=>{if(t.x===e.x)return{x:t.x,y:n.y};if(t.y===e.y)return{x:n.x,y:t.y};const i=(e.y-t.y)/(e.x-t.x),r=-1/i,o=(-i*t.x+t.y+r*n.x-n.y)/(r-i);return{x:o,y:i*(o-t.x)+t.y}},R=(t,e)=>Math.sqrt(Math.pow(e.x-t.x,2)+Math.pow(e.y-t.y,2)),P=(t,e,n)=>{const i=Math.min(t.x,e.x,n.x),r=Math.max(t.x,e.x,n.x),o=Math.min(t.y,e.y,n.y);return{width:r-i,height:Math.max(t.y,e.y,n.y)-o}},M=(t,e,n)=>{const i=Object.assign({},t),r={x:e.x-t.x,y:e.y-t.y};if(0===r.x&&0===r.y)return i;if(0===r.x)i.y+=n*Math.sign(r.y);else if(0===r.y)i.x+=n*Math.sign(r.x);else{const t=Math.sqrt(Math.pow(r.x,2)+Math.pow(r.y,2));i.x+=r.x*(n/t),i.y+=r.y*(n/t)}return i},O=(t,e)=>{const[n,i,r]=t,[o,s,a]=e,c=.1/Math.abs([...t,...e].reduce(((t,e)=>Math.min(t,e.x,e.y)),-1)),h=(t,e,n)=>{const[i,r,o,s]=t.map(Number),[a,c,h,l]=e.map(Number),[u,x,p,f]=n.map(Number),y=o-r*h/c,g=h-c*p/x,d=l-c*f/x,m=a-c*u/x,v=(y/g*d-(s-r*l/c))/(y/g*m-(i-r*a/c)),b=(d-m*v)/g;return{x:v,y:(s-i*v-o*b)/r,z:b}},l=[o.x+c,o.y+c,1,n.x+c],u=[s.x+c,s.y+c,1,i.x+c],x=[a.x+c,a.y+c,1,r.x+c],p=h(l,u,x);l[3]=n.y+c,u[3]=i.y+c,x[3]=r.y+c;const f=h(l,u,x),y=p.x,g=p.y,d=p.z;return[y,f.x,g,f.y,d,f.z]},B=(t,e,n,i,r=.1)=>{const o=(t,e,n)=>Math.abs(t.x*(e.y-n.y)+e.x*(n.y-t.y)+n.x*(t.y-e.y))/2,s=o(e,n,i);return o(e,n,t)+o(n,i,t)+o(i,e,t)<=s+r},I=(t,e,n,i,r)=>{var o;const{x:s,y:a,sourceScale:c=1,destinationScale:h=1}=i,{gridColor:l={r:255,g:0,b:0,a:1},enableContentDisplay:u=!0,enableGridDisplay:x=!1,enableGridVertexDisplay:p=!1}=null!==(o=t.renderingConfig)&&void 0!==o?o:{},{calcBoundingBox:f,calcPerpendicularIntersection:y,calcCoordDistance:g,calcRelativeCoord:d,calcMatrix:m}=r,v=(t,e,n,i=1)=>{const r=y(e,n,t),o=g(t,r),s=d(t,r,o+i);return{x:s.x-r.x+e.x,y:s.y-r.y+e.y}},b=n.getContext("2d");b.clearRect(0,0,n.width,n.height);const _=Math.ceil(1/(c*h));b.save(),b.transform(c*h,0,0,c*h,s*c*h,a*c*h);const z=(t,n,i,r,o,s,a)=>{const h=[t,i,o],y=new Path2D;for(let t=0;t<3;t++){const e=h[t],n=h[(t+1)%3],i=h[(t+2)%3],r=v(e,n,i,_),o=v(e,i,n,_);y.lineTo(r.x,r.y),y.lineTo(o.x,o.y)}if(u){b.save(),b.clip(y);const h=m([t,i,o],[n,r,s]);b.transform(...h);const l=f(n,r,s),u=(a.x-1)*c,x=(a.y-1)*c,p=(l.width+2)*c,g=(l.height+2)*c,d=a.x-1/c,v=a.y-1/c,_=l.width+2/c,z=l.height+2/c;b.drawImage(e,u,x,p,g,d,v,_,z),b.restore()}if(p){const e=Math.floor(2/c);b.fillStyle=`rgba(${l.r}, ${l.g}, ${l.b}, ${l.a})`,b.fillRect(t.x-e/2,t.y-e/2,e,e)}if(x){const t=Math.floor(1/c);b.lineWidth=t,b.strokeStyle="rgba(255, 0, 0, 0.5)",b.stroke(y)}};return t.regionPoints.forEach(((e,n)=>{e.forEach(((e,i)=>{const r=e,o=t.regionCurves[n][i].vertical.length-1;r.forEach(((e,s)=>{const a=r[s],c=r[s+1],h=r[s+o+2],l=r[s+o+1],u=t.originalRegionPoints[n][i][s],x=t.originalRegionPoints[n][i][s+1],p=t.originalRegionPoints[n][i][s+o+2],f=t.originalRegionPoints[n][i][s+o+1];c&&h&&s%(o+1)<o&&(z(a,u,c,x,l,f,u),z(h,p,c,x,l,f,u))}))}))})),b.restore(),n},A=(t,e,n,i)=>{const{width:r,height:o,sourceScale:s=1,destinationScale:a=1}=i;return(n=null!=n?n:document.createElement("canvas")).width=r*a*s,n.height=o*a*s,I(t,e,n,i,{calcBoundingBox:P,calcPerpendicularIntersection:S,calcCoordDistance:R,calcRelativeCoord:M,calcMatrix:O})},L=(t,e,n,i)=>{var r;const{x:o,y:s,width:a,height:c,sourceScale:h=1}=i,{enableAntialias:l=!0,gridColor:u={r:255,g:0,b:0,a:1},enableContentDisplay:x=!0,enableGridDisplay:p=!1,enableGridVertexDisplay:f=!1}=null!==(r=t.renderingConfig)&&void 0!==r?r:{},{width:y,height:g}=e,d=n.getContext("webgl",{antialias:l});if(!d)throw Error("[Warpvas] Failed to initialize WebGL. Your browser or device may not support it.");const m={before:[],after:[]};t.regionPoints.forEach(((e,n)=>{e.forEach(((e,i)=>{const r=e,o=t.regionCurves[n][i].vertical.length-1;r.forEach(((e,s)=>{const a=r[s],c=r[s+1],h=r[s+o+2],l=r[s+o+1],u=t.originalRegionPoints[n][i][s],x=t.originalRegionPoints[n][i][s+1],p=t.originalRegionPoints[n][i][s+o+2],f=t.originalRegionPoints[n][i][s+o+1];c&&h&&s%(o+1)<o&&(m.before.push(u,x,f,p,x,f),m.after.push(a,c,l,h,c,l))}))}))}));const v="\n      attribute vec4 aVertexPosition;\n      attribute vec2 aTextureCoord;\n      varying highp vec2 vTextureCoord;\n      void main(void) {\n          gl_Position = aVertexPosition;\n          gl_PointSize = 2.0;\n          vTextureCoord = aTextureCoord;\n      }\n  ",b=(t,e)=>{const n=d.createShader(t);return n?(d.shaderSource(n,e),d.compileShader(n),d.getShaderParameter(n,d.COMPILE_STATUS)?n:(console.error("[Warpvas] Shader compilation error:",d.getShaderInfoLog(n)),d.deleteShader(n),null)):(console.error("[Warpvas] Failed to create shader."),null)},_=(t,e)=>{const n=b(d.VERTEX_SHADER,t);if(!n)return console.error("[Warpvas] Failed to initialize vertex shader."),null;const i=b(d.FRAGMENT_SHADER,e);if(!i)return console.error("[Warpvas] Failed to initialize fragment shader."),null;const r=d.createProgram();return r?(d.attachShader(r,n),d.attachShader(r,i),d.linkProgram(r),d.getProgramParameter(r,d.LINK_STATUS)?r:(console.error("[Warpvas] Shader program linking error:",d.getProgramInfoLog(r)),null)):(console.error("[Warpvas] Failed to create shader program."),null)},z=t=>!(t&t-1),w=_(v,"\n      varying highp vec2 vTextureCoord;\n      uniform sampler2D uSampler;\n      void main(void) {\n          gl_FragColor = texture2D(uSampler, vTextureCoord);\n      }\n  ");if(!w)throw Error("[Warpvas] Failed to initialize shader program.");const E={program:w,attribLocations:{vertexPosition:d.getAttribLocation(w,"aVertexPosition"),textureCoord:d.getAttribLocation(w,"aTextureCoord")},uniformLocations:{uSampler:d.getUniformLocation(w,"uSampler")}},C=d.createTexture();if(!C)throw Error("[Warpvas] Failed to create WebGL texture object.");return d.bindTexture(d.TEXTURE_2D,C),d.texImage2D(d.TEXTURE_2D,0,d.RGBA,d.RGBA,d.UNSIGNED_BYTE,e),z(e.width)&&z(e.height)&&d.generateMipmap(d.TEXTURE_2D),d.enable(d.BLEND),d.blendFunc(d.SRC_ALPHA,d.ONE_MINUS_SRC_ALPHA),d.texParameteri(d.TEXTURE_2D,d.TEXTURE_WRAP_S,d.CLAMP_TO_EDGE),d.texParameteri(d.TEXTURE_2D,d.TEXTURE_WRAP_T,d.CLAMP_TO_EDGE),d.texParameteri(d.TEXTURE_2D,d.TEXTURE_MIN_FILTER,d.LINEAR),d.viewport(0,0,n.width,n.height),((t,e,n)=>{d.clearColor(0,0,0,0),d.clear(d.COLOR_BUFFER_BIT);const i=d.FLOAT,r=!1,o=4*Float32Array.BYTES_PER_ELEMENT;d.bindBuffer(d.ARRAY_BUFFER,e.position),d.vertexAttribPointer(t.attribLocations.vertexPosition,2,i,r,o,0),d.enableVertexAttribArray(t.attribLocations.vertexPosition),d.bindBuffer(d.ARRAY_BUFFER,e.textureCoord),d.vertexAttribPointer(t.attribLocations.textureCoord,2,i,r,o,0),d.enableVertexAttribArray(t.attribLocations.textureCoord),d.useProgram(t.program),d.activeTexture(d.TEXTURE0),d.bindTexture(d.TEXTURE_2D,n),d.uniform1i(t.uniformLocations.uSampler,0),x&&d.drawArrays(d.TRIANGLES,0,m.before.length);const{r:s,g:a,b:c,a:h}=u,l=`${(s/255).toFixed(1)}, ${(a/255).toFixed(1)}, ${(c/255).toFixed(1)}, ${h.toFixed(1)}`,y=_(v,`\n      void main(void) {\n        gl_FragColor = vec4(${l});\n      }\n    `);if(!y)throw Error("[Warpvas] Failed to initialize outline shader program.");d.bindBuffer(d.ARRAY_BUFFER,e.position),d.vertexAttribPointer(d.getAttribLocation(y,"aVertexPosition"),2,i,r,0,0),d.enableVertexAttribArray(d.getAttribLocation(y,"aVertexPosition")),d.bindBuffer(d.ARRAY_BUFFER,e.textureCoord),d.vertexAttribPointer(d.getAttribLocation(y,"aTextureCoord"),2,i,r,0,0),d.enableVertexAttribArray(d.getAttribLocation(y,"aTextureCoord")),d.useProgram(y),p&&d.drawArrays(d.LINES,0,2*m.before.length),f&&d.drawArrays(d.POINTS,0,2*m.before.length)})(E,(()=>{const t=d.createBuffer();d.bindBuffer(d.ARRAY_BUFFER,t);const e=m.before.map(((t,e)=>{const n=[t.x/(y/h),t.y/(g/h)];return(e+1)%3==0?n.push(m.before[e-2].x/(y/h),m.before[e-2].y/(g/h)):n.push(m.before[e+1].x/(y/h),m.before[e+1].y/(g/h)),n})).flat(1);d.bufferData(d.ARRAY_BUFFER,new Float32Array(e),d.STATIC_DRAW);const n=d.createBuffer();d.bindBuffer(d.ARRAY_BUFFER,n);const i=m.after.map(((t,e)=>{const n=[(t.x+o)/(a/2)-1,-((t.y+s)/(c/2)-1)];return(e+1)%3==0?n.push((m.after[e-2].x+o)/(a/2)-1,-((m.after[e-2].y+s)/(c/2)-1)):n.push((m.after[e+1].x+o)/(a/2)-1,-((m.after[e+1].y+s)/(c/2)-1)),n})).flat(1);return d.bufferData(d.ARRAY_BUFFER,new Float32Array(i),d.STATIC_DRAW),{position:n,textureCoord:t}})(),C),n},F=(t,e,n,i)=>{const{width:r,height:o,sourceScale:s=1,destinationScale:a=1}=i;return(n=null!=n?n:document.createElement("canvas")).width=r*a*s,n.height=o*a*s,L(t,e,n,i)},D="WORKER_MESSAGE",k="JOB_RESULT",U=t=>t instanceof ArrayBuffer||t instanceof MessagePort||self.ImageBitmap&&t instanceof ImageBitmap,N=()=>{const t=[];let e,n=new Map;const i={collect:t=>{for(let e in t)n.set(e,t[e]);return i},onMessage:t=>(e=t,i),create:i=>{const r=i.toString(),o=`\n        // 将收集到的变量声明和定义加入脚本字符串，后面函数执行的时候便不会出现not defined的错误了\n        $collections = {};\n        ${Object.entries(Object.fromEntries(n)).reduce(((t,[e,n])=>t+`$collections['${e}']=`+("function"==typeof n?`${n};`:`JSON.parse(\`${JSON.stringify(n)}\`);`)),"")}\n  \n        // 声明定义用于判断是否是可转移对象的函数\n        $isTransferables = ${U}\n  \n        // 在脚本中声明并定义一个包含工作流程的函数体\n        $job=${r};\n  \n        // 给worker线程添加消息监听，等待主线程的发号施令\n        onmessage=e=>{\n          const { index, args } = e.data;\n  \n          Promise.resolve(\n            $job.apply($job, args.concat([{\n              collections: $collections,\n              postMessage: (message) => postMessage({ type: '${D}', message }),\n              close: self.close,\n            }]))\n          ).then(result => {\n            postMessage({ type: '${k}', message: { index, result } }, [result].filter($isTransferables))\n          }).catch(error => {\n            postMessage({ type: '${k}', message: { index, error } })\n          })\n        }\n      `,s=URL.createObjectURL(new Blob([o],{type:"text/javascript"})),a=new Worker(s);return a.onmessage=function(n){const i=n.data;if(i.type===D&&e&&e.call(e,i.message),i.type===k){const{index:e,result:n,error:r}=i.message,{done:o}=t[e];o(r,n)}},{run:(...e)=>new Promise(((n,i)=>{const r=t.length;t.push({done:(t,e)=>{t?i(t):n(e)}}),a.postMessage({index:r,args:e},e.filter(U))})),terminate:()=>{a.terminate(),URL.revokeObjectURL(s),t.length=0,n.clear(),e=void 0}}}};return i},W=(t,n,i,r)=>e(void 0,void 0,void 0,(function*(){const{regionPoints:e,renderingConfig:o,regionCurves:s,originalRegionPoints:a}=t,c={renderingConfig:o,regionCurves:s.map((t=>t.map((t=>({horizontal:{length:t.horizontal.length},vertical:{length:t.vertical.length}}))))),regionPoints:e,originalRegionPoints:a},h=N().collect({warpvas:c,options:r,createWarpedCanvas:I,calcBoundingBox:P,calcPerpendicularIntersection:S,calcCoordDistance:R,calcRelativeCoord:M,calcMatrix:O}).create(((t,{collections:e})=>{const{options:n,warpvas:i,createWarpedCanvas:r,calcBoundingBox:o,calcPerpendicularIntersection:s,calcCoordDistance:a,calcRelativeCoord:c,calcMatrix:h}=e,{width:l,height:u,sourceScale:x=1,destinationScale:p=1}=n,f=new OffscreenCanvas(l*p*x,u*p*x),y=new OffscreenCanvas(t.width,t.height),g=y.getContext("2d");return null==g||g.putImageData(t,0,0),r(i,y,f,n,{calcBoundingBox:o,calcPerpendicularIntersection:s,calcCoordDistance:a,calcRelativeCoord:c,calcMatrix:h}).transferToImageBitmap()})),l=yield h.run(n);return h.terminate(),(i=null!=i?i:document.createElement("canvas")).width=l.width,i.height=l.height,i.getContext("2d").drawImage(l,0,0),i})),G=(t,n,i,r)=>e(void 0,void 0,void 0,(function*(){const{regionPoints:e,renderingConfig:o,regionCurves:s,originalRegionPoints:a}=t,c={renderingConfig:o,regionCurves:s.map((t=>t.map((t=>({horizontal:{length:t.horizontal.length},vertical:{length:t.vertical.length}}))))),regionPoints:e,originalRegionPoints:a},h=N().collect({warpvas:c,options:r,createWarpedCanvas:L}).create(((t,{collections:e})=>{const{options:n,warpvas:i,createWarpedCanvas:r}=e,{width:o,height:s,sourceScale:a=1,destinationScale:c=1}=n;return r(i,t,new OffscreenCanvas(o*c*a,s*c*a),n).transferToImageBitmap()})),l=yield h.run(n);return h.terminate(),(i=null!=i?i:document.createElement("canvas")).width=l.width,i.height=l.height,i.getContext("2d").drawImage(l,0,0),i}));var j,H;!function(t){t.TOP_LEFT="tl",t.TOP_RIGHT="tr",t.BOTTOM_LEFT="bl",t.BOTTOM_RIGHT="br"}(j||(j={})),function(t){t.TOP="top",t.BOTTOM="bottom",t.LEFT="left",t.RIGHT="right"}(H||(H={}));class ${constructor(t,e=1,n=1){if(this.splitPoints=[],this.originalRegions=[],this.originalRegionPoints=[],this.regionBoundaryCurves=[],this.regionCurves=[],this.regionPoints=[],this.splitUnit=.05,this.splitStrategy={name:"default",execute:$.strategy},this.renderingContext="webgl",this.renderingConfig={padding:0,enableAntialias:!0,enableSafeRendering:!0,enableContentDisplay:!0,enableGridDisplay:!1,enableGridVertexDisplay:!1,gridColor:{r:255,g:0,b:0,a:1}},this._safeModeEnabled=!1,this._cacheSourceSize=null,this._cacheSourceImageData=null,this._cacheInputCanvas=null,this._cacheOutputCanvas=null,this._inputLimitScale=1,this._outputLimitScale=1,!(t instanceof HTMLCanvasElement||t instanceof HTMLImageElement))throw new TypeError("[Warpvas] source must be either HTMLCanvasElement or HTMLImageElement!");if(t instanceof HTMLImageElement){const e=document.createElement("canvas"),n=e.getContext("2d");if(!n)throw new Error("Failed to get 2D rendering context for canvas");e.width=t.naturalWidth,e.height=t.naturalHeight,n.drawImage(t,0,0),this.source=e}else this.source=t;this.splitPoints=this._initializeSplitPoints(e,n),this.setWarpState(this.splitPoints)}get maxSplitUnitPixel(){return this.splitUnit*this.source.width}get scale(){return{x:this._inputLimitScale*this._outputLimitScale,y:this._inputLimitScale*this._outputLimitScale}}static strategy(t){if(!t.regionCurves)return[];const e=[];return t.regionBoundaryCurves.forEach(((n,i)=>{const r=[];n.forEach(((e,n)=>{const o=[],{vertical:s,horizontal:a}=t.regionCurves[i][n];for(let t=0;t<a.length;t++)for(let e=0;e<s.length;e++){const n=s[e].get(t/(a.length-1)),i=a[t].get(e/(s.length-1));o.push({x:(n.x+i.x)/2,y:(n.y+i.y)/2})}r.push(o)})),e.push(r)})),e}static serializeWarpState(t){const{splitPoints:e,regionBounds:n}=t,i=[e.length,n.length,n[0].length];e.forEach((t=>{i.push(t.x,t.y)}));const r=["top","right","bottom","left"];n.forEach((t=>t.forEach((t=>[r.forEach((e=>t[e].forEach((t=>{i.push(t.x,t.y)}))))]))));const o=new Float32Array(i),s=new Uint8Array(o.buffer);return btoa(String.fromCharCode.apply(null,s))}static deserializeWarpState(t){const e=atob(t),n=new Uint8Array(e.length);for(let t=0;t<e.length;t++)n[t]=e.charCodeAt(t);const i=new Float32Array(n.buffer),r=Array.from(i),o=["top","right","bottom","left"],s=r[0],a=r[1],c=r[2];let h=3;const l=[];for(let t=0;t<s;t++)l.push({x:r[h],y:r[h+1]}),h+=2;const u=[];for(let t=0;t<a;t++){const t=[];for(let e=0;e<c;e++){const e={};for(const t of o){e[t]=[];for(let n=0;n<4;n++)e[t].push({x:r[h],y:r[h+1]}),h+=2}t.push(e)}u.push(t)}return{splitPoints:l,regionBounds:u}}_initializeSplitPoints(t=1,e=1){const n=Math.max(Math.floor(t),1),i=Math.max(Math.floor(e),1),r=[];for(let o=1;o<n;o++)for(let n=1;n<i;n++)o===n&&r.push({x:n/e,y:o/t});return r}_initializeOriginalRegions(){const{width:t,height:e}=this.source;let n=[],i=[];this.splitPoints.forEach((t=>{t.x<0||t.x>1||t.y<0||t.y>1||(n.push(t.x),i.push(t.y))})),n=[...new Set([0,...n,1])],i=[...new Set([0,...i,1])],n.sort(((t,e)=>t-e)),i.sort(((t,e)=>t-e));const r=[];for(let o=0;o<i.length-1;o++){r.push([]);for(let s=0;s<n.length-1;s++)r[r.length-1].push({tl:{x:n[s]*t,y:i[o]*e},tr:{x:n[s+1]*t,y:i[o]*e},bl:{x:n[s]*t,y:i[o+1]*e},br:{x:n[s+1]*t,y:i[o+1]*e}})}return r}_calculateSamplingPoints(t){const e=t.tr.x-t.tl.x,n=t.bl.y-t.tl.y,i=Math.max(Math.ceil(e/this.maxSplitUnitPixel),1)+1,r=Math.max(Math.ceil(n/this.maxSplitUnitPixel),1)+1;return{hts:Array.from({length:i}).map(((t,e)=>e/(i-1))),vts:Array.from({length:r}).map(((t,e)=>e/(r-1)))}}_initializeOriginalRegionPoints(){return this.originalRegions.map((t=>t.map((t=>{const{hts:e,vts:n}=this._calculateSamplingPoints(t),i=[],{tl:r,tr:o,bl:s}=t,a=o.x-r.x,c=s.y-r.y;for(let t=0;t<n.length;t++)for(let o=0;o<e.length;o++)i.push({x:r.x+a*e[o],y:r.y+c*n[t]});return i}))))}_initializeBoundaryControlPoints(t){const e=[];return t.forEach((t=>{e.push([]),t.forEach((t=>{const{tl:n,tr:i,br:r,bl:o}=t,s={top:[n,i],bottom:[o,r],left:[n,o],right:[i,r]},a={};for(const t in s){const[e,n]=s[t];a[t]=[e,{x:e.x+1*(n.x-e.x)/3,y:e.y+1*(n.y-e.y)/3},{x:n.x-1*(n.x-e.x)/3,y:n.y-1*(n.y-e.y)/3},n]}e[e.length-1].push(a)}))})),e}_generateRegionCurves(t,e,n){const i={horizontal:[],vertical:[]};return e.forEach((e=>{if(0===e)return void i.vertical.push(t.left);if(1===e)return void i.vertical.push(t.right);const n=t.top.get(e),r=t.bottom.get(e),o=new T([n,{x:n.x+((t.left.points[1].x-t.left.points[0].x)*(1-e)+(t.right.points[1].x-t.right.points[0].x)*e),y:n.y+((t.left.points[1].y-t.left.points[0].y)*(1-e)+(t.right.points[1].y-t.right.points[0].y)*e)},{x:r.x+((t.left.points[2].x-t.left.points[3].x)*(1-e)+(t.right.points[2].x-t.right.points[3].x)*e),y:r.y+((t.left.points[2].y-t.left.points[3].y)*(1-e)+(t.right.points[2].y-t.right.points[3].y)*e)},r]);i.vertical.push(o)})),n.forEach((e=>{if(0===e)return void i.horizontal.push(t.top);if(1===e)return void i.horizontal.push(t.bottom);const n=t.left.get(e),r=t.right.get(e),o=new T([n,{x:n.x+((t.top.points[1].x-t.top.points[0].x)*(1-e)+(t.bottom.points[1].x-t.bottom.points[0].x)*e),y:n.y+((t.top.points[1].y-t.top.points[0].y)*(1-e)+(t.bottom.points[1].y-t.bottom.points[0].y)*e)},{x:r.x+((t.top.points[2].x-t.top.points[3].x)*(1-e)+(t.bottom.points[2].x-t.bottom.points[3].x)*e),y:r.y+((t.top.points[2].y-t.top.points[3].y)*(1-e)+(t.bottom.points[2].y-t.bottom.points[3].y)*e)},r]);i.horizontal.push(o)})),i}_generateAllRegionCurves(t){const e=[];return t.forEach(((t,n)=>{const i=[];e.push(i),t.forEach(((t,e)=>{const r=t,o=this.originalRegions[n][e],{hts:s,vts:a}=this._calculateSamplingPoints(o);i.push(this._generateRegionCurves(r,s,a))}))})),e}setSplitUnit(t){return this.splitUnit=t<=0?1:Math.min(1,t),this.originalRegionPoints=this._initializeOriginalRegionPoints(),this}setSplitStrategy(t){return this.splitStrategy=t,this}setInputLimitSize(t){return this._inputLimitSize=t,t||(this._inputLimitScale=1,this._cacheInputCanvas=null),this._cacheSourceImageData=null,this}setOutputLimitSize(t){return this._outputLimitSize=t,t||(this._outputLimitScale=1),this}setRenderingContext(t){return this.renderingContext=t,this}setRenderingCanvas(t){return this._cacheOutputCanvas=t,this}setRenderingConfig(t){return this.renderingConfig=Object.assign(Object.assign({},this.renderingConfig),t),this}getBoundingBoxInfo(){const{padding:t}=this.renderingConfig,e=this.regionCurves.length,n=this.regionCurves[0].length,i={left:1/0,right:-1/0,top:1/0,bottom:-1/0};for(let t=0;t<e;t++)for(let e=0;e<n;e++){const n=this.regionCurves[t][e];Object.values(n).forEach((t=>{const e=t.length;for(let n=0;n<e;n++){const e=t[n].bbox();i.left=Math.min(i.left,e.x.min),i.right=Math.max(i.right,e.x.max),i.top=Math.min(i.top,e.y.min),i.bottom=Math.max(i.bottom,e.y.max)}}))}return{offsetX:-i.left+t,offsetY:-i.top+t,width:i.right-i.left+2*t,height:i.bottom-i.top+2*t}}_cloneCanvas(t,e=t.width,n=t.height){const i=document.createElement("canvas");i.width=e,i.height=n;const r=i.getContext("2d");return null==r||r.drawImage(t,0,0,e,n),i}_createLinearBezier(t,e){return[t,{x:t.x+1*(e.x-t.x)/3,y:t.y+1*(e.y-t.y)/3},{x:e.x-1*(e.x-t.x)/3,y:e.y-1*(e.y-t.y)/3},e]}_mergeBezierCurves(t,e){const n=(t,e,n)=>{const{x:i,y:r}=e,{x:o,y:s}=n,a=Math.atan2(r,i),c=Math.atan2(s,o)-a,h=Math.sqrt(Math.pow(o,2)+Math.pow(s,2))*Math.cos(c),l=h*Math.cos(a),u=h*Math.sin(a);return{x:t.x+l,y:t.y+u}},i=n(t[1],{x:t[1].x-t[0].x,y:t[1].y-t[0].y},{x:e[1].x-e[0].x,y:e[1].y-e[0].y}),r=n(e[2],{x:e[2].x-e[3].x,y:e[2].y-e[3].y},{x:t[2].x-t[3].x,y:t[2].y-t[3].y});return[t[0],i,r,e[3]]}_findConnectedVertex(t,e){const n={top:[["left",0],["right",0]],bottom:[["left",3],["right",3]],left:[["top",0],["bottom",0]],right:[["top",3],["bottom",3]]}[t];if(!n||!["first","last"].includes(e))throw TypeError(`[Warpvas] Invalid vertex connection parameters: direction="${t}", position="${e}"\nExpected values:\n- direction: "top" | "bottom" | "left" | "right"\n- position: "first" | "last"`);const i=n[{first:0,last:1}[e]];return{direction:i[0],position:{0:"first",3:"last"}[i[1]]}}_setSingleRegionVertexCoord(t,e,n,i,r=!0){const o=(n,i,o)=>{var s,a;const c=null===(a=null===(s=this.regionBoundaryCurves[t])||void 0===s?void 0:s[e])||void 0===a?void 0:a[n];if(!c)return;const h="first"===i?o:c.points[0],l="last"===i?o:c.points[3];c.points.forEach(((t,e)=>{if(!r&&[1,2].includes(e))return;const n=this._createLinearBezier(h,l)[e];t.x=n.x,t.y=n.y}))},[s,a]={[j.TOP_LEFT]:["top","first"],[j.TOP_RIGHT]:["top","last"],[j.BOTTOM_LEFT]:["bottom","first"],[j.BOTTOM_RIGHT]:["bottom","last"]}[n];o(s,a,i);const c=this._findConnectedVertex(s,a);o(c.direction,c.position,i)}updateVertexCoord(t,e,n,i,r=!0){return this._setSingleRegionVertexCoord(t,e,n,i,r),{[j.TOP_LEFT]:[{row:t-1,col:e-1,type:j.BOTTOM_RIGHT},{row:t-1,col:e,type:j.BOTTOM_LEFT},{row:t,col:e-1,type:j.TOP_RIGHT}],[j.TOP_RIGHT]:[{row:t-1,col:e+1,type:j.BOTTOM_LEFT},{row:t,col:e+1,type:j.TOP_LEFT},{row:t-1,col:e,type:j.BOTTOM_RIGHT}],[j.BOTTOM_LEFT]:[{row:t,col:e-1,type:j.BOTTOM_RIGHT},{row:t+1,col:e,type:j.TOP_LEFT},{row:t+1,col:e-1,type:j.TOP_RIGHT}],[j.BOTTOM_RIGHT]:[{row:t,col:e+1,type:j.BOTTOM_LEFT},{row:t+1,col:e,type:j.TOP_RIGHT},{row:t+1,col:e+1,type:j.TOP_LEFT}]}[n].forEach((({row:t,col:e,type:n})=>{this._setSingleRegionVertexCoord(t,e,n,i,r)})),this}updateRegionBoundCoords(t,e,n,i){return this.regionBoundaryCurves=this._initializeRegionBoundaryCurves(this.forEachRegionBoundCoords(((r,o,s,a)=>r===t&&o===e&&n===s?i:a.points.map((t=>({x:t.x,y:t.y})))))),this.updateVertexCoord(t,e,{top:j.TOP_LEFT,right:j.TOP_RIGHT,bottom:j.BOTTOM_LEFT,left:j.TOP_LEFT}[n],i[0],!1),this.updateVertexCoord(t,e,{top:j.TOP_RIGHT,right:j.BOTTOM_RIGHT,bottom:j.BOTTOM_RIGHT,left:j.BOTTOM_LEFT}[n],i[3],!1),this}forEachRegionBoundCoords(t=(t,e,n,i)=>i.points){const e=[];return this.regionBoundaryCurves.forEach(((n,i)=>{e.push([]),n.forEach(((n,r)=>{e[e.length-1].push(["top","right","left","bottom"].reduce(((e,o)=>(e[o]=t(i,r,o,n[o]),e)),{}))}))})),e}_initializeRegionBoundaryCurves(t){const e=[];return t.forEach(((t,n)=>{e.push([]),t.forEach(((t,i)=>{var r,o,s,a;const c={};for(const h in t){switch(h){case"top":{const t=null===(o=null===(r=e[n-1])||void 0===r?void 0:r[i])||void 0===o?void 0:o.bottom;t&&(c[h]=t);break}case"left":{const t=null===(a=null===(s=e[n])||void 0===s?void 0:s[i-1])||void 0===a?void 0:a.right;t&&(c[h]=t);break}}if(!c[h]){const e=t[h];c[h]=new T(e[0].x,e[0].y,e[1].x,e[1].y,e[2].x,e[2].y,e[3].x,e[3].y)}}e[e.length-1].push(c)}))})),e}getWarpState(){const t=this.forEachRegionBoundCoords();return{splitPoints:this.splitPoints,regionBounds:t}}setWarpState(t,e=null){this.splitPoints=t;const{width:n,height:i}=this.source;if(this._cacheSourceSize={width:n,height:i},this.originalRegions=this._initializeOriginalRegions(),this.originalRegionPoints=this._initializeOriginalRegionPoints(),e)this.regionBoundaryCurves=this._initializeRegionBoundaryCurves(e);else{const t=this._initializeBoundaryControlPoints(this.originalRegions);this.regionBoundaryCurves=this._initializeRegionBoundaryCurves(t)}return this}resetWarpState(t=1,e=1){return this.splitPoints=this._initializeSplitPoints(t,e),this.setWarpState(this.splitPoints)}isUnwarped(){const t=this.forEachRegionBoundCoords(((t,e,n,i)=>i.points.map((t=>({x:t.x/this.source.width,y:t.y/this.source.height})))));return 0===this.splitPoints.length&&Object.entries(t[0][0]).every((([t,e])=>{const n=["right","bottom"].includes(t)?1:0,i={top:"y",bottom:"y",left:"x",right:"x"}[t],r={top:"x",bottom:"x",left:"y",right:"y"}[t];return e.every((t=>t[i]===n))&&0===e[0][r]&&Math.abs(e[1][r]-1/3)<Number.EPSILON&&Math.abs(e[2][r]-2/3)<Number.EPSILON&&1===e[3][r]}))}getHitInfo(t){let e=null;try{this.forEachSplitRegion((([n,i,r,o],s,a,c,h,l)=>{const u=B(t,n,i,o),x=B(t,r,i,o);if(u||x)throw e={rowIndex:h,colIndex:l,row:a,col:c,after:[n,i,r,o],before:s,clickPart:u?0:1},Error()}))}catch(t){}return e}splitRegionByPoint(t,e,n,i=.05){const{tl:r,tr:o,bl:s}=this.originalRegions[t][e];let a=(n.x-r.x)/(o.x-r.x),c=(n.y-r.y)/(s.y-r.y);a<i&&(a=0),a>1-i&&(a=1),c<i&&(c=0),c>1-i&&(c=1);const h=[];this.regionBoundaryCurves.forEach(((e,n)=>{if(n!==t||0===c||1===c)return void h.push(e.map((t=>{const e={};for(const n in t)e[n]=t[n].points;return e})));const i=[],r=[];e.forEach((t=>{const{horizontal:e,vertical:n}=this._generateRegionCurves(t,[0,1],[0,c,1]),{left:o,right:s}=n[0].split(c),{left:a,right:h}=n[1].split(c);i.push({left:o.points,right:a.points,top:e[0].points,bottom:e[1].points}),r.push({left:s.points,right:h.points,top:e[1].points,bottom:e[2].points})})),h.push(i,r)})),0!==a&&1!==a&&h.forEach(((t,n)=>{const{horizontal:i,vertical:r}=this._generateRegionCurves({left:new T(t[e].left),right:new T(t[e].right),top:new T(t[e].top),bottom:new T(t[e].bottom)},[0,a,1],[0,1]),{left:o,right:s}=i[0].split(a),{left:c,right:l}=i[1].split(a);h[n].splice(e,1,{left:r[0].points,right:r[1].points,top:o.points,bottom:c.points},{left:r[1].points,right:r[2].points,top:s.points,bottom:l.points})})),this.setWarpState([...this.splitPoints,{x:(0===a?r.x:1===a?o.x:n.x)/this.source.width,y:(0===c?r.y:1===c?s.y:n.y)/this.source.height}],h)}removeRegion(...t){const e=[],{width:n,height:i}=this.source,r=(r,o,s)=>{t.some((t=>t.row===o||t.column===s))||0===o&&0===s||o===this.originalRegions.length&&0===s||0===o&&s===this.originalRegions[0].length||o===this.originalRegions.length&&s===this.originalRegions[0].length||e.some((t=>t.x===r.x||0===s||s===this.originalRegions[0].length))&&e.some((t=>t.y===r.y||0===o||o===this.originalRegions.length))||e.push({x:r.x/n,y:r.y/i})};this.originalRegions.forEach(((t,e)=>{t.forEach(((n,i)=>{const{tl:o,tr:s,bl:a,br:c}=n;r(o,e,i),i===t.length-1&&r(s,e,i+1),e===this.originalRegions.length-1&&(r(a,e+1,i),i===t.length-1&&r(c,e+1,i+1))}))}));const o=this.forEachRegionBoundCoords(),s=[...new Set(t.map((t=>t.row)))];s.sort(((t,e)=>e-t)),s.forEach((t=>{const e=o[t],n=o[t-1];e&&n&&o.splice(t-1,2,n.map(((t,n)=>({top:t.top,left:this._mergeBezierCurves(t.left,e[n].left),right:this._mergeBezierCurves(t.right,e[n].right),bottom:e[n].bottom}))))}));const a=[...new Set(t.map((t=>t.column)))];a.sort(((t,e)=>e-t)),a.forEach((t=>{o.forEach((e=>{const n=e[t],i=e[t-1];n&&i&&e.splice(t-1,2,{top:this._mergeBezierCurves(i.top,n.top),left:i.left,right:n.right,bottom:this._mergeBezierCurves(i.bottom,n.bottom)})}))})),this.setWarpState(e,o)}forEachSplitRegion(t){this.regionPoints.forEach(((e,n)=>{e.forEach(((e,i)=>{const r=e,o=this.regionCurves[n][i].vertical.length-1;r.forEach(((e,s)=>{const a=Math.floor(s/(o+1)),c=s%(o+1),h=r[s],l=r[s+1],u=r[s+o+2],x=r[s+o+1],p=this.originalRegionPoints[n][i][s],f=this.originalRegionPoints[n][i][s+1],y=this.originalRegionPoints[n][i][s+o+2],g=this.originalRegionPoints[n][i][s+o+1];l&&u&&s%(o+1)<o&&t([h,l,u,x],[p,f,y,g],a,c,n,i)}))}))}))}_generateRenderOptions(){var t,e;!this._cacheSourceSize||this._cacheSourceSize.width===this.source.width&&this._cacheSourceSize.height===this.source.height||this.setWarpState(this.splitPoints),this.regionCurves=this._generateAllRegionCurves(this.regionBoundaryCurves),this.regionPoints=this.splitStrategy.execute(this);const{offsetX:n,offsetY:i,width:r,height:o}=this.getBoundingBoxInfo();if(this._inputLimitSize&&!this._cacheInputCanvas){const t=this._inputLimitSize,{width:e,height:n}=this.source,i={width:t.width?Math.min(1,t.width/e):0,height:t.height?Math.min(1,t.height/n):0};i.width=i.width||i.height,i.height=i.height||i.width;const r=Math.min(i.width,i.height),o=document.createElement("canvas");o.width=Math.ceil(e*r),o.height=Math.ceil(n*r);const s=o.getContext("2d");null==s||s.drawImage(this.source,0,0,o.width,o.height),this._inputLimitScale=r,this._cacheInputCanvas=o}if(this._outputLimitSize){let t=1;this._outputLimitSize.width&&(t=Math.min(t,this._outputLimitSize.width/r)),this._outputLimitSize.height&&(t=Math.min(t,this._outputLimitSize.height/o)),this._outputLimitScale=t}let s=null!==(t=this._cacheInputCanvas)&&void 0!==t?t:this.source;const a=null!==(e=this._cacheOutputCanvas)&&void 0!==e?e:null;return s===a&&(console.warn("[Warpvas] Do not use the same canvas as both input and output. This will require creating a copy of the input canvas before each render operation."),s=this._cloneCanvas(s)),{inputCanvas:s,outputCanvas:a,options:{x:n,y:i,width:r,height:o,sourceScale:this._inputLimitScale,destinationScale:this._outputLimitScale}}}_getInputCanvasImageData(t=!0){var e;if(t&&this._cacheSourceImageData)return this._cacheSourceImageData;const n=null!==(e=this._cacheInputCanvas)&&void 0!==e?e:this.source,i=n.getContext("2d");if(!i)throw new Error("[Warpvas] Failed to get 2D rendering context. Please ensure that:\n1. The inputCanvas is a valid <canvas> element\n2. The browser supports Canvas API\n3. The canvas has not been tainted by cross-origin content");const r=i.getImageData(0,0,n.width,n.height);return this._cacheSourceImageData=r,r}render(){const{inputCanvas:t,outputCanvas:e,options:n}=this._generateRenderOptions();if(this._safeModeEnabled)return A(this,t,e,n);const i={"2d":A,webgl:F}[this.renderingContext];try{return i(this,t,e,n)}catch(i){if(this.renderingConfig.enableSafeRendering&&"webgl"===this.renderingContext)return this._safeModeEnabled=!0,A(this,t,e,n);throw i}}renderWithWorker(t=!0){return e(this,void 0,void 0,(function*(){const{outputCanvas:e,options:n}=this._generateRenderOptions(),i=this._getInputCanvasImageData(t);if(this._safeModeEnabled)return G(this,i,e,n);const r={"2d":W,webgl:G}[this.renderingContext];try{return r(this,i,e,n)}catch(t){if(this.renderingConfig.enableSafeRendering&&"webgl"===this.renderingContext)return this._safeModeEnabled=!0,G(this,i,e,n);throw t}}))}dispose(){this._safeModeEnabled=!1,this._cacheInputCanvas&&(this._cacheInputCanvas.width=0,this._cacheInputCanvas.height=0,this._cacheInputCanvas=null),this._cacheOutputCanvas&&(this._cacheOutputCanvas.width=0,this._cacheOutputCanvas.height=0,this._cacheOutputCanvas=null),this._cacheSourceImageData=null,this._cacheSourceSize=null,this.splitPoints=[],this.originalRegions=[],this.originalRegionPoints=[],this.regionBoundaryCurves=[],this.regionCurves=[],this.regionPoints=[]}}"function"==typeof SuppressedError&&SuppressedError;const V=(t,e,n)=>{if(t.x===e.x)return{x:t.x,y:n.y};if(t.y===e.y)return{x:n.x,y:t.y};const i=(e.y-t.y)/(e.x-t.x),r=-1/i,o=(-i*t.x+t.y+r*n.x-n.y)/(r-i);return{x:o,y:i*(o-t.x)+t.y}},X=(t,e)=>Math.sqrt(Math.pow(e.x-t.x,2)+Math.pow(e.y-t.y,2)),q=(t,e,n)=>{const i=Object.assign({},t),r={x:e.x-t.x,y:e.y-t.y};if(0===r.x&&0===r.y)return i;if(0===r.x)i.y+=n*Math.sign(r.y);else if(0===r.y)i.x+=n*Math.sign(r.x);else{const t=Math.sqrt(Math.pow(r.x,2)+Math.pow(r.y,2));i.x+=r.x*(n/t),i.y+=r.y*(n/t)}return i};var Y,J,K=Object.freeze({__proto__:null,calcBoundingBox:(t,e,n)=>{const i=Math.min(t.x,e.x,n.x),r=Math.max(t.x,e.x,n.x),o=Math.min(t.y,e.y,n.y);return{width:r-i,height:Math.max(t.y,e.y,n.y)-o}},calcCoordDistance:X,calcExpandCoord:(t,e,n,i=1)=>{const r=V(e,n,t),o=X(t,r),s=q(t,r,o+i);return{x:s.x-r.x+e.x,y:s.y-r.y+e.y}},calcIntersection:(t,e,n,i)=>{const r=(t,e)=>Math.abs(t-e)<Math.pow(.1,12);if(r(t.x,e.x)&&r(n.x,i.x))return null;if(r(t.y,e.y)&&r(n.y,i.y))return null;const o=1e4*(e.y-t.y)/Math.round(1e4*(e.x-t.x)),s=1e4*(i.y-n.y)/Math.round(1e4*(i.x-n.x)),a=t.y-o*t.x,c=n.y-s*n.x;if(Math.abs(o)===1/0)return{x:t.x,y:s*t.x+c};if(Math.abs(s)===1/0)return{x:n.x,y:o*n.x+a};const h=(c-a)/(o-s);return{x:h,y:o*h+a}},calcMatrix:(t,e)=>{const[n,i,r]=t,[o,s,a]=e,c=.1/Math.abs([...t,...e].reduce(((t,e)=>Math.min(t,e.x,e.y)),-1)),h=(t,e,n)=>{const[i,r,o,s]=t.map(Number),[a,c,h,l]=e.map(Number),[u,x,p,f]=n.map(Number),y=o-r*h/c,g=h-c*p/x,d=l-c*f/x,m=a-c*u/x,v=(y/g*d-(s-r*l/c))/(y/g*m-(i-r*a/c)),b=(d-m*v)/g;return{x:v,y:(s-i*v-o*b)/r,z:b}},l=[o.x+c,o.y+c,1,n.x+c],u=[s.x+c,s.y+c,1,i.x+c],x=[a.x+c,a.y+c,1,r.x+c],p=h(l,u,x);l[3]=n.y+c,u[3]=i.y+c,x[3]=r.y+c;const f=h(l,u,x),y=p.x,g=p.y,d=p.z;return[y,f.x,g,f.y,d,f.z]},calcPerpendicularIntersection:V,calcRelativeCoord:q,isTriangleContainsPoint:(t,e,n,i,r=.1)=>{const o=(t,e,n)=>Math.abs(t.x*(e.y-n.y)+e.x*(n.y-t.y)+n.x*(t.y-e.y))/2,s=o(e,n,i);return o(e,n,t)+o(n,i,t)+o(i,e,t)<=s+r}});!function(t){t.TOP_LEFT="tl",t.TOP_RIGHT="tr",t.BOTTOM_LEFT="bl",t.BOTTOM_RIGHT="br"}(Y||(Y={})),function(t){t.TOP="top",t.BOTTOM="bottom",t.LEFT="left",t.RIGHT="right"}(J||(J={}));const{abs:Q,cos:Z,sin:tt,acos:et,atan2:nt,sqrt:it,pow:rt}=Math;function ot(t){return t<0?-rt(-t,1/3):rt(t,1/3)}const st=Math.PI,at=2*st,ct=st/2,ht=Number.MAX_SAFE_INTEGER||9007199254740991,lt=Number.MIN_SAFE_INTEGER||-9007199254740991,ut={x:0,y:0,z:0},xt={Tvalues:[-.06405689286260563,.06405689286260563,-.1911188674736163,.1911188674736163,-.3150426796961634,.3150426796961634,-.4337935076260451,.4337935076260451,-.5454214713888396,.5454214713888396,-.6480936519369755,.6480936519369755,-.7401241915785544,.7401241915785544,-.820001985973903,.820001985973903,-.8864155270044011,.8864155270044011,-.9382745520027328,.9382745520027328,-.9747285559713095,.9747285559713095,-.9951872199970213,.9951872199970213],Cvalues:[.12793819534675216,.12793819534675216,.1258374563468283,.1258374563468283,.12167047292780339,.12167047292780339,.1155056680537256,.1155056680537256,.10744427011596563,.10744427011596563,.09761865210411388,.09761865210411388,.08619016153195327,.08619016153195327,.0733464814110803,.0733464814110803,.05929858491543678,.05929858491543678,.04427743881741981,.04427743881741981,.028531388628933663,.028531388628933663,.0123412297999872,.0123412297999872],arcfn:function(t,e){const n=e(t);let i=n.x*n.x+n.y*n.y;return void 0!==n.z&&(i+=n.z*n.z),it(i)},compute:function(t,e,n){if(0===t)return e[0].t=0,e[0];const i=e.length-1;if(1===t)return e[i].t=1,e[i];const r=1-t;let o=e;if(0===i)return e[0].t=t,e[0];if(1===i){const e={x:r*o[0].x+t*o[1].x,y:r*o[0].y+t*o[1].y,t:t};return n&&(e.z=r*o[0].z+t*o[1].z),e}if(i<4){let e,s,a,c=r*r,h=t*t,l=0;2===i?(o=[o[0],o[1],o[2],ut],e=c,s=r*t*2,a=h):3===i&&(e=c*r,s=c*t*3,a=r*h*3,l=t*h);const u={x:e*o[0].x+s*o[1].x+a*o[2].x+l*o[3].x,y:e*o[0].y+s*o[1].y+a*o[2].y+l*o[3].y,t:t};return n&&(u.z=e*o[0].z+s*o[1].z+a*o[2].z+l*o[3].z),u}const s=JSON.parse(JSON.stringify(e));for(;s.length>1;){for(let e=0;e<s.length-1;e++)s[e]={x:s[e].x+(s[e+1].x-s[e].x)*t,y:s[e].y+(s[e+1].y-s[e].y)*t},void 0!==s[e].z&&(s[e].z=s[e].z+(s[e+1].z-s[e].z)*t);s.splice(s.length-1,1)}return s[0].t=t,s[0]},computeWithRatios:function(t,e,n,i){const r=1-t,o=n,s=e;let a,c=o[0],h=o[1],l=o[2],u=o[3];return c*=r,h*=t,2===s.length?(a=c+h,{x:(c*s[0].x+h*s[1].x)/a,y:(c*s[0].y+h*s[1].y)/a,z:!!i&&(c*s[0].z+h*s[1].z)/a,t:t}):(c*=r,h*=2*r,l*=t*t,3===s.length?(a=c+h+l,{x:(c*s[0].x+h*s[1].x+l*s[2].x)/a,y:(c*s[0].y+h*s[1].y+l*s[2].y)/a,z:!!i&&(c*s[0].z+h*s[1].z+l*s[2].z)/a,t:t}):(c*=r,h*=1.5*r,l*=3*r,u*=t*t*t,4===s.length?(a=c+h+l+u,{x:(c*s[0].x+h*s[1].x+l*s[2].x+u*s[3].x)/a,y:(c*s[0].y+h*s[1].y+l*s[2].y+u*s[3].y)/a,z:!!i&&(c*s[0].z+h*s[1].z+l*s[2].z+u*s[3].z)/a,t:t}):void 0))},derive:function(t,e){const n=[];for(let i=t,r=i.length,o=r-1;r>1;r--,o--){const t=[];for(let n,r=0;r<o;r++)n={x:o*(i[r+1].x-i[r].x),y:o*(i[r+1].y-i[r].y)},e&&(n.z=o*(i[r+1].z-i[r].z)),t.push(n);n.push(t),i=t}return n},between:function(t,e,n){return e<=t&&t<=n||xt.approximately(t,e)||xt.approximately(t,n)},approximately:function(t,e,n){return Q(t-e)<=(n||1e-6)},length:function(t){const e=xt.Tvalues.length;let n=0;for(let i,r=0;r<e;r++)i=.5*xt.Tvalues[r]+.5,n+=xt.Cvalues[r]*xt.arcfn(i,t);return.5*n},map:function(t,e,n,i,r){return i+(t-e)/(n-e)*(r-i)},lerp:function(t,e,n){const i={x:e.x+t*(n.x-e.x),y:e.y+t*(n.y-e.y)};return void 0!==e.z&&void 0!==n.z&&(i.z=e.z+t*(n.z-e.z)),i},pointToString:function(t){let e=t.x+"/"+t.y;return void 0!==t.z&&(e+="/"+t.z),e},pointsToString:function(t){return"["+t.map(xt.pointToString).join(", ")+"]"},copy:function(t){return JSON.parse(JSON.stringify(t))},angle:function(t,e,n){const i=e.x-t.x,r=e.y-t.y,o=n.x-t.x,s=n.y-t.y;return nt(i*s-r*o,i*o+r*s)},round:function(t,e){const n=""+t,i=n.indexOf(".");return parseFloat(n.substring(0,i+1+e))},dist:function(t,e){const n=t.x-e.x,i=t.y-e.y;return it(n*n+i*i)},closest:function(t,e){let n,i,r=rt(2,63);return t.forEach((function(t,o){i=xt.dist(e,t),i<r&&(r=i,n=o)})),{mdist:r,mpos:n}},abcratio:function(t,e){if(2!==e&&3!==e)return!1;if(void 0===t)t=.5;else if(0===t||1===t)return t;const n=rt(t,e)+rt(1-t,e);return Q((n-1)/n)},projectionratio:function(t,e){if(2!==e&&3!==e)return!1;if(void 0===t)t=.5;else if(0===t||1===t)return t;const n=rt(1-t,e);return n/(rt(t,e)+n)},lli8:function(t,e,n,i,r,o,s,a){const c=(t-n)*(o-a)-(e-i)*(r-s);return 0!=c&&{x:((t*i-e*n)*(r-s)-(t-n)*(r*a-o*s))/c,y:((t*i-e*n)*(o-a)-(e-i)*(r*a-o*s))/c}},lli4:function(t,e,n,i){const r=t.x,o=t.y,s=e.x,a=e.y,c=n.x,h=n.y,l=i.x,u=i.y;return xt.lli8(r,o,s,a,c,h,l,u)},lli:function(t,e){return xt.lli4(t,t.c,e,e.c)},makeline:function(t,e){return new zt(t.x,t.y,(t.x+e.x)/2,(t.y+e.y)/2,e.x,e.y)},findbbox:function(t){let e=ht,n=ht,i=lt,r=lt;return t.forEach((function(t){const o=t.bbox();e>o.x.min&&(e=o.x.min),n>o.y.min&&(n=o.y.min),i<o.x.max&&(i=o.x.max),r<o.y.max&&(r=o.y.max)})),{x:{min:e,mid:(e+i)/2,max:i,size:i-e},y:{min:n,mid:(n+r)/2,max:r,size:r-n}}},shapeintersections:function(t,e,n,i,r){if(!xt.bboxoverlap(e,i))return[];const o=[],s=[t.startcap,t.forward,t.back,t.endcap],a=[n.startcap,n.forward,n.back,n.endcap];return s.forEach((function(e){e.virtual||a.forEach((function(i){if(i.virtual)return;const s=e.intersects(i,r);s.length>0&&(s.c1=e,s.c2=i,s.s1=t,s.s2=n,o.push(s))}))})),o},makeshape:function(t,e,n){const i=e.points.length,r=t.points.length,o=xt.makeline(e.points[i-1],t.points[0]),s=xt.makeline(t.points[r-1],e.points[0]),a={startcap:o,forward:t,back:e,endcap:s,bbox:xt.findbbox([o,t,e,s]),intersections:function(t){return xt.shapeintersections(a,a.bbox,t,t.bbox,n)}};return a},getminmax:function(t,e,n){if(!n)return{min:0,max:0};let i,r,o=ht,s=lt;-1===n.indexOf(0)&&(n=[0].concat(n)),-1===n.indexOf(1)&&n.push(1);for(let a=0,c=n.length;a<c;a++)i=n[a],r=t.get(i),r[e]<o&&(o=r[e]),r[e]>s&&(s=r[e]);return{min:o,mid:(o+s)/2,max:s,size:s-o}},align:function(t,e){const n=e.p1.x,i=e.p1.y,r=-nt(e.p2.y-i,e.p2.x-n);return t.map((function(t){return{x:(t.x-n)*Z(r)-(t.y-i)*tt(r),y:(t.x-n)*tt(r)+(t.y-i)*Z(r)}}))},roots:function(t,e){e=e||{p1:{x:0,y:0},p2:{x:1,y:0}};const n=t.length-1,i=xt.align(t,e),r=function(t){return 0<=t&&t<=1};if(2===n){const t=i[0].y,e=i[1].y,n=i[2].y,o=t-2*e+n;if(0!==o){const i=-it(e*e-t*n),s=-t+e;return[-(i+s)/o,-(-i+s)/o].filter(r)}return e!==n&&0===o?[(2*e-n)/(2*e-2*n)].filter(r):[]}const o=i[0].y,s=i[1].y,a=i[2].y;let c=3*s-o-3*a+i[3].y,h=3*o-6*s+3*a,l=-3*o+3*s,u=o;if(xt.approximately(c,0)){if(xt.approximately(h,0))return xt.approximately(l,0)?[]:[-u/l].filter(r);const t=it(l*l-4*h*u),e=2*h;return[(t-l)/e,(-l-t)/e].filter(r)}h/=c,l/=c,u/=c;const x=(3*l-h*h)/3,p=x/3,f=(2*h*h*h-9*h*l+27*u)/27,y=f/2,g=y*y+p*p*p;let d,m,v,b,_;if(g<0){const t=-x/3,e=it(t*t*t),n=-f/(2*e),i=et(n<-1?-1:n>1?1:n),o=2*ot(e);return v=o*Z(i/3)-h/3,b=o*Z((i+at)/3)-h/3,_=o*Z((i+2*at)/3)-h/3,[v,b,_].filter(r)}if(0===g)return d=y<0?ot(-y):-ot(y),v=2*d-h/3,b=-d-h/3,[v,b].filter(r);{const t=it(g);return d=ot(-y+t),m=ot(y+t),[d-m-h/3].filter(r)}},droots:function(t){if(3===t.length){const e=t[0],n=t[1],i=t[2],r=e-2*n+i;if(0!==r){const t=-it(n*n-e*i),o=-e+n;return[-(t+o)/r,-(-t+o)/r]}return n!==i&&0===r?[(2*n-i)/(2*(n-i))]:[]}if(2===t.length){const e=t[0],n=t[1];return e!==n?[e/(e-n)]:[]}return[]},curvature:function(t,e,n,i,r){let o,s,a,c,h=0,l=0;const u=xt.compute(t,e),x=xt.compute(t,n),p=u.x*u.x+u.y*u.y;if(i?(o=it(rt(u.y*x.z-x.y*u.z,2)+rt(u.z*x.x-x.z*u.x,2)+rt(u.x*x.y-x.x*u.y,2)),s=rt(p+u.z*u.z,1.5)):(o=u.x*x.y-u.y*x.x,s=rt(p,1.5)),0===o||0===s)return{k:0,r:0};if(h=o/s,l=s/o,!r){const r=xt.curvature(t-.001,e,n,i,!0).k,o=xt.curvature(t+.001,e,n,i,!0).k;c=(o-h+(h-r))/2,a=(Q(o-h)+Q(h-r))/2}return{k:h,r:l,dk:c,adk:a}},inflections:function(t){if(t.length<4)return[];const e=xt.align(t,{p1:t[0],p2:t.slice(-1)[0]}),n=e[2].x*e[1].y,i=e[3].x*e[1].y,r=e[1].x*e[2].y,o=18*(-3*n+2*i+3*r-e[3].x*e[2].y),s=18*(3*n-i-3*r),a=18*(r-n);if(xt.approximately(o,0)){if(!xt.approximately(s,0)){let t=-a/s;if(0<=t&&t<=1)return[t]}return[]}const c=2*o;if(xt.approximately(c,0))return[];const h=s*s-4*o*a;if(h<0)return[];const l=Math.sqrt(h);return[(l-s)/c,-(s+l)/c].filter((function(t){return 0<=t&&t<=1}))},bboxoverlap:function(t,e){const n=["x","y"],i=n.length;for(let r,o,s,a,c=0;c<i;c++)if(r=n[c],o=t[r].mid,s=e[r].mid,a=(t[r].size+e[r].size)/2,Q(o-s)>=a)return!1;return!0},expandbox:function(t,e){e.x.min<t.x.min&&(t.x.min=e.x.min),e.y.min<t.y.min&&(t.y.min=e.y.min),e.z&&e.z.min<t.z.min&&(t.z.min=e.z.min),e.x.max>t.x.max&&(t.x.max=e.x.max),e.y.max>t.y.max&&(t.y.max=e.y.max),e.z&&e.z.max>t.z.max&&(t.z.max=e.z.max),t.x.mid=(t.x.min+t.x.max)/2,t.y.mid=(t.y.min+t.y.max)/2,t.z&&(t.z.mid=(t.z.min+t.z.max)/2),t.x.size=t.x.max-t.x.min,t.y.size=t.y.max-t.y.min,t.z&&(t.z.size=t.z.max-t.z.min)},pairiteration:function(t,e,n){const i=t.bbox(),r=e.bbox(),o=1e5,s=n||.5;if(i.x.size+i.y.size<s&&r.x.size+r.y.size<s)return[(o*(t._t1+t._t2)/2|0)/o+"/"+(o*(e._t1+e._t2)/2|0)/o];let a=t.split(.5),c=e.split(.5),h=[{left:a.left,right:c.left},{left:a.left,right:c.right},{left:a.right,right:c.right},{left:a.right,right:c.left}];h=h.filter((function(t){return xt.bboxoverlap(t.left.bbox(),t.right.bbox())}));let l=[];return 0===h.length||(h.forEach((function(t){l=l.concat(xt.pairiteration(t.left,t.right,s))})),l=l.filter((function(t,e){return l.indexOf(t)===e}))),l},getccenter:function(t,e,n){const i=e.x-t.x,r=e.y-t.y,o=n.x-e.x,s=n.y-e.y,a=i*Z(ct)-r*tt(ct),c=i*tt(ct)+r*Z(ct),h=o*Z(ct)-s*tt(ct),l=o*tt(ct)+s*Z(ct),u=(t.x+e.x)/2,x=(t.y+e.y)/2,p=(e.x+n.x)/2,f=(e.y+n.y)/2,y=u+a,g=x+c,d=p+h,m=f+l,v=xt.lli8(u,x,y,g,p,f,d,m),b=xt.dist(v,t);let _,z=nt(t.y-v.y,t.x-v.x),w=nt(e.y-v.y,e.x-v.x),E=nt(n.y-v.y,n.x-v.x);return z<E?((z>w||w>E)&&(z+=at),z>E&&(_=E,E=z,z=_)):E<w&&w<z?(_=E,E=z,z=_):E+=at,v.s=z,v.e=E,v.r=b,v},numberSort:function(t,e){return t-e}};class pt{constructor(t){this.curves=[],this._3d=!1,t&&(this.curves=t,this._3d=this.curves[0]._3d)}valueOf(){return this.toString()}toString(){return"["+this.curves.map((function(t){return xt.pointsToString(t.points)})).join(", ")+"]"}addCurve(t){this.curves.push(t),this._3d=this._3d||t._3d}length(){return this.curves.map((function(t){return t.length()})).reduce((function(t,e){return t+e}))}curve(t){return this.curves[t]}bbox(){const t=this.curves;for(var e=t[0].bbox(),n=1;n<t.length;n++)xt.expandbox(e,t[n].bbox());return e}offset(t){const e=[];return this.curves.forEach((function(n){e.push(...n.offset(t))})),new pt(e)}}const{abs:ft,min:yt,max:gt,cos:dt,sin:mt,acos:vt,sqrt:bt}=Math,_t=Math.PI;class zt{constructor(t){let e=t&&t.forEach?t:Array.from(arguments).slice(),n=!1;if("object"==typeof e[0]){n=e.length;const t=[];e.forEach((function(e){["x","y","z"].forEach((function(n){void 0!==e[n]&&t.push(e[n])}))})),e=t}let i=!1;const r=e.length;if(n){if(n>4){if(1!==arguments.length)throw new Error("Only new Bezier(point[]) is accepted for 4th and higher order curves");i=!0}}else if(6!==r&&8!==r&&9!==r&&12!==r&&1!==arguments.length)throw new Error("Only new Bezier(point[]) is accepted for 4th and higher order curves");const o=this._3d=!i&&(9===r||12===r)||t&&t[0]&&void 0!==t[0].z,s=this.points=[];for(let t=0,n=o?3:2;t<r;t+=n){var a={x:e[t],y:e[t+1]};o&&(a.z=e[t+2]),s.push(a)}const c=this.order=s.length-1,h=this.dims=["x","y"];o&&h.push("z"),this.dimlen=h.length;const l=xt.align(s,{p1:s[0],p2:s[c]}),u=xt.dist(s[0],s[c]);this._linear=l.reduce(((t,e)=>t+ft(e.y)),0)<u/50,this._lut=[],this._t1=0,this._t2=1,this.update()}static quadraticFromPoints(t,e,n,i){if(void 0===i&&(i=.5),0===i)return new zt(e,e,n);if(1===i)return new zt(t,e,e);const r=zt.getABC(2,t,e,n,i);return new zt(t,r.A,n)}static cubicFromPoints(t,e,n,i,r){void 0===i&&(i=.5);const o=zt.getABC(3,t,e,n,i);void 0===r&&(r=xt.dist(e,o.C));const s=r*(1-i)/i,a=xt.dist(t,n),c=(n.x-t.x)/a,h=(n.y-t.y)/a,l=r*c,u=r*h,x=s*c,p=s*h,f=e.x-l,y=e.y-u,g=e.x+x,d=e.y+p,m=o.A,v=m.x+(f-m.x)/(1-i),b=m.y+(y-m.y)/(1-i),_=m.x+(g-m.x)/i,z=m.y+(d-m.y)/i,w={x:t.x+(v-t.x)/i,y:t.y+(b-t.y)/i},E={x:n.x+(_-n.x)/(1-i),y:n.y+(z-n.y)/(1-i)};return new zt(t,w,E,n)}static getUtils(){return xt}getUtils(){return zt.getUtils()}static get PolyBezier(){return pt}valueOf(){return this.toString()}toString(){return xt.pointsToString(this.points)}toSVG(){if(this._3d)return!1;const t=this.points,e=["M",t[0].x,t[0].y,2===this.order?"Q":"C"];for(let n=1,i=t.length;n<i;n++)e.push(t[n].x),e.push(t[n].y);return e.join(" ")}setRatios(t){if(t.length!==this.points.length)throw new Error("incorrect number of ratio values");this.ratios=t,this._lut=[]}verify(){const t=this.coordDigest();t!==this._print&&(this._print=t,this.update())}coordDigest(){return this.points.map((function(t,e){return""+e+t.x+t.y+(t.z?t.z:0)})).join("")}update(){this._lut=[],this.dpoints=xt.derive(this.points,this._3d),this.computedirection()}computedirection(){const t=this.points,e=xt.angle(t[0],t[this.order],t[1]);this.clockwise=e>0}length(){return xt.length(this.derivative.bind(this))}static getABC(t=2,e,n,i,r=.5){const o=xt.projectionratio(r,t),s=1-o,a={x:o*e.x+s*i.x,y:o*e.y+s*i.y},c=xt.abcratio(r,t);return{A:{x:n.x+(n.x-a.x)/c,y:n.y+(n.y-a.y)/c},B:n,C:a,S:e,E:i}}getABC(t,e){e=e||this.get(t);let n=this.points[0],i=this.points[this.order];return zt.getABC(this.order,n,e,i,t)}getLUT(t){if(this.verify(),t=t||100,this._lut.length===t+1)return this._lut;this._lut=[],t++,this._lut=[];for(let e,n,i=0;i<t;i++)n=i/(t-1),e=this.compute(n),e.t=n,this._lut.push(e);return this._lut}on(e,n){n=n||5;const i=this.getLUT(),r=[];for(let t,o=0,s=0;o<i.length;o++)t=i[o],xt.dist(t,e)<n&&(r.push(t),s+=o/i.length);return!!r.length&&(t/=r.length)}project(t){const e=this.getLUT(),n=e.length-1,i=xt.closest(e,t),r=i.mpos,o=(r-1)/n,s=(r+1)/n,a=.1/n;let c,h=i.mdist,l=o,u=l;h+=1;for(let e;l<s+a;l+=a)c=this.compute(l),e=xt.dist(t,c),e<h&&(h=e,u=l);return u=u<0?0:u>1?1:u,c=this.compute(u),c.t=u,c.d=h,c}get(t){return this.compute(t)}point(t){return this.points[t]}compute(t){return this.ratios?xt.computeWithRatios(t,this.points,this.ratios,this._3d):xt.compute(t,this.points,this._3d,this.ratios)}raise(){const t=this.points,e=[t[0]],n=t.length;for(let i,r,o=1;o<n;o++)i=t[o],r=t[o-1],e[o]={x:(n-o)/n*i.x+o/n*r.x,y:(n-o)/n*i.y+o/n*r.y};return e[n]=t[n-1],new zt(e)}derivative(t){return xt.compute(t,this.dpoints[0],this._3d)}dderivative(t){return xt.compute(t,this.dpoints[1],this._3d)}align(){let t=this.points;return new zt(xt.align(t,{p1:t[0],p2:t[t.length-1]}))}curvature(t){return xt.curvature(t,this.dpoints[0],this.dpoints[1],this._3d)}inflections(){return xt.inflections(this.points)}normal(t){return this._3d?this.__normal3(t):this.__normal2(t)}__normal2(t){const e=this.derivative(t),n=bt(e.x*e.x+e.y*e.y);return{t:t,x:-e.y/n,y:e.x/n}}__normal3(t){const e=this.derivative(t),n=this.derivative(t+.01),i=bt(e.x*e.x+e.y*e.y+e.z*e.z),r=bt(n.x*n.x+n.y*n.y+n.z*n.z);e.x/=i,e.y/=i,e.z/=i,n.x/=r,n.y/=r,n.z/=r;const o={x:n.y*e.z-n.z*e.y,y:n.z*e.x-n.x*e.z,z:n.x*e.y-n.y*e.x},s=bt(o.x*o.x+o.y*o.y+o.z*o.z);o.x/=s,o.y/=s,o.z/=s;const a=[o.x*o.x,o.x*o.y-o.z,o.x*o.z+o.y,o.x*o.y+o.z,o.y*o.y,o.y*o.z-o.x,o.x*o.z-o.y,o.y*o.z+o.x,o.z*o.z];return{t:t,x:a[0]*e.x+a[1]*e.y+a[2]*e.z,y:a[3]*e.x+a[4]*e.y+a[5]*e.z,z:a[6]*e.x+a[7]*e.y+a[8]*e.z}}hull(t){let e=this.points,n=[],i=[],r=0;for(i[r++]=e[0],i[r++]=e[1],i[r++]=e[2],3===this.order&&(i[r++]=e[3]);e.length>1;){n=[];for(let o,s=0,a=e.length-1;s<a;s++)o=xt.lerp(t,e[s],e[s+1]),i[r++]=o,n.push(o);e=n}return i}split(t,e){if(0===t&&e)return this.split(e).left;if(1===e)return this.split(t).right;const n=this.hull(t),i={left:2===this.order?new zt([n[0],n[3],n[5]]):new zt([n[0],n[4],n[7],n[9]]),right:2===this.order?new zt([n[5],n[4],n[2]]):new zt([n[9],n[8],n[6],n[3]]),span:n};return i.left._t1=xt.map(0,0,1,this._t1,this._t2),i.left._t2=xt.map(t,0,1,this._t1,this._t2),i.right._t1=xt.map(t,0,1,this._t1,this._t2),i.right._t2=xt.map(1,0,1,this._t1,this._t2),e?(e=xt.map(e,t,1,0,1),i.right.split(e).left):i}extrema(){const t={};let e=[];return this.dims.forEach(function(n){let i=function(t){return t[n]},r=this.dpoints[0].map(i);t[n]=xt.droots(r),3===this.order&&(r=this.dpoints[1].map(i),t[n]=t[n].concat(xt.droots(r))),t[n]=t[n].filter((function(t){return t>=0&&t<=1})),e=e.concat(t[n].sort(xt.numberSort))}.bind(this)),t.values=e.sort(xt.numberSort).filter((function(t,n){return e.indexOf(t)===n})),t}bbox(){const t=this.extrema(),e={};return this.dims.forEach(function(n){e[n]=xt.getminmax(this,n,t[n])}.bind(this)),e}overlaps(t){const e=this.bbox(),n=t.bbox();return xt.bboxoverlap(e,n)}offset(t,e){if(void 0!==e){const n=this.get(t),i=this.normal(t),r={c:n,n:i,x:n.x+i.x*e,y:n.y+i.y*e};return this._3d&&(r.z=n.z+i.z*e),r}if(this._linear){const e=this.normal(0),n=this.points.map((function(n){const i={x:n.x+t*e.x,y:n.y+t*e.y};return n.z&&e.z&&(i.z=n.z+t*e.z),i}));return[new zt(n)]}return this.reduce().map((function(e){return e._linear?e.offset(t)[0]:e.scale(t)}))}simple(){if(3===this.order){const t=xt.angle(this.points[0],this.points[3],this.points[1]),e=xt.angle(this.points[0],this.points[3],this.points[2]);if(t>0&&e<0||t<0&&e>0)return!1}const t=this.normal(0),e=this.normal(1);let n=t.x*e.x+t.y*e.y;return this._3d&&(n+=t.z*e.z),ft(vt(n))<_t/3}reduce(){let t,e,n=0,i=0,r=.01,o=[],s=[],a=this.extrema().values;for(-1===a.indexOf(0)&&(a=[0].concat(a)),-1===a.indexOf(1)&&a.push(1),n=a[0],t=1;t<a.length;t++)i=a[t],e=this.split(n,i),e._t1=n,e._t2=i,o.push(e),n=i;return o.forEach((function(t){for(n=0,i=0;i<=1;)for(i=n+r;i<=1.01;i+=r)if(e=t.split(n,i),!e.simple()){if(i-=r,ft(n-i)<r)return[];e=t.split(n,i),e._t1=xt.map(n,0,1,t._t1,t._t2),e._t2=xt.map(i,0,1,t._t1,t._t2),s.push(e),n=i;break}n<1&&(e=t.split(n,1),e._t1=xt.map(n,0,1,t._t1,t._t2),e._t2=t._t2,s.push(e))})),s}translate(t,e,n){n="number"==typeof n?n:e;const i=this.order;let r=this.points.map(((t,r)=>(1-r/i)*e+r/i*n));return new zt(this.points.map(((e,n)=>({x:e.x+t.x*r[n],y:e.y+t.y*r[n]}))))}scale(t){const e=this.order;let n=!1;if("function"==typeof t&&(n=t),n&&2===e)return this.raise().scale(n);const i=this.clockwise,r=this.points;if(this._linear)return this.translate(this.normal(0),n?n(0):t,n?n(1):t);const o=n?n(0):t,s=n?n(1):t,a=[this.offset(0,10),this.offset(1,10)],c=[],h=xt.lli4(a[0],a[0].c,a[1],a[1].c);if(!h)throw new Error("cannot scale this curve. Try reducing it first.");return[0,1].forEach((function(t){const n=c[t*e]=xt.copy(r[t*e]);n.x+=(t?s:o)*a[t].n.x,n.y+=(t?s:o)*a[t].n.y})),n?([0,1].forEach((function(o){if(2!==e||!o){var s=r[o+1],a={x:s.x-h.x,y:s.y-h.y},l=n?n((o+1)/e):t;n&&!i&&(l=-l);var u=bt(a.x*a.x+a.y*a.y);a.x/=u,a.y/=u,c[o+1]={x:s.x+l*a.x,y:s.y+l*a.y}}})),new zt(c)):([0,1].forEach((t=>{if(2===e&&t)return;const n=c[t*e],i=this.derivative(t),o={x:n.x+i.x,y:n.y+i.y};c[t+1]=xt.lli4(n,o,h,r[t+1])})),new zt(c))}outline(t,e,n,i){if(e=void 0===e?t:e,this._linear){const r=this.normal(0),o=this.points[0],s=this.points[this.points.length-1];let a,c,h;void 0===n&&(n=t,i=e),a={x:o.x+r.x*t,y:o.y+r.y*t},h={x:s.x+r.x*n,y:s.y+r.y*n},c={x:(a.x+h.x)/2,y:(a.y+h.y)/2};const l=[a,c,h];a={x:o.x-r.x*e,y:o.y-r.y*e},h={x:s.x-r.x*i,y:s.y-r.y*i},c={x:(a.x+h.x)/2,y:(a.y+h.y)/2};const u=[h,c,a],x=xt.makeline(u[2],l[0]),p=xt.makeline(l[2],u[0]),f=[x,new zt(l),p,new zt(u)];return new pt(f)}const r=this.reduce(),o=r.length,s=[];let a,c=[],h=0,l=this.length();const u=void 0!==n&&void 0!==i;function x(t,e,n,i,r){return function(o){const s=i/n,a=(i+r)/n,c=e-t;return xt.map(o,0,1,t+s*c,t+a*c)}}r.forEach((function(r){const o=r.length();u?(s.push(r.scale(x(t,n,l,h,o))),c.push(r.scale(x(-e,-i,l,h,o)))):(s.push(r.scale(t)),c.push(r.scale(-e))),h+=o})),c=c.map((function(t){return a=t.points,a[3]?t.points=[a[3],a[2],a[1],a[0]]:t.points=[a[2],a[1],a[0]],t})).reverse();const p=s[0].points[0],f=s[o-1].points[s[o-1].points.length-1],y=c[o-1].points[c[o-1].points.length-1],g=c[0].points[0],d=xt.makeline(y,p),m=xt.makeline(f,g),v=[d].concat(s).concat([m]).concat(c);return new pt(v)}outlineshapes(t,e,n){e=e||t;const i=this.outline(t,e).curves,r=[];for(let t=1,e=i.length;t<e/2;t++){const o=xt.makeshape(i[t],i[e-t],n);o.startcap.virtual=t>1,o.endcap.virtual=t<e/2-1,r.push(o)}return r}intersects(t,e){return t?t.p1&&t.p2?this.lineIntersects(t):(t instanceof zt&&(t=t.reduce()),this.curveintersects(this.reduce(),t,e)):this.selfintersects(e)}lineIntersects(t){const e=yt(t.p1.x,t.p2.x),n=yt(t.p1.y,t.p2.y),i=gt(t.p1.x,t.p2.x),r=gt(t.p1.y,t.p2.y);return xt.roots(this.points,t).filter((t=>{var o=this.get(t);return xt.between(o.x,e,i)&&xt.between(o.y,n,r)}))}selfintersects(t){const e=this.reduce(),n=e.length-2,i=[];for(let r,o,s,a=0;a<n;a++)o=e.slice(a,a+1),s=e.slice(a+2),r=this.curveintersects(o,s,t),i.push(...r);return i}curveintersects(t,e,n){const i=[];t.forEach((function(t){e.forEach((function(e){t.overlaps(e)&&i.push({left:t,right:e})}))}));let r=[];return i.forEach((function(t){const e=xt.pairiteration(t.left,t.right,n);e.length>0&&(r=r.concat(e))})),r}arcs(t){return t=t||.5,this._iterate(t,[])}_error(t,e,n,i){const r=(i-n)/4,o=this.get(n+r),s=this.get(i-r),a=xt.dist(t,e),c=xt.dist(t,o),h=xt.dist(t,s);return ft(c-a)+ft(h-a)}_iterate(t,e){let n,i=0,r=1;do{n=0,r=1;let o,s,a,c,h,l=this.get(i),u=!1,x=!1,p=r,f=1;do{if(x=u,c=a,p=(i+r)/2,o=this.get(p),s=this.get(r),a=xt.getccenter(l,o,s),a.interval={start:i,end:r},u=this._error(a,l,i,r)<=t,h=x&&!u,h||(f=r),u){if(r>=1){if(a.interval.end=f=1,c=a,r>1){let t={x:a.x+a.r*dt(a.e),y:a.y+a.r*mt(a.e)};a.e+=xt.angle({x:a.x,y:a.y},t,this.get(1))}break}r+=(r-i)/2}else r=p}while(!h&&n++<100);if(n>=100)break;c=c||a,e.push(c),i=f}while(r<1);return e}}const wt={name:"perspective",execute:t=>{const e=[],n=(t,e,n,i)=>{if(t===e)return n/i;const r=1-(1/(1+n/i*(t/e-1))*t-e)/(t-e);return Math.min(1,Math.max(0,r))};return t.regionBoundaryCurves.forEach(((i,r)=>{const o=[];i.forEach(((e,i)=>{const s=[],a=e,c={tl:a.top.points[0],tr:a.top.points[3],bl:a.bottom.points[0],br:a.bottom.points[3]};if((t=>{const e=K.calcIntersection(t.tl,t.tr,t.bl,t.br),n=K.calcIntersection(t.tl,t.bl,t.tr,t.br),i=e=>e&&Object.values(t).some(((t,n,i)=>K.isTriangleContainsPoint(e,i[n],i[(n+1)%4],i[(n+2)%4])));return i(e)||i(n)})(c))throw new Error("[Warpvas: Perspective] Invalid perspective shape: The four control points cannot form a triangle or cross each other");const h={left:new zt(a.left.points).length(),right:new zt(a.right.points).length(),top:new zt(a.top.points).length(),bottom:new zt(a.bottom.points).length()},l=K.calcIntersection(c.tl,c.bl,c.tr,c.br),u=K.calcIntersection(c.tl,c.tr,c.bl,c.br),{vertical:x,horizontal:p}=t.regionCurves[r][i],f=p.length-1,y=x.length-1;for(let t=0;t<p.length;t++)for(let e=0;e<x.length;e++){let i=a.top.get(e/y),r=a.bottom.get(e/y);if(u){const t=K.calcCoordDistance(c.tl,u)/K.calcCoordDistance(c.tr,u),o=n(h.left,h.left/t,e,y);i=a.top.get(o);const s=K.calcCoordDistance(c.bl,u)/K.calcCoordDistance(c.br,u),l=n(h.left,h.left/s,e,y);r=a.bottom.get(l)}let o=a.left.get(t/f),x=a.right.get(t/f);if(l){const e=K.calcCoordDistance(c.tl,l)/K.calcCoordDistance(c.bl,l),i=n(h.top,h.top/e,t,f);o=a.left.get(i);const r=K.calcCoordDistance(c.tr,l)/K.calcCoordDistance(c.br,l),s=n(h.top,h.top/r,t,f);x=a.right.get(s)}const p=K.calcIntersection(i,r,o,x);p?s.push(p):s.push(i)}o.push(s)})),e.push(o)})),e}};!async function(){const t=new Image;t.onload=()=>{const{naturalHeight:e}=t,n=new $(t);n.setOutputLimitSize({height:300}),n.setSplitStrategy(wt),n.setRenderingConfig({enableGridDisplay:!0}),n.updateVertexCoord(0,0,"tl",{x:0,y:e/3}),n.updateVertexCoord(0,0,"bl",{x:0,y:e/3*2}),document.body.appendChild(n.render())},t.crossOrigin="Anonymous",t.src="https://i.imgur.com/pBVj9NN.png"}()}();
//# sourceMappingURL=index.js.map
